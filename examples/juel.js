// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5F6hf":[function(require,module,exports) {
var _juelGlobal = require("./src/JuelGlobal");
var _isMobile = require("./src/_Utils/IsMobile");
var _vh = require("./src/_Utils/Vh");
var _accordion = require("./src/Accordion/Accordion");
var _carousel = require("./src/Carousel/Carousel");
var _loading = require("./src/Loading/Loading");
var _tooltip = require("./src/Tooltip/Tooltip");
var _tabs = require("./src/Tabs/Tabs");
var _badge = require("./src/Badge/Badge");
var _select = require("./src/Select/Select");
var _scrollPane = require("./src/ScrollPane/ScrollPane");
var _list = require("./src/List/List");
var _menu = require("./src/Menu/Menu");
var _modal = require("./src/Modal/Modal");
var _toggle = require("./src/Toggle/Toggle");
var _button = require("./src/Button/Button");
var _text = require("./src/Text/Text");
var _memo = require("./src/Memo/Memo");
var _range = require("./src/Range/Range");
var _tickbox = require("./src/Tickbox/Tickbox");
var _progress = require("./src/Progress/Progress");
var _embed = require("./src/Embed/Embed");
var _random = require("./src/Random/Random");
var _navBar = require("./src/NavBar/NavBar");
var _chart = require("./src/Chart/Chart");
var _chartDataSet = require("./src/Chart/ChartDataSet");
var _draggableContainer = require("./src/DraggableContainer/DraggableContainer");
var _imagePreload = require("./src/ImagePreload/ImagePreload");
var _page = require("./src/Page/Page");
var _toolbar = require("./src/Toolbar/Toolbar");
var _toolbarItem = require("./src/Toolbar/ToolbarItem");
var _lightbox = require("./src/Lightbox/Lightbox");
var _flip = require("./src/Flip/Flip");
var _tilt = require("./src/Tilt/Tilt");
var _icons = require("./src/Icons/Icons");
var _contents = require("./src/Contents/Contents");
var _template = require("./src/Template/Template");
var _speechSection = require("./src/SpeechSection/SpeechSection");
var _fishEye = require("./src/FishEye/FishEye");
var _boxMenu = require("./src/BoxMenu/BoxMenu");
var _spinner = require("./src/Spinner/Spinner");
var _reciteMe = require("./src/ReciteMe/ReciteMe");
$(function() {
    (0, _isMobile.IsMobile)();
    (0, _vh.Vh)();
});

},{"./src/JuelGlobal":"9dDzu","./src/_Utils/IsMobile":"5Z54X","./src/_Utils/Vh":"6DlUO","./src/Accordion/Accordion":"cBFL0","./src/Carousel/Carousel":"l43kz","./src/Loading/Loading":"jsbjR","./src/Tooltip/Tooltip":"htWbt","./src/Tabs/Tabs":"6KMJY","./src/Badge/Badge":"geKcT","./src/Select/Select":"71Q1X","./src/ScrollPane/ScrollPane":"2rV7j","./src/List/List":"kdVmJ","./src/Menu/Menu":"LBqTL","./src/Modal/Modal":"inF6U","./src/Toggle/Toggle":"8Dnb4","./src/Button/Button":"i46xy","./src/Text/Text":"4Gmhr","./src/Memo/Memo":"1yiyr","./src/Range/Range":"ex6fn","./src/Tickbox/Tickbox":"80nuG","./src/Progress/Progress":"dSYyA","./src/Embed/Embed":"AJydg","./src/Random/Random":"bJejc","./src/NavBar/NavBar":"9ZBpR","./src/Chart/Chart":"liS0w","./src/Chart/ChartDataSet":"k8p14","./src/DraggableContainer/DraggableContainer":"4OQeM","./src/ImagePreload/ImagePreload":"gp15G","./src/Page/Page":"9lAlL","./src/Toolbar/Toolbar":"9SPFn","./src/Toolbar/ToolbarItem":"fV3at","./src/Lightbox/Lightbox":"e57Ex","./src/Flip/Flip":"cm6wg","./src/Tilt/Tilt":"7XKFx","./src/Icons/Icons":"h5x8O","./src/Contents/Contents":"5XoDN","./src/Template/Template":"bKVa3","./src/SpeechSection/SpeechSection":"cdwqj","./src/FishEye/FishEye":"6kGc0","./src/BoxMenu/BoxMenu":"5i8sQ","./src/Spinner/Spinner":"bGUf5","./src/ReciteMe/ReciteMe":"8wQqb"}],"9dDzu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _juelModule = require("./_Modules/JuelModule");
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
var _juelLess = require("bundle-text:./_CommonStyles/juel.less");
var _juelLessDefault = parcelHelpers.interopDefault(_juelLess);
window.juel = (0, _juelModule.JuelModule);
window.$ = (0, _jqueryDefault.default);
window.jQuery = (0, _jqueryDefault.default);
(function() {
    let style = document.createElement("style");
    style.id = "juel-styles";
    style.textContent = (0, _juelLessDefault.default);
    document.head.append(style);
})();

},{"./_Modules/JuelModule":"6Vvq8","jquery":"f7Za7","bundle-text:./_CommonStyles/juel.less":"4pi7m","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6Vvq8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelModule", ()=>JuelModule);
var _audioModule = require("./AudioModule");
var _iconsModule = require("./IconsModule");
var JuelModule;
(function(JuelModule) {
    JuelModule.params = new Proxy(new URLSearchParams(window.location.search), {
        get: (searchParams, prop)=>searchParams.get(prop)
    });
    JuelModule.audio = (0, _audioModule.AudioModule);
    JuelModule.icon = (0, _iconsModule.IconsModule);
})(JuelModule || (JuelModule = {}));

},{"./AudioModule":"3OCAh","./IconsModule":"j1e1P","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3OCAh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AudioModule", ()=>AudioModule);
var AudioModule;
(function(AudioModule) {
    let audios;
    AudioModule.play = (src)=>{
        if (!audios || !(src in audios)) {
            let audio = new Audio(src);
            if (!audios) audios = {};
            audios[src] = audio;
            audio.onended = ()=>{
                delete audios[src];
            };
            audio.play();
            return true;
        } else return false;
    };
})(AudioModule || (AudioModule = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"isk47":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"j1e1P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IconsModule", ()=>IconsModule);
var IconsModule;
(function(IconsModule) {
    IconsModule.get = (name)=>{
        let style = getComputedStyle(document.body);
        let icon = style.getPropertyValue(`--icon-${name}`);
        if (icon) {
            var data = /(?<=url\().*(?=\))/.exec(icon)[0];
            let splitty = data.split(",");
            console.log(splitty);
            if (splitty.length > 1) {
                let decoded = decodeURIComponent(splitty[1]).replaceAll("\\", "");
                console.log(decoded);
                return decoded;
            }
        }
        return "";
    };
    IconsModule.use = (name)=>{
        return `<svg><use href="#icon-${name}" /></svg>`;
    };
})(IconsModule || (IconsModule = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"f7Za7":[function(require,module,exports) {
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */ (function(global, factory) {
    "use strict";
    if (typeof module.exports === "object") // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    };
    else factory(global);
// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function(window1, noGlobal) {
    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
    } : function(array) {
        return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction = function isFunction(obj) {
        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
        // Plus for old WebKit, typeof returns "function" for HTML collections
        // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };
    var document = window1.document;
    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };
    function DOMEval(code, node, doc) {
        doc = doc || document;
        var i, val, script = doc.createElement("script");
        script.text = code;
        if (node) for(i in preservedScriptAttributes){
            // Support: Firefox 64+, Edge 18+
            // Some browsers don't support the "nonce" property on scripts.
            // On the other hand, just using `getAttribute` is not enough as
            // the `nonce` attribute is reset to an empty string whenever it
            // becomes browsing-context connected.
            // See https://github.com/whatwg/html/issues/2369
            // See https://html.spec.whatwg.org/#nonce-attributes
            // The `node.getAttribute` check was added for the sake of
            // `jQuery.globalEval` so that it can fake a nonce-containing node
            // via an object.
            val = node[i] || node.getAttribute && node.getAttribute(i);
            if (val) script.setAttribute(i, val);
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
        if (obj == null) return obj + "";
        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module
    var version = "3.6.0", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return all the elements in a clean array
            if (num == null) return slice.call(this);
            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        even: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return (i + 1) % 2;
            }));
        },
        odd: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return i % 2;
            }));
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [
                this[j]
            ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) target = {};
        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for(; i < length; i++){
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) // Extend the base object
            for(name in options){
                copy = options[name];
                // Prevent Object.prototype pollution
                // Prevent never-ending loop
                if (name === "__proto__" || target === copy) continue;
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    src = target[name];
                    // Ensure proper type for the source value
                    if (copyIsArray && !Array.isArray(src)) clone = [];
                    else if (!copyIsArray && !jQuery.isPlainObject(src)) clone = {};
                    else clone = src;
                    copyIsArray = false;
                    // Never move original objects, clone them
                    target[name] = jQuery.extend(deep, clone, copy);
                // Don't bring in undefined values
                } else if (copy !== undefined) target[name] = copy;
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isPlainObject: function(obj) {
            var proto, Ctor;
            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") return false;
            proto = getProto(obj);
            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) return true;
            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
            var name;
            for(name in obj)return false;
            return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
            DOMEval(code, {
                nonce: options && options.nonce
            }, doc);
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for(; i < length; i++){
                    if (callback.call(obj[i], i, obj[i]) === false) break;
                }
            } else for(i in obj){
                if (callback.call(obj[i], i, obj[i]) === false) break;
            }
            return obj;
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) jQuery.merge(ret, typeof arr === "string" ? [
                    arr
                ] : arr);
                else push.call(ret, arr);
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for(; j < len; j++)first[i++] = second[j];
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for(; i < length; i++){
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) matches.push(elems[i]);
            }
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for(; i < length; i++){
                    value = callback(elems[i], i, arg);
                    if (value != null) ret.push(value);
                }
            // Go through every key on the object,
            } else for(i in elems){
                value = callback(elems[i], i, arg);
                if (value != null) ret.push(value);
            }
            // Flatten any nested arrays
            return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });
    if (typeof Symbol === "function") jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) return false;
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */ function(window1) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window1.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) hasDuplicate = true;
            return 0;
        }, // Instance methods
        hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, pushNative = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for(; i < len; i++){
                if (list[i] === elem) return i;
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
        identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
        // or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 0x10000;
            return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
            nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
            high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        }, // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if (ch === "\0") return "�";
                // Control characters and (dependent upon position) numbers get escaped as code points
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        }, // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        }, inDisabledFieldset = addCombinator(function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
        }, {
            dir: "parentNode",
            next: "legend"
        });
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            // eslint-disable-next-line no-unused-expressions
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? // Leverage slice if possible
                function(target, els) {
                    pushNative.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length, i = 0;
                    // Can't trust NodeList.length
                    while(target[j++] = els[i++]);
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;
            results = results || [];
            // Return early from calls with invalid selector or context
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) return results;
            // Try to shortcut find operations (as opposed to filters) in HTML documents
            if (!seed) {
                setDocument(context);
                context = context || document;
                if (documentIsHTML) {
                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        // ID selector
                        if (m = match[1]) {
                            // Document context
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else return results;
                            // Element context
                            } else // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        // Type selector
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        // Class selector
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    // Take advantage of querySelectorAll
                    if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
                    // Exclude object elements
                    (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                        newSelector = selector;
                        newContext = context;
                        // qSA considers elements outside a scoping root when evaluating child or
                        // descendant combinators, which is not what we want.
                        // In such cases, we work around the behavior by prefixing every selector in the
                        // list with an ID selector referencing the scope context.
                        // The technique has to be used as well when a leading combinator is used
                        // as such selectors are not recognized by querySelectorAll.
                        // Thanks to Andrew Dupont for this technique.
                        if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                            // Expand context for sibling selectors
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                            // We can use :scope instead of the ID hack if the browser
                            // supports it & if we're not changing the context.
                            if (newContext !== context || !support.scope) {
                                // Capture the context ID, setting it first if necessary
                                if (nid = context.getAttribute("id")) nid = nid.replace(rcssescape, fcssescape);
                                else context.setAttribute("id", nid = expando);
                            }
                            // Prefix every selector in the list
                            groups = tokenize(selector);
                            i = groups.length;
                            while(i--)groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                            newSelector = groups.join(",");
                        }
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                            nonnativeSelectorCache(selector, true);
                        } finally{
                            if (nid === expando) context.removeAttribute("id");
                        }
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */ function createCache() {
            var keys = [];
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) // Only keep the most recent entries
                delete cache[keys.shift()];
                return cache[key + " "] = value;
            }
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */ function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */ function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally{
                // Remove from its parent by default
                if (el.parentNode) el.parentNode.removeChild(el);
                // release memory in IE
                el = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */ function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = arr.length;
            while(i--)Expr.attrHandle[arr[i]] = handler;
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */ function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            // Use IE sourceIndex if available on both nodes
            if (diff) return diff;
            // Check if b follows a
            if (cur) while(cur = cur.nextSibling){
                if (cur === b) return -1;
            }
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */ function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */ function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */ function createDisabledPseudo(disabled) {
            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
            return function(elem) {
                // Only certain elements can match :enabled or :disabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                if ("form" in elem) {
                    // Check for inherited disabledness on relevant non-disabled elements:
                    // * listed form-associated elements in a disabled fieldset
                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                    // * option elements in a disabled optgroup
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                    // All such elements have a "form" property.
                    if (elem.parentNode && elem.disabled === false) {
                        // Option elements defer to a parent optgroup if present
                        if ("label" in elem) {
                            if ("label" in elem.parentNode) return elem.parentNode.disabled === disabled;
                            else return elem.disabled === disabled;
                        }
                        // Support: IE 6 - 11
                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                        return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                        /* jshint -W018 */ elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                // even exist on them, let alone have a boolean value.
                } else if ("label" in elem) return elem.disabled === disabled;
                // Remaining elements are neither :enabled nor :disabled
                return false;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */ function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    // Match elements found at the specified indexes
                    while(i--)if (seed[j = matchIndexes[i]]) seed[j] = !(matches[j] = seed[j]);
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */ function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        // Expose support vars for convenience
        support = Sizzle.support = {};
        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */ isXML = Sizzle.isXML = function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            // Support: IE <=8
            // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
            // https://bugs.jquery.com/ticket/4833
            return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
        };
        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */ setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            // Return early if doc is invalid or already selected
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (doc == document || doc.nodeType !== 9 || !doc.documentElement) return document;
            // Update global variables
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            // Support: IE 9 - 11+, Edge 12 - 18+
            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                // Support: IE 11, Edge
                if (subWindow.addEventListener) subWindow.addEventListener("unload", unloadHandler, false);
                else if (subWindow.attachEvent) subWindow.attachEvent("onunload", unloadHandler);
            }
            // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
            // Safari 4 - 5 only, Opera <=11.6 - 12.x only
            // IE/Edge & older browsers don't support the :scope pseudo-class.
            // Support: Safari 6.0 only
            // Safari 6.0 supports :scope but it's an alias of :root there.
            support.scope = assert(function(el) {
                docElem.appendChild(el).appendChild(document.createElement("div"));
                return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
            });
            /* Attributes
	---------------------------------------------------------------------- */ // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function(el) {
                el.className = "i";
                return !el.getAttribute("className");
            });
            /* getElement(s)By*
	---------------------------------------------------------------------- */ // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(el) {
                el.appendChild(document.createComment(""));
                return !el.getElementsByTagName("*").length;
            });
            // Support: IE<9
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programmatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            // ID filter and find
            if (support.getById) {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [
                            elem
                        ] : [];
                    }
                };
            } else {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
                // Support: IE 6 - 7 only
                // getElementById is not reliable as a find shortcut
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            // Verify the id attribute
                            node = elem.getAttributeNode("id");
                            if (node && node.value === id) return [
                                elem
                            ];
                            // Fall back on getElementsByName
                            elems = context.getElementsByName(id);
                            i = 0;
                            while(elem = elems[i++]){
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) return [
                                    elem
                                ];
                            }
                        }
                        return [];
                    }
                };
            }
            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") return context.getElementsByTagName(tag);
                else if (support.qsa) return context.querySelectorAll(tag);
            } : function(tag, context) {
                var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);
                // Filter out possible comments
                if (tag === "*") {
                    while(elem = results[i++])if (elem.nodeType === 1) tmp.push(elem);
                    return tmp;
                }
                return results;
            };
            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) return context.getElementsByClassName(className);
            };
            /* QSA/matchesSelector
	---------------------------------------------------------------------- */ // QSA and matchesSelector support
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];
            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See https://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(el) {
                    var input;
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // https://bugs.jquery.com/ticket/12359
                    docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (el.querySelectorAll("[msallowcapture^='']").length) rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!el.querySelectorAll("[selected]").length) rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!el.querySelectorAll("[id~=" + expando + "-]").length) rbuggyQSA.push("~=");
                    // Support: IE 11+, Edge 15 - 18+
                    // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                    // Adding a temporary attribute to the document before the selection works
                    // around the issue.
                    // Interestingly, IE 10 & older don't seem to have the issue.
                    input = document.createElement("input");
                    input.setAttribute("name", "");
                    el.appendChild(input);
                    if (!el.querySelectorAll("[name='']").length) rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!el.querySelectorAll(":checked").length) rbuggyQSA.push(":checked");
                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibling-combinator selector` fails
                    if (!el.querySelectorAll("a#" + expando + "+*").length) rbuggyQSA.push(".#.+[+~]");
                    // Support: Firefox <=3.6 - 5 only
                    // Old Firefox doesn't throw on a badly-escaped identifier.
                    el.querySelectorAll("\\\f");
                    rbuggyQSA.push("[\\r\\n\\f]");
                });
                assert(function(el) {
                    el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    el.appendChild(input).setAttribute("name", "D");
                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (el.querySelectorAll("[name=d]").length) rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (el.querySelectorAll(":enabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: IE9-11+
                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(":disabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: Opera 10 - 11 only
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    el.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) assert(function(el) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches.call(el, "*");
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
            });
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            /* Contains
	---------------------------------------------------------------------- */ hasCompare = rnative.test(docElem.compareDocumentPosition);
            // Element contains another
            // Purposefully self-exclusive
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) while(b = b.parentNode){
                    if (b === a) return true;
                }
                return false;
            };
            /* Sorting
	---------------------------------------------------------------------- */ // Document order sorting
            sortOrder = hasCompare ? function(a, b) {
                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) return compare;
                // Calculate position if both inputs belong to the same document
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                1;
                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    // Choose the first element that is related to our preferred document
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) return -1;
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) return 1;
                    // Maintain original order
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [
                    a
                ], bp = [
                    b
                ];
                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */ return a == document ? -1 : b == document ? 1 : /* eslint-enable eqeqeq */ aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                else if (aup === bup) return siblingCheck(a, b);
                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while(cur = cur.parentNode)ap.unshift(cur);
                cur = b;
                while(cur = cur.parentNode)bp.unshift(cur);
                // Walk down the tree looking for a discrepancy
                while(ap[i] === bp[i])i++;
                return i ? // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */ ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : /* eslint-enable eqeqeq */ 0;
            };
            return document;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                // IE 9's matchesSelector returns false on disconnected nodes
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) return ret;
            } catch (e) {
                nonnativeSelectorCache(expr, true);
            }
            return Sizzle(expr, document, null, [
                elem
            ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ((context.ownerDocument || context) != document) setDocument(context);
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ((elem.ownerDocument || elem) != document) setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */ Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while(elem = results[i++])if (elem === results[i]) j = duplicates.push(i);
                while(j--)results.splice(duplicates[j], 1);
            }
            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;
            return results;
        };
        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */ getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) // If no nodeType, this is expected to be an array
            while(node = elem[i++])// Do not traverse comment nodes
            ret += getText(node);
            else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") return elem.textContent;
                else // Traverse its children
                for(elem = elem.firstChild; elem; elem = elem.nextSibling)ret += getText(elem);
            } else if (nodeType === 3 || nodeType === 4) return elem.nodeValue;
            // Do not include comment or processing instruction nodes
            return ret;
        };
        Expr = Sizzle.selectors = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") match[3] = " " + match[3] + " ";
                    return match.slice(0, 4);
                },
                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/ match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) Sizzle.error(match[0]);
                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    // other types prohibit arguments
                    } else if (match[3]) Sizzle.error(match[0]);
                    return match;
                },
                "PSEUDO": function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) return null;
                    // Accept quoted arguments as-is
                    if (match[3]) match[2] = match[4] || match[5] || "";
                    else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                    (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },
            filter: {
                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                "CLASS": function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"), classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    }));
                },
                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) return operator === "!=";
                        if (!operator) return true;
                        result += "";
                        /* eslint-disable max-len */ return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    /* eslint-enable max-len */ };
                },
                "CHILD": function(type, what, _argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
                    function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, _context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while(dir){
                                    node = elem;
                                    while(node = node[dir]){
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) return false;
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [
                                forward ? parent.firstChild : parent.lastChild
                            ];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while(node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop())// When found, cache indexes on `parent` and break
                                if (node.nodeType === 1 && ++diff && node === elem) {
                                    uniqueCache[type] = [
                                        dirruns,
                                        nodeIndex,
                                        diff
                                    ];
                                    break;
                                }
                            } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            outerCache = node[expando] || (node[expando] = {});
                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                            uniqueCache[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) break;
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) return fn(argument);
                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            "",
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while(i--){
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, _context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while(i--)if (elem = unmatched[i]) seed[i] = !(matches[i] = elem);
                    }) : function(elem, _context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                "contains": markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || getText(elem)).indexOf(text) > -1;
                    };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) Sizzle.error("unsupported lang: " + lang);
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                        }
                        while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                // Miscellaneous
                "target": function(elem) {
                    var hash = window1.location && window1.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                "root": function(elem) {
                    return elem === docElem;
                },
                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),
                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) // eslint-disable-next-line no-unused-expressions
                    elem.parentNode.selectedIndex;
                    return elem.selected === true;
                },
                // Contents
                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for(elem = elem.firstChild; elem; elem = elem.nextSibling){
                        if (elem.nodeType < 6) return false;
                    }
                    return true;
                },
                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },
                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                "first": createPositionalPseudo(function() {
                    return [
                        0
                    ];
                }),
                "last": createPositionalPseudo(function(_matchIndexes, length) {
                    return [
                        length - 1
                    ];
                }),
                "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                    return [
                        argument < 0 ? argument + length : argument
                    ];
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument > length ? length : argument;
                    for(; --i >= 0;)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for(; ++i < length;)matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        // Add button/input type pseudos
        for(i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        })Expr.pseudos[i] = createInputPseudo(i);
        for(i in {
            submit: true,
            reset: true
        })Expr.pseudos[i] = createButtonPseudo(i);
        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while(soFar){
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) // Don't consume trailing commas as valid
                    soFar = soFar.slice(match[0].length) || soFar;
                    groups.push(tokens = []);
                }
                matched = false;
                // Combinators
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                // Filters
                for(type in Expr.filter)if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice(matched.length);
                }
                if (!matched) break;
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
            tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for(; i < len; i++)selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? // Check against closest ancestor/preceding element
            function(elem, context, xml) {
                while(elem = elem[dir]){
                    if (elem.nodeType === 1 || checkNonElements) return matcher(elem, context, xml);
                }
                return false;
            } : // Check against all ancestor/preceding elements
            function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                    dirruns,
                    doneName
                ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) return true;
                    }
                } else {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                        if (skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem;
                        else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) // Assign to newCache so results back-propagate to previous elements
                        return newCache[2] = oldCache[2];
                        else {
                            // Reuse newcache so results back-propagate to previous elements
                            uniqueCache[key] = newCache;
                            // A match means we're done; a fail means we have to keep checking
                            if (newCache[2] = matcher(elem, context, xml)) return true;
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while(i--){
                    if (!matchers[i](elem, context, xml)) return false;
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for(; i < len; i++)Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for(; i < len; i++){
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) map.push(i);
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) postFilter = setMatcher(postFilter);
            if (postFinder && !postFinder[expando]) postFinder = setMatcher(postFinder, postSelector);
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [
                    context
                ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : // ...otherwise use results directly
                results : matcherIn;
                // Find primary matches
                if (matcher) matcher(matcherIn, matcherOut, context, xml);
                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while(i--)if (elem = temp[i]) matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while(i--)if (elem = matcherOut[i]) // Restore matcherIn since elem is not yet a final match
                            temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while(i--)if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) seed[temp] = !(results[temp] = elem);
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) postFinder(null, results, matcherOut, xml);
                    else push.apply(results, matcherOut);
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [
                function(elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    // Avoid hanging onto element (issue #299)
                    checkContext = null;
                    return ret;
                }
            ];
            for(; i < len; i++)if (matcher = Expr.relative[tokens[i].type]) matchers = [
                addCombinator(elementMatcher(matchers), matcher)
            ];
            else {
                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                // Return special upon seeing a positional matcher
                if (matcher[expando]) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for(; j < len; j++){
                        if (Expr.relative[tokens[j].type]) break;
                    }
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i - 1).concat({
                        value: tokens[i - 2].type === " " ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                outermostContext = context == document || context || outermost;
                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for(; i !== len && (elem = elems[i]) != null; i++){
                    if (byElement && elem) {
                        j = 0;
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (!context && elem.ownerDocument != document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while(matcher = elementMatchers[j++])if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        if (outermost) dirruns = dirrunsUnique;
                    }
                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) matchedCount--;
                        // Lengthen the array for every element, matched or not
                        if (seed) unmatched.push(elem);
                    }
                }
                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;
                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while(matcher = setMatchers[j++])matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while(i--)if (!(unmatched[i] || setMatched[i])) setMatched[i] = pop.call(results);
                        }
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched);
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) Sizzle.uniqueSort(results);
                }
                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) match = tokenize(selector);
                i = match.length;
                while(i--){
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) setMatchers.push(cached);
                    else elementMatchers.push(cached);
                }
                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */ select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            // Try to minimize operations if there is only one selector in the list and no seed
            // (the latter of which guarantees us context)
            if (match.length === 1) {
                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) return results;
                    else if (compiled) context = context.parentNode;
                    selector = selector.slice(tokens.shift().value.length);
                }
                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while(i--){
                    token = tokens[i];
                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) break;
                    if (find = Expr.find[type]) // Search, expanding context for leading sibling combinators
                    {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        // One-time assignments
        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;
        // Initialize against the default document
        setDocument();
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(el) {
            // Should return 1, but returns 4 (following)
            return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        });
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
        })) addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        });
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
        })) addHandle("value", function(elem, _name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") return elem.defaultValue;
        });
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
        })) addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        });
        return Sizzle;
    }(window1);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while((elem = elem[dir]) && elem.nodeType !== 9)if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for(; n; n = n.nextSibling)if (n.nodeType === 1 && n !== elem) matched.push(n);
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        });
        // Single element
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        });
        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        });
        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) expr = ":not(" + expr + ")";
        if (elems.length === 1 && elem.nodeType === 1) return jQuery.find.matchesSelector(elem, expr) ? [
            elem
        ] : [];
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== "string") return this.pushStack(jQuery(selector).filter(function() {
                for(i = 0; i < len; i++){
                    if (jQuery.contains(self[i], this)) return true;
                }
            }));
            ret = this.pushStack([]);
            for(i = 0; i < len; i++)jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) return this;
        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;
        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [
                null,
                selector,
                null
            ];
            else match = rquickExpr.exec(selector);
            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {
                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for(match in context)// Properties of context are called as methods if possible
                        if (isFunction(this[match])) this[match](context[match]);
                        else this.attr(match, context[match]);
                    }
                    return this;
                // HANDLE: $(#id)
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem) {
                        // Inject the element directly into the jQuery object
                        this[0] = elem;
                        this.length = 1;
                    }
                    return this;
                }
            } else if (!context || context.jquery) return (context || root).find(selector);
            else return this.constructor(context).find(selector);
        // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
        // HANDLE: $(function)
        // Shortcut for document ready
        } else if (isFunction(selector)) return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
        return jQuery.makeArray(selector, this);
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    // Initialize central reference
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for(; i < l; i++){
                    if (jQuery.contains(this, targets[i])) return true;
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) for(; i < l; i++){
                for(cur = this[i]; cur && cur !== context; cur = cur.parentNode)// Always skip document fragments
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
            // No argument, return index in parent
            if (!elem) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            // Index in selector
            if (typeof elem === "string") return indexOf.call(jQuery(elem), this[0]);
            // Locate the position of the desired element
            return indexOf.call(this, // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while((cur = cur[dir]) && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) return elem.contentDocument;
            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName(elem, "template")) elem = elem.content || elem;
            return jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") selector = until;
            if (selector && typeof selector === "string") matched = jQuery.filter(selector, matched);
            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) jQuery.uniqueSort(matched);
                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) matched.reverse();
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */ jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, // Last fire value for non-forgettable lists
        memory, // Flag to know if list was already fired
        fired, // Flag to prevent firing
        locked, // Actual callback list
        list = [], // Queue of execution data for repeatable lists
        queue = [], // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1, // Fire callbacks
        fire = function() {
            // Enforce single-firing
            locked = locked || options.once;
            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            fired = firing = true;
            for(; queue.length; firingIndex = -1){
                memory = queue.shift();
                while(++firingIndex < list.length)// Run callback and check for early termination
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    // Jump to end and forget the data so .add doesn't re-fire
                    firingIndex = list.length;
                    memory = false;
                }
            }
            // Forget the data if we're done with it
            if (!options.memory) memory = false;
            firing = false;
            // Clean up if we're done firing for good
            if (locked) {
                // Keep an empty list if we have data for future add calls
                if (memory) list = [];
                else list = "";
            }
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) list.push(arg);
                            } else if (arg && arg.length && toType(arg) !== "string") // Inspect recursively
                            add(arg);
                        });
                    })(arguments);
                    if (memory && !firing) fire();
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while((index = jQuery.inArray(arg, list, index)) > -1){
                        list.splice(index, 1);
                        // Handle firing indexes
                        if (index <= firingIndex) firingIndex--;
                    }
                });
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
                if (list) list = [];
                return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
                locked = queue = [];
                if (!memory && !firing) list = memory = "";
                return this;
            },
            locked: function() {
                return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [
                        context,
                        args.slice ? args.slice() : args
                    ];
                    queue.push(args);
                    if (!firing) fire();
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction(method = value.promise)) method.call(value).done(resolve).fail(reject);
            else if (value && isFunction(method = value.then)) method.call(value, resolve, reject);
            else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply(undefined, [
                value
            ].slice(noValue));
        // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.
        } catch (value1) {
            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [
                value1
            ]);
        }
    }
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [
                    "notify",
                    "progress",
                    jQuery.Callbacks("memory"),
                    jQuery.Callbacks("memory"),
                    2
                ],
                [
                    "resolve",
                    "done",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    0,
                    "resolved"
                ],
                [
                    "reject",
                    "fail",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    1,
                    "rejected"
                ]
            ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                "catch": function(fn) {
                    return promise.then(null, fn);
                },
                // Keep pipe for back-compat
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(_i, tuple) {
                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && isFunction(returned.promise)) returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                else newDefer[tuple[0] + "With"](this, fn ? [
                                    returned
                                ] : arguments);
                            });
                        });
                        fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0;
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                // Support: Promises/A+ section 2.3.3.3.3
                                // https://promisesaplus.com/#point-59
                                // Ignore double-resolution attempts
                                if (depth < maxDepth) return;
                                returned = handler.apply(that, args);
                                // Support: Promises/A+ section 2.3.1
                                // https://promisesaplus.com/#point-48
                                if (returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                // https://promisesaplus.com/#point-54
                                // https://promisesaplus.com/#point-75
                                // Retrieve `then` only once
                                then = returned && // Support: Promises/A+ section 2.3.4
                                // https://promisesaplus.com/#point-64
                                // Only check objects and functions for thenability
                                (typeof returned === "object" || typeof returned === "function") && returned.then;
                                // Handle a returned thenable
                                if (isFunction(then)) {
                                    // Special processors (notify) just wait for resolution
                                    if (special) then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                    else {
                                        // ...and disregard older resolution values
                                        maxDepth++;
                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                    }
                                } else {
                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Identity) {
                                        that = undefined;
                                        args = [
                                            returned
                                        ];
                                    }
                                    // Process the value(s)
                                    // Default process is resolve
                                    (special || deferred.resolveWith)(that, args);
                                }
                            }, // Only normal processors (resolve) catch and reject exceptions
                            process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    if (jQuery.Deferred.exceptionHook) jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                    // Support: Promises/A+ section 2.3.3.3.4.1
                                    // https://promisesaplus.com/#point-61
                                    // Ignore post-resolution exceptions
                                    if (depth + 1 >= maxDepth) {
                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        if (handler !== Thrower) {
                                            that = undefined;
                                            args = [
                                                e
                                            ];
                                        }
                                        deferred.rejectWith(that, args);
                                    }
                                }
                            };
                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            if (depth) process();
                            else {
                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                if (jQuery.Deferred.getStackHook) process.stackTrace = jQuery.Deferred.getStackHook();
                                window1.setTimeout(process);
                            }
                        };
                    }
                    return jQuery.Deferred(function(newDefer) {
                        // progress_handlers.add( ... )
                        tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                        // rejected_handlers.add( ... )
                        tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;
                // Handle state
                if (stateString) list.add(function() {
                    // state = "resolved" (i.e., fulfilled)
                    // state = "rejected"
                    state = stateString;
                }, // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i][2].disable, // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i][3].disable, // progress_callbacks.lock
                tuples[0][2].lock, // progress_handlers.lock
                tuples[0][3].lock);
                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);
                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                    return this;
                };
                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            // Make the deferred a promise
            promise.promise(deferred);
            // Call given func if any
            if (func) func.call(deferred, deferred);
            // All done!
            return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
            var // count of uncompleted subordinates
            remaining = arguments.length, // count of unprocessed arguments
            i = remaining, // subordinate fulfillment data
            resolveContexts = Array(i), resolveValues = slice.call(arguments), // the primary Deferred
            primary = jQuery.Deferred(), // subordinate callback factory
            updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this;
                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (!--remaining) primary.resolveWith(resolveContexts, resolveValues);
                };
            };
            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);
                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) return primary.then();
            }
            // Multiple arguments are aggregated like Promise.all array elements
            while(i--)adoptValue(resolveValues[i], updateFunc(i), primary.reject);
            return primary.promise();
        }
    });
    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) window1.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    };
    jQuery.readyException = function(error) {
        window1.setTimeout(function() {
            throw error;
        });
    };
    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function(error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) return;
            // Remember that the DOM is ready
            jQuery.isReady = true;
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) return;
            // If there are functions bound, to execute
            readyList.resolveWith(document, [
                jQuery
            ]);
        }
    });
    jQuery.ready.then = readyList.then;
    // The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window1.removeEventListener("load", completed);
        jQuery.ready();
    }
    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
    window1.setTimeout(jQuery.ready);
    else {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);
        // A fallback to window.onload, that will always work
        window1.addEventListener("load", completed);
    }
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for(i in key)access(elems, fn, i, key[i], true, emptyGet, raw);
        // Sets one value
        } else if (value !== undefined) {
            chainable = true;
            if (!isFunction(value)) raw = true;
            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function(elem, _key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) for(; i < len; i++)fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
        if (chainable) return elems;
        // Gets
        if (bulk) return fn.call(elems);
        return len ? fn(elems[0], key) : emptyGet;
    };
    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    // Used by camelCase as callback to replace()
    function fcamelCase(_all, letter) {
        return letter.toUpperCase();
    }
    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function(owner) {
            // Check if the owner object already has a cache
            var value = owner[this.expando];
            // If not, create one
            if (!value) {
                value = {};
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {
                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) owner[this.expando] = value;
                    else Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") cache[camelCase(data)] = value;
            else // Copy the properties one-by-one to the cache object
            for(prop in data)cache[camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function(owner, key, value) {
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || key && typeof key === "string" && value === undefined) return this.get(owner, key);
            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);
            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) return;
            if (key !== undefined) {
                // Support array or space separated string of keys
                if (Array.isArray(key)) // If key is an array of keys...
                // We always set camelCase keys, so remove that.
                key = key.map(camelCase);
                else {
                    key = camelCase(key);
                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ? [
                        key
                    ] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while(i--)delete cache[key[i]];
            }
            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) owner[this.expando] = undefined;
                else delete owner[this.expando];
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === "true") return true;
        if (data === "false") return false;
        if (data === "null") return null;
        // Only convert to a number if it doesn't change the string
        if (data === +data + "") return +data;
        if (rbrace.test(data)) return JSON.parse(data);
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {}
                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else data = undefined;
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while(i--)// Support: IE 11 only
                        // The attrs elements can be null (#14894)
                        if (attrs[i]) {
                            name = attrs[i].name;
                            if (name.indexOf("data-") === 0) {
                                name = camelCase(name.slice(5));
                                dataAttr(elem, name, data[name]);
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            // Sets multiple values
            if (typeof key === "object") return this.each(function() {
                dataUser.set(this, key);
            });
            return access(this, function(value) {
                var data;
                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) return data;
                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) return data;
                    // We tried really hard, but the data doesn't exist.
                    return;
                }
                // Set the data...
                this.each(function() {
                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    else queue.push(data);
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") queue.unshift("inprogress");
                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) hooks.empty.fire();
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [
                        type + "queue",
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) return jQuery.queue(this[0], type);
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) defer.resolveWith(elements, [
                    elements
                ]);
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while(i--){
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [
        "Top",
        "Right",
        "Bottom",
        "Left"
    ];
    var documentElement = document.documentElement;
    var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
    }, composed = {
        composed: true
    };
    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if (documentElement.getRootNode) isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
    var isHiddenWithinTree = function(elem, el) {
        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        // Inline style trumps all
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;
            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];
            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;
            while(maxIterations--){
                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) maxIterations = 0;
                initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) return display;
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") display = "block";
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        // Determine new display value for elements that need to change
        for(; index < length; index++){
            elem = elements[index];
            if (!elem.style) continue;
            display = elem.style.display;
            if (show) {
                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) elem.style.display = "";
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) values[index] = getDefaultDisplay(elem);
            } else if (display !== "none") {
                values[index] = "none";
                // Remember what we're overwriting
                dataPriv.set(elem, "display", display);
            }
        }
        // Set the display of the elements in a second loop to avoid constant reflow
        for(index = 0; index < length; index++)if (values[index] != null) elements[index].style.display = values[index];
        return elements;
    }
    jQuery.fn.extend({
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") return state ? this.show() : this.hide();
            return this.each(function() {
                if (isHiddenWithinTree(this)) jQuery(this).show();
                else jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        // Support: IE <=9 only
        // IE <=9 replaces <option> tags with their contents when inserted outside of
        // the select element.
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
    })();
    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [
            1,
            "<table>",
            "</table>"
        ],
        col: [
            2,
            "<table><colgroup>",
            "</colgroup></table>"
        ],
        tr: [
            2,
            "<table><tbody>",
            "</tbody></table>"
        ],
        td: [
            3,
            "<table><tbody><tr>",
            "</tr></tbody></table>"
        ],
        _default: [
            0,
            "",
            ""
        ]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    // Support: IE <=9 only
    if (!support.option) wrapMap.optgroup = wrapMap.option = [
        1,
        "<select multiple='multiple'>",
        "</select>"
    ];
    function getAll(context, tag) {
        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") ret = context.getElementsByTagName(tag || "*");
        else if (typeof context.querySelectorAll !== "undefined") ret = context.querySelectorAll(tag || "*");
        else ret = [];
        if (tag === undefined || tag && nodeName(context, tag)) return jQuery.merge([
            context
        ], ret);
        return ret;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for(; i < l; i++)dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for(; i < l; i++){
            elem = elems[i];
            if (elem || elem === 0) {
                // Add nodes directly
                if (toType(elem) === "object") // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(nodes, elem.nodeType ? [
                    elem
                ] : elem);
                else if (!rhtml.test(elem)) nodes.push(context.createTextNode(elem));
                else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || [
                        "",
                        ""
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while(j--)tmp = tmp.lastChild;
                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);
                    // Remember the top-level container
                    tmp = fragment.firstChild;
                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }
        // Remove wrapper from fragment
        fragment.textContent = "";
        i = 0;
        while(elem = nodes[i++]){
            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) ignored.push(elem);
                continue;
            }
            attached = isAttached(elem);
            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");
            // Preserve script evaluation history
            if (attached) setGlobalEval(tmp);
            // Capture executables
            if (scripts) {
                j = 0;
                while(elem = tmp[j++])if (rscriptType.test(elem.type || "")) scripts.push(elem);
            }
        }
        return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).
    function expectSync(elem, type) {
        return elem === safeActiveElement() === (type === "focus");
    }
    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        // Types can be a map of types/handlers
        if (typeof types === "object") {
            // ( types-Object, selector, data )
            if (typeof selector !== "string") {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for(type in types)on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (data == null && fn == null) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) fn = returnFalse;
        else if (!fn) return elem;
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */ jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            // Only attach events to objects that accept data
            if (!acceptData(elem)) return;
            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) jQuery.find.matchesSelector(documentElement, selector);
            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) handler.guid = jQuery.guid++;
            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) events = elemData.events = Object.create(null);
            if (!(eventHandle = elemData.handle)) eventHandle = elemData.handle = function(e) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // There *must* be a type, no attaching namespace-only handlers
                if (!type) continue;
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};
                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;
                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) elem.addEventListener(type, eventHandle);
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) handleObj.handler.guid = handler.guid;
                }
                // Add to the element's handler list, delegates in front
                if (selector) handlers.splice(handlers.delegateCount++, 0, handleObj);
                else handlers.push(handleObj);
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) return;
            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for(type in events)jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                // Remove matching events
                origCount = j = handlers.length;
                while(j--){
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) handlers.delegateCount--;
                        if (special.remove) special.remove.call(elem, handleObj);
                    }
                }
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) jQuery.removeEvent(elem, type, elemData.handle);
                    delete events[type];
                }
            }
            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) dataPriv.remove(elem, "handle events");
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            for(i = 1; i < arguments.length; i++)args[i] = arguments[i];
            event.delegateTarget = this;
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) return;
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){
                event.currentTarget = matched.elem;
                j = 0;
                while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped())// If the event is namespaced, then each handler is only invoked if it is
                // specially universal or its namespaces are a superset of the event's.
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                    if (ret !== undefined) {
                        if ((event.result = ret) === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) special.postDispatch.call(this, event);
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
                for(; cur !== this; cur = cur.parentNode || this)// Don't check non-elements (#13208)
                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                    matchedHandlers = [];
                    matchedSelectors = {};
                    for(i = 0; i < delegateCount; i++){
                        handleObj = handlers[i];
                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";
                        if (matchedSelectors[sel] === undefined) matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [
                            cur
                        ]).length;
                        if (matchedSelectors[sel]) matchedHandlers.push(handleObj);
                    }
                    if (matchedHandlers.length) handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                    });
                }
            }
            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            });
            return handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction(hook) ? function() {
                    if (this.originalEvent) return hook(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[name];
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function(data) {
                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;
                    // Claim the first handler
                    if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) // dataPriv.set( el, "click", ... )
                    leverageNative(el, "click", returnTrue);
                    // Return false to allow normal processing in the caller
                    return false;
                },
                trigger: function(data) {
                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;
                    // Force setup before triggering a click
                    if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) leverageNative(el, "click");
                    // Return non-false to allow normal event-path propagation
                    return true;
                },
                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function(event) {
                    var target = event.target;
                    return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) event.originalEvent.returnValue = event.result;
                }
            }
        }
    };
    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative(el, type, expectSync) {
        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if (!expectSync) {
            if (dataPriv.get(el, type) === undefined) jQuery.event.add(el, type, returnTrue);
            return;
        }
        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
            namespace: false,
            handler: function(event) {
                var notAsync, result, saved = dataPriv.get(this, type);
                if (event.isTrigger & 1 && this[type]) {
                    // Interrupt processing of the outer synthetic .trigger()ed event
                    // Saved data should be false in such cases, but might be a leftover capture object
                    // from an async native handler (gh-4350)
                    if (!saved.length) {
                        // Store arguments for use when handling the inner native event
                        // There will always be at least one argument (an event object), so this array
                        // will not be confused with a leftover capture object.
                        saved = slice.call(arguments);
                        dataPriv.set(this, type, saved);
                        // Trigger the native event and capture its result
                        // Support: IE <=9 - 11+
                        // focus() and blur() are asynchronous
                        notAsync = expectSync(this, type);
                        this[type]();
                        result = dataPriv.get(this, type);
                        if (saved !== result || notAsync) dataPriv.set(this, type, false);
                        else result = {};
                        if (saved !== result) {
                            // Cancel the outer synthetic event
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            // Support: Chrome 86+
                            // In Chrome, if an element having a focusout handler is blurred by
                            // clicking outside of it, it invokes the handler synchronously. If
                            // that handler calls `.remove()` on the element, the data is cleared,
                            // leaving `result` undefined. We need to guard against this.
                            return result && result.value;
                        }
                    // If this is an inner synthetic event for an event with a bubbling surrogate
                    // (focus or blur), assume that the surrogate already propagated from triggering the
                    // native event and prevent that from happening again here.
                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                    // less bad than duplication.
                    } else if ((jQuery.event.special[type] || {}).delegateType) event.stopPropagation();
                // If this is a native event triggered above, everything is now in order
                // Fire an inner synthetic event with the original arguments
                } else if (saved.length) {
                    // ...and capture the result
                    dataPriv.set(this, type, {
                        value: jQuery.event.trigger(// Support: IE <=9 - 11+
                        // Extend with the prototype to reset the above stopImmediatePropagation()
                        jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
                    });
                    // Abort handling of the native event
                    event.stopImmediatePropagation();
                }
            }
        });
    }
    jQuery.removeEvent = function(elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) elem.removeEventListener(type, handle);
    };
    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        // Event type
        } else this.type = src;
        // Put explicitly provided properties onto the event object
        if (props) jQuery.extend(this, props);
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();
        // Mark it as fixed
        this[jQuery.expando] = true;
    };
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopImmediatePropagation();
            this.stopPropagation();
        }
    };
    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
    }, jQuery.event.addProp);
    jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(type, delegateType) {
        jQuery.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
                // Claim the first handler
                // dataPriv.set( this, "focus", ... )
                // dataPriv.set( this, "blur", ... )
                leverageNative(this, type, expectSync);
                // Return false to allow normal processing in the caller
                return false;
            },
            trigger: function() {
                // Force setup before trigger
                leverageNative(this, type);
                // Return non-false to allow normal event-path propagation
                return true;
            },
            // Suppress native focus or blur as it's already being fired
            // in leverageNative.
            _default: function() {
                return true;
            },
            delegateType: delegateType
        };
    });
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for(type in types)this.off(type, selector, types[type]);
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) fn = returnFalse;
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) return jQuery(elem).children("tbody")[0] || elem;
        return elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") elem.type = elem.type.slice(5);
        else elem.removeAttribute("type");
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) return;
        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
                dataPriv.remove(dest, "handle events");
                for(type in events)for(i = 0, l = events[type].length; i < l; i++)jQuery.event.add(dest, type, events[type][i]);
            }
        }
        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) dest.checked = src.checked;
        else if (nodeName === "input" || nodeName === "textarea") dest.defaultValue = src.defaultValue;
    }
    function domManip(collection, args, callback, ignored) {
        // Flatten any nested arrays
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            if (valueIsFunction) args[0] = value.call(this, index, self.html());
            domManip(self, args, callback, ignored);
        });
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) fragment = first;
            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for(; i < l; i++){
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) // Support: Android <=4.0 only, PhantomJS 1 only
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(scripts, getAll(node, "script"));
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);
                    // Evaluate executable scripts on first document insertion
                    for(i = 0; i < hasScripts; i++){
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src && (node.type || "").toLowerCase() !== "module") // Optional AJAX dependency, but won't run scripts if not present
                            {
                                if (jQuery._evalUrl && !node.noModule) jQuery._evalUrl(node.src, {
                                    nonce: node.nonce || node.getAttribute("nonce")
                                }, doc);
                            } else DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for(; (node = nodes[i]) != null; i++){
            if (!keepData && node.nodeType === 1) jQuery.cleanData(getAll(node));
            if (node.parentNode) {
                if (keepData && isAttached(node)) setGlobalEval(getAll(node, "script"));
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for(i = 0, l = srcElements.length; i < l; i++)fixInput(srcElements[i], destElements[i]);
            }
            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for(i = 0, l = srcElements.length; i < l; i++)cloneCopyEvent(srcElements[i], destElements[i]);
                } else cloneCopyEvent(elem, clone);
            }
            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            // Return the cloned set
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for(; (elem = elems[i]) !== undefined; i++)if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) {
                        for(type in data.events)if (special[type]) jQuery.event.remove(elem, type);
                        else jQuery.removeEvent(elem, type, data.handle);
                    }
                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataPriv.expando] = undefined;
                }
                if (elem[dataUser.expando]) // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[dataUser.expando] = undefined;
            }
        }
    });
    jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) this.textContent = value;
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            var elem, i = 0;
            for(; (elem = this[i]) != null; i++)if (elem.nodeType === 1) {
                // Prevent memory leaks
                jQuery.cleanData(getAll(elem, false));
                // Remove any remaining nodes
                elem.textContent = "";
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) return elem.innerHTML;
                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                    "",
                    ""
                ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for(; i < l; i++){
                            elem = this[i] || {};
                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }
                if (elem) this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) parent.replaceChild(elem, this);
                }
            // Force callback invocation
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for(; i <= last; i++){
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) view = window1;
        return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
        var ret, name, old = {};
        // Remember the old values, and insert the new ones
        for(name in options){
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        // Revert the old values
        for(name in options)elem.style[name] = old[name];
        return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    (function() {
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            // This is a singleton, we need to execute it only once
            if (!div) return;
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window1.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            // Support: Chrome <=64
            // Don't get tricked when zoom affects offsetWidth (gh-4029)
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }
        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        // Finish early in limited (non-browser) environments
        if (!div.style) return;
        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
            boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
                computeStyleTests();
                return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
                var table, tr, trChild, trStyle;
                if (reliableTrDimensionsVal == null) {
                    table = document.createElement("table");
                    tr = document.createElement("tr");
                    trChild = document.createElement("div");
                    table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                    tr.style.cssText = "border:1px solid";
                    // Support: Chrome 86+
                    // Height set through cssText does not get applied.
                    // Computed height then comes back as 0.
                    tr.style.height = "1px";
                    trChild.style.height = "9px";
                    // Support: Android 8 Chrome 86+
                    // In our bodyBackground.html iframe,
                    // display for all div elements is set to "inline",
                    // which causes a problem only in Android 8 Chrome 86.
                    // Ensuring the div is display: block
                    // gets around this issue.
                    trChild.style.display = "block";
                    documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                    trStyle = window1.getComputedStyle(tr);
                    reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                    documentElement.removeChild(table);
                }
                return reliableTrDimensionsVal;
            }
        });
    })();
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;
        computed = computed || getStyles(elem);
        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === "" && !isAttached(elem)) ret = jQuery.style(elem, name);
            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }
                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var cssPrefixes = [
        "Webkit",
        "Moz",
        "ms"
    ], emptyStyle = document.createElement("div").style, vendorProps = {};
    // Return a vendor-prefixed property or undefined
    function vendorPropName(name) {
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while(i--){
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) return name;
        }
    }
    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) return final;
        if (name in emptyStyle) return name;
        return vendorProps[name] = vendorPropName(name) || name;
    }
    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) return 0;
        for(; i < 4; i += 2){
            // Both box models exclude margin
            if (box === "margin") delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {
                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // For "border" or "margin", add border
                if (box !== "padding") delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                else extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            // If we get here with a border-box (content + padding + border), we're seeking "content" or
            // "padding" or "margin"
            } else {
                // For "content", subtract padding
                if (box === "content") delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // For "content" or "padding", subtract border
                if (box !== "margin") delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
        }
        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
        // Assuming integer scroll gutter, subtract the rest and round down
        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
        return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
        // Start with computed style
        var styles = getStyles(elem), // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
        // Fake content-box until we know it's needed to know the true value.
        boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) return val;
            val = "auto";
        }
        // Support: IE 9 - 11 only
        // Use offsetWidth/offsetHeight for when box sizing is unreliable.
        // In those cases, the computed value can be trusted to be border-box.
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            // Where available, offsetWidth/offsetHeight approximate border box dimensions.
            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
            // retrieved value as a content box dimension.
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) val = elem[offsetProp];
        }
        // Normalize "" and auto
        val = parseFloat(val) || 0;
        // Adjust for the element's box model
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val) + "px";
    }
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) return;
            // Make sure that we're working with the right name
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;
                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    // Fixes bug #9237
                    type = "number";
                }
                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) return;
                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === "number" && !isCustomProp) value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) style[name] = "inherit";
                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) style.setProperty(name, value);
                    else style[name] = value;
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) return ret;
                // Otherwise just get the value from the style object
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) val = hooks.get(elem, true, extra);
            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) val = curCSS(elem, name, styles);
            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) val = cssNormalTransform[name];
            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        "height",
        "width"
    ], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
                if (computed) // Certain elements can have dimension info if we invisibly show them
                // but it must have a current display style that would benefit
                return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
            },
            set: function(elem, value, extra) {
                var matches, styles = getStyles(elem), // Only read styles.position if the test has a chance to fail
                // to avoid forcing a reflow.
                scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px";
    });
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [
                    value
                ];
                for(; i < 4; i++)expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        };
        if (prefix !== "margin") jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for(; i < len; i++)map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            else this.pos = eased = percent;
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) this.options.step.call(this.elem, this.now, this);
            if (hooks && hooks.set) hooks.set(this);
            else Tween.propHooks._default.set(this);
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) return tween.elem[tween.prop];
                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) jQuery.fx.step[tween.prop](tween);
                else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                else tween.elem[tween.prop] = tween.now;
            }
        }
    };
    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) tween.elem[tween.prop] = tween.now;
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    // Back compat <1.8 extension point
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window1.requestAnimationFrame) window1.requestAnimationFrame(schedule);
            else window1.setTimeout(schedule, jQuery.fx.interval);
            jQuery.fx.tick();
        }
    }
    // Animations created synchronously will run synchronously
    function createFxNow() {
        window1.setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = Date.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for(; i < 4; i += 2 - includeWidth){
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) attrs.opacity = attrs.width = type;
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for(; index < length; index++){
            if (tween = collection[index].call(animation, prop, value)) // We're done with this property
            return tween;
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) oldfire();
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                // Ensure the complete handler is called before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) hooks.empty.fire();
                });
            });
        }
        // Detect show/hide animations
        for(prop in props){
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) hidden = true;
                    else continue;
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) return;
        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {
            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) restoreDisplay = dataPriv.get(elem, "display");
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) display = restoreDisplay;
                else {
                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([
                        elem
                    ], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([
                        elem
                    ]);
                }
            }
            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {
                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function() {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        // Implement show/hide animations
        propTween = false;
        for(prop in orig){
            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) hidden = dataShow.hidden;
                } else dataShow = dataPriv.access(elem, "fxshow", {
                    display: restoreDisplay
                });
                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) dataShow.hidden = !hidden;
                // Show elements before animating them
                if (hidden) showHide([
                    elem
                ], true);
                /* eslint-disable no-loop-func */ anim.done(function() {
                    /* eslint-enable no-loop-func */ // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) showHide([
                        elem
                    ]);
                    dataPriv.remove(elem, "fxshow");
                    for(prop in orig)jQuery.style(elem, prop, orig[prop]);
                });
            }
            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for(index in props){
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for(index in value)if (!(index in props)) {
                    props[index] = value[index];
                    specialEasing[index] = easing;
                }
            } else specialEasing[name] = easing;
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            // Don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) return false;
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for(; index < length; index++)animation.tweens[index].run(percent);
            deferred.notifyWith(elem, [
                animation,
                percent,
                remaining
            ]);
            // If there's more to do, yield
            if (percent < 1 && length) return remaining;
            // If this was an empty animation, synthesize a final progress notification
            if (!length) deferred.notifyWith(elem, [
                animation,
                1,
                0
            ]);
            // Resolve the animation and report its conclusion
            deferred.resolveWith(elem, [
                animation
            ]);
            return false;
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                stopped = true;
                for(; index < length; index++)animation.tweens[index].run(1);
                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                    deferred.resolveWith(elem, [
                        animation,
                        gotoEnd
                    ]);
                } else deferred.rejectWith(elem, [
                    animation,
                    gotoEnd
                ]);
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for(; index < length; index++){
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) animation.opts.start.call(elem, animation);
        // Attach callbacks from options
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [
                function(prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }
            ]
        },
        tweener: function(props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = [
                    "*"
                ];
            } else props = props.match(rnothtmlwhite);
            var prop, index = 0, length = props.length;
            for(; index < length; index++){
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [
            defaultPrefilter
        ],
        prefilter: function(callback, prepend) {
            if (prepend) Animation.prefilters.unshift(callback);
            else Animation.prefilters.push(callback);
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };
        // Go to the end state if fx are off
        if (jQuery.fx.off) opt.duration = 0;
        else if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) opt.duration = jQuery.fx.speeds[opt.duration];
            else opt.duration = jQuery.fx.speeds._default;
        }
        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) opt.queue = "fx";
        // Queueing
        opt.old = opt.complete;
        opt.complete = function() {
            if (isFunction(opt.old)) opt.old.call(this);
            if (opt.queue) jQuery.dequeue(this, opt.queue);
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()// Animate to the value specified
            .end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                // Empty animations, or finishing resolves immediately
                if (empty || dataPriv.get(this, "finish")) anim.stop(true);
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue) this.queue(type || "fx", []);
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) stopQueue(data[index]);
                } else {
                    for(index in data)if (data[index] && data[index].stop && rrun.test(index)) stopQueue(data[index]);
                }
                for(index = timers.length; index--;)if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    timers[index].anim.stop(gotoEnd);
                    dequeue = false;
                    timers.splice(index, 1);
                }
                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            if (type !== false) type = type || "fx";
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // Enable finishing flag on private data
                data.finish = true;
                // Empty the queue first
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) hooks.stop.call(this, true);
                // Look for any active animations, and finish them
                for(index = timers.length; index--;)if (timers[index].elem === this && timers[index].queue === type) {
                    timers[index].anim.stop(true);
                    timers.splice(index, 1);
                }
                // Look for any animations in the old queue and finish them
                for(index = 0; index < length; index++)if (queue[index] && queue[index].finish) queue[index].finish.call(this);
                // Turn off finishing flag
                delete data.finish;
            });
        }
    });
    jQuery.each([
        "toggle",
        "show",
        "hide"
    ], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for(; i < timers.length; i++){
            timer = timers[i];
            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) timers.splice(i--, 1);
        }
        if (!timers.length) jQuery.fx.stop();
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (inProgress) return;
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function() {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };
    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window1.setTimeout(next, time);
            hooks.stop = function() {
                window1.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";
        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;
        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") return jQuery.prop(elem, name, value);
            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            ret = jQuery.find.attr(elem, name);
            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) elem.value = val;
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, // Attribute names can contain non-HTML whitespace characters
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
            attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) while(name = attrNames[i++])elem.removeAttribute(name);
        }
    });
    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) // Remove boolean attributes when set to false
            jQuery.removeAttr(elem, name);
            else elem.setAttribute(name, name);
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    if (tabindex) return parseInt(tabindex, 10);
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) return 0;
                    return -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });
    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support.optSelected) jQuery.propHooks.selected = {
        get: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent && parent.parentNode) parent.parentNode.selectedIndex;
            return null;
        },
        set: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) parent.parentNode.selectedIndex;
            }
        }
    };
    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
        if (Array.isArray(value)) return value;
        if (typeof value === "string") return value.match(rnothtmlwhite) || [];
        return [];
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            classes = classesToArray(value);
            if (classes.length) while(elem = this[i++]){
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                    j = 0;
                    while(clazz = classes[j++])if (cur.indexOf(" " + clazz + " ") < 0) cur += clazz + " ";
                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) elem.setAttribute("class", finalValue);
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            classes = classesToArray(value);
            if (classes.length) while(elem = this[i++]){
                curValue = getClass(elem);
                // This expression is here for better compressibility (see addClass)
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                    j = 0;
                    while(clazz = classes[j++])// Remove *all* instances
                    while(cur.indexOf(" " + clazz + " ") > -1)cur = cur.replace(" " + clazz + " ", " ");
                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) elem.setAttribute("class", finalValue);
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (typeof stateVal === "boolean" && isValidValue) return stateVal ? this.addClass(value) : this.removeClass(value);
            if (isFunction(value)) return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
            return this.each(function() {
                var className, i, self, classNames;
                if (isValidValue) {
                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);
                    while(className = classNames[i++])// Check each className given, space separated list
                    if (self.hasClass(className)) self.removeClass(className);
                    else self.addClass(className);
                // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) // Store className if set
                    dataPriv.set(this, "__className__", className);
                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while(elem = this[i++]){
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return true;
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) return ret;
                    ret = elem.value;
                    // Handle most common string cases
                    if (typeof ret === "string") return ret.replace(rreturn, "");
                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }
                return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) return;
                if (valueIsFunction) val = value.call(this, i, jQuery(this).val());
                else val = value;
                // Treat null/undefined as ""; convert numbers to string
                if (val == null) val = "";
                else if (typeof val === "number") val += "";
                else if (Array.isArray(val)) val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + "";
                });
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) this.value = val;
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : // Support: IE <=10 - 11 only
                    // option.text throws exceptions (#14686, #14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) i = max;
                    else i = one ? index : 0;
                    // Loop through all the selected options
                    for(; i < max; i++){
                        option = options[i];
                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                        !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                            // Get the specific value for the option
                            value = jQuery(option).val();
                            // We don't need an array for one selects
                            if (one) return value;
                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while(i--){
                        option = options[i];
                        /* eslint-disable no-cond-assign */ if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) optionSet = true;
                    /* eslint-enable no-cond-assign */ }
                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) elem.selectedIndex = -1;
                    return values;
                }
            }
        }
    });
    // Radios and checkboxes getter/setter
    jQuery.each([
        "radio",
        "checkbox"
    ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
        };
        if (!support.checkOn) jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    });
    // Return jQuery for attributes-only inclusion
    support.focusin = "onfocusin" in window1;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
        e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [
                elem || document
            ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document;
            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) return;
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) return;
            if (type.indexOf(".") > -1) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) event.target = elem;
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [
                event
            ] : jQuery.makeArray(data, [
                event
            ]);
            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) return;
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) cur = cur.parentNode;
                for(; cur; cur = cur.parentNode){
                    eventPath.push(cur);
                    tmp = cur;
                }
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) eventPath.push(tmp.defaultView || tmp.parentWindow || window1);
            }
            // Fire handlers on the event path
            i = 0;
            while((cur = eventPath[i++]) && !event.isPropagationStopped()){
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                // jQuery handler
                handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");
                if (handle) handle.apply(cur, data);
                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) event.preventDefault();
                }
            }
            event.type = type;
            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) // Call a native DOM method on the target with the same name as the event.
                // Don't do default actions on window, that's where global variables be (#6170)
                {
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];
                        if (tmp) elem[ontype] = null;
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        if (event.isPropagationStopped()) lastElement.addEventListener(type, stopPropagationCallback);
                        elem[type]();
                        if (event.isPropagationStopped()) lastElement.removeEventListener(type, stopPropagationCallback);
                        jQuery.event.triggered = undefined;
                        if (tmp) elem[ontype] = tmp;
                    }
                }
            }
            return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, true);
        }
    });
    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support.focusin) jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                // Handle: regular nodes (via `this.ownerDocument`), window
                // (via `this.document`) & document (via `this`).
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) doc.addEventListener(orig, handler, true);
                dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                    doc.removeEventListener(orig, handler, true);
                    dataPriv.remove(doc, fix);
                } else dataPriv.access(doc, fix, attaches);
            }
        };
    });
    var location = window1.location;
    var nonce = {
        guid: Date.now()
    };
    var rquery = /\?/;
    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") return null;
        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = new window1.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {}
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
        }).join("\n") : data));
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) // Serialize array item.
        jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) // Treat each array item as a scalar.
            add(prefix, v);
            else // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        });
        else if (!traditional && toType(obj) === "object") // Serialize object item.
        for(name in obj)buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        else // Serialize scalar item.
        add(prefix, obj);
    }
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            // If value is a function, invoke it and use its return value
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a == null) return "";
        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) // Serialize the form elements
        jQuery.each(a, function() {
            add(this.name, this.value);
        });
        else // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for(prefix in a)buildParams(prefix, a[prefix], traditional, add);
        // Return the resulting serialization
        return s.join("&");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
                var val = jQuery(this).val();
                if (val == null) return null;
                if (Array.isArray(val)) return jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                });
                return {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */ prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */ transports = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"), // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
    originAnchor.href = location.href;
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while(dataType = dataTypes[i++])// Prepend if requested
                if (dataType[0] === "+") {
                    dataType = dataType.slice(1) || "*";
                    (structure[dataType] = structure[dataType] || []).unshift(func);
                // Otherwise append
                } else (structure[dataType] = structure[dataType] || []).push(func);
            }
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) return !(selected = dataTypeOrTransport);
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for(key in src)if (src[key] !== undefined) (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        if (deep) jQuery.extend(true, target, deep);
        return target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */ function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        // Remove auto dataType and get content-type in the process
        while(dataTypes[0] === "*"){
            dataTypes.shift();
            if (ct === undefined) ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
        // Check if we're dealing with a known content-type
        if (ct) {
            for(type in contents)if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
            }
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
        else {
            // Try convertible dataTypes
            for(type in responses){
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) firstDataType = type;
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) dataTypes.unshift(finalDataType);
            return responses[finalDataType];
        }
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */ function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) for(conv in s.converters)converters[conv.toLowerCase()] = s.converters[conv];
        current = dataTypes.shift();
        // Convert to each sequential dataType
        while(current){
            if (s.responseFields[current]) jqXHR[s.responseFields[current]] = response;
            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) response = s.dataFilter(response, s.dataType);
            prev = current;
            current = dataTypes.shift();
            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === "*") current = prev;
                else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];
                    // If none found, seek a pair
                    if (!conv) for(conv2 in converters){
                        // If conv2 outputs current
                        tmp = conv2.split(" ");
                        if (tmp[1] === current) {
                            // If prev can be converted to accepted input
                            conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                            if (conv) {
                                // Condense equivalence converters
                                if (conv === true) conv = converters[conv2];
                                else if (converters[conv2] !== true) {
                                    current = tmp[0];
                                    dataTypes.unshift(tmp[1]);
                                }
                                break;
                            }
                        }
                    }
                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) response = conv(response);
                        else try {
                            response = conv(response);
                        } catch (e) {
                            return {
                                state: "parsererror",
                                error: conv ? e : "No conversion from " + prev + " to " + current
                            };
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/ accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": JSON.parse,
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            return settings ? // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            // Force options to be an object
            options = options || {};
            var transport, // URL without anti-cache param
            cacheURL, // Response headers
            responseHeadersString, responseHeaders, // timeout handle
            timeoutTimer, // Url cleanup var
            urlAnchor, // Request state (becomes false upon send and true upon completion)
            completed, // To know if global events are to be dispatched
            fireGlobals, // Loop variable
            i, // uncached part of the url
            uncached, // Create the final options object
            s = jQuery.ajaxSetup({}, options), // Callbacks context
            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), // Status-dependent callbacks
            statusCode = s.statusCode || {}, // Headers (they are sent all at once)
            requestHeaders = {}, requestHeadersNames = {}, // Default abort message
            strAbort = "canceled", // Fake xhr
            jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while(match = rheaders.exec(responseHeadersString))responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                        }
                        match = responseHeaders[key.toLowerCase() + " "];
                    }
                    return match == null ? null : match.join(", ");
                },
                // Raw string
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                    if (completed == null) {
                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (completed == null) s.mimeType = type;
                    return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (completed) // Execute the appropriate callbacks
                        jqXHR.always(map[jqXHR.status]);
                        else // Lazy-add the new callbacks in a way that preserves old ones
                        for(code in map)statusCode[code] = [
                            statusCode[code],
                            map[code]
                        ];
                    }
                    return this;
                },
                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) transport.abort(finalText);
                    done(0, finalText);
                    return this;
                }
            };
            // Attach deferreds
            deferred.promise(jqXHR);
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;
            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [
                ""
            ];
            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");
                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;
                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }
            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") s.data = jQuery.param(s.data, s.traditional);
            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            // If request was aborted inside a prefilter, stop there
            if (completed) return jqXHR;
            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;
            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) jQuery.event.trigger("ajaxStart");
            // Uppercase the type
            s.type = s.type.toUpperCase();
            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");
            // More options handling for requests with no content
            if (!s.hasContent) {
                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);
                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
                }
                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;
            // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) s.data = s.data.replace(r20, "+");
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                if (jQuery.etag[cacheURL]) jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) jqXHR.setRequestHeader("Content-Type", s.contentType);
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            // Check for headers option
            for(i in s.headers)jqXHR.setRequestHeader(i, s.headers[i]);
            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) // Abort if not done already and return
            return jqXHR.abort();
            // Aborting is no longer a cancellation
            strAbort = "abort";
            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            // If no transport, we auto-abort
            if (!transport) done(-1, "No Transport");
            else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) globalEventContext.trigger("ajaxSend", [
                    jqXHR,
                    s
                ]);
                // If request was aborted inside ajaxSend, stop there
                if (completed) return jqXHR;
                // Timeout
                if (s.async && s.timeout > 0) timeoutTimer = window1.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout);
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e1) {
                    // Rethrow post-completion exceptions
                    if (completed) throw e1;
                    // Propagate others as results
                    done(-1, e1);
                }
            }
            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                // Ignore repeat invocations
                if (completed) return;
                completed = true;
                // Clear timeout if it exists
                if (timeoutTimer) window1.clearTimeout(timeoutTimer);
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
                // Cache response headers
                responseHeadersString = headers || "";
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
                // Get response data
                if (responses) response = ajaxHandleResponses(s, jqXHR, responses);
                // Use a noop converter for missing script but not if jsonp
                if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) s.converters["text script"] = function() {};
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) jQuery.lastModified[cacheURL] = modified;
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) jQuery.etag[cacheURL] = modified;
                    }
                    // if no content
                    if (status === 204 || s.type === "HEAD") statusText = "nocontent";
                    else if (status === 304) statusText = "notmodified";
                    else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) status = 0;
                    }
                }
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                // Success/Error
                if (isSuccess) deferred.resolveWith(callbackContext, [
                    success,
                    statusText,
                    jqXHR
                ]);
                else deferred.rejectWith(callbackContext, [
                    jqXHR,
                    statusText,
                    error
                ]);
                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
                    jqXHR,
                    s,
                    isSuccess ? success : error
                ]);
                // Complete
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [
                        jqXHR,
                        s
                    ]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) jQuery.event.trigger("ajaxStop");
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([
        "get",
        "post"
    ], function(_i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery.ajaxPrefilter(function(s) {
        var i;
        for(i in s.headers)if (i.toLowerCase() === "content-type") s.contentType = s.headers[i] || "";
    });
    jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
            url: url,
            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
                "text script": function() {}
            },
            dataFilter: function(response) {
                jQuery.globalEval(response, options, doc);
            }
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (this[0]) {
                if (isFunction(html)) html = html.call(this[0]);
                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) wrap.insertBefore(this[0]);
                wrap.map(function() {
                    var elem = this;
                    while(elem.firstElementChild)elem = elem.firstElementChild;
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            });
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) contents.wrapAll(html);
                else self.append(html);
            });
        },
        wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window1.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(options.type, options.url, options.async, options.username, options.password);
                // Apply custom fields if provided
                if (options.xhrFields) for(i in options.xhrFields)xhr[i] = options.xhrFields[i];
                // Override mime type if needed
                if (options.mimeType && xhr.overrideMimeType) xhr.overrideMimeType(options.mimeType);
                // X-Requested-With header
                // For cross-domain requests, seeing as conditions for a preflight are
                // akin to a jigsaw puzzle, we simply never set it to be sure.
                // (it can always be set on a per-request basis or even using ajaxSetup)
                // For same-domain requests, won't change header if already provided.
                if (!options.crossDomain && !headers["X-Requested-With"]) headers["X-Requested-With"] = "XMLHttpRequest";
                // Set headers
                for(i in headers)xhr.setRequestHeader(i, headers[i]);
                // Callback
                callback = function(type) {
                    return function() {
                        if (callback) {
                            callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                            if (type === "abort") xhr.abort();
                            else if (type === "error") {
                                // Support: IE <=9 only
                                // On a manual native abort, IE9 throws
                                // errors on any property access that is not readyState
                                if (typeof xhr.status !== "number") complete(0, "error");
                                else complete(// File: protocol always yields status 0; see #8605, #14207
                                xhr.status, xhr.statusText);
                            } else complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders());
                        }
                    };
                };
                // Listen to events
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                // Support: IE 9 only
                // Use onreadystatechange to replace onabort
                // to handle uncaught aborts
                if (xhr.onabort !== undefined) xhr.onabort = errorCallback;
                else xhr.onreadystatechange = function() {
                    // Check readyState before timeout as it changes
                    if (xhr.readyState === 4) // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window1.setTimeout(function() {
                        if (callback) errorCallback();
                    });
                };
                // Create the abort callback
                callback = callback("abort");
                try {
                    // Do send the request (this may raise an exception)
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    // #14683: Only rethrow if this hasn't been notified as an error yet
                    if (callback) throw e;
                }
            },
            abort: function() {
                if (callback) callback();
            }
        };
    });
    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function(s) {
        if (s.crossDomain) s.contents.script = false;
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) s.cache = false;
        if (s.crossDomain) s.type = "GET";
    });
    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) complete(evt.type === "error" ? 404 : 200, evt.type);
                    });
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
        }
    });
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            // Insert callback into url or form data
            if (jsonProp) s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            else if (s.jsonp !== false) s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) jQuery.error(callbackName + " was not called");
                return responseContainer[0];
            };
            // Force json dataType
            s.dataTypes[0] = "json";
            // Install callback
            overwritten = window1[callbackName];
            window1[callbackName] = function() {
                responseContainer = arguments;
            };
            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // If previous value didn't exist - remove it
                if (overwritten === undefined) jQuery(window1).removeProp(callbackName);
                else window1[callbackName] = overwritten;
                // Save back as free
                if (s[callbackName]) {
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }
                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) overwritten(responseContainer[0]);
                responseContainer = overwritten = undefined;
            });
            // Delegate to script
            return "script";
        }
    });
    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = function() {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    }();
    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") return [];
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument("");
                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document.location.href;
                context.head.appendChild(base);
            } else context = document;
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        // Single tag
        if (parsed) return [
            context.createElement(parsed[1])
        ];
        parsed = buildFragment([
            data
        ], context, scripts);
        if (scripts && scripts.length) jQuery(scripts).remove();
        return jQuery.merge([], parsed.childNodes);
    };
    /**
 * Load a url into a page
 */ jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        // If it's a function
        if (isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;
        // Otherwise, build a param string
        } else if (params && typeof params === "object") type = "POST";
        // If we have elements to modify, make the request
        if (self.length > 0) jQuery.ajax({
            url: url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            // Save response for use in complete callback
            response = arguments;
            self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
            responseText);
        // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        });
        return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            // Set position first, in-case top/left are set even on static elem
            if (position === "static") elem.style.position = "relative";
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call(elem, i, jQuery.extend({}, curOffset));
            if (options.top != null) props.top = options.top - curOffset.top + curTop;
            if (options.left != null) props.left = options.left - curOffset.left + curLeft;
            if ("using" in options) options.using.call(elem, props);
            else curElem.css(props);
        }
    };
    jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
            // Preserve chaining for setter
            if (arguments.length) return options === undefined ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var rect, win, elem = this[0];
            if (!elem) return;
            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) return {
                top: 0,
                left: 0
            };
            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
            if (!this[0]) return;
            var offsetParent, offset, doc, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") // Assume position:fixed implies availability of getBoundingClientRect
            offset = elem.getBoundingClientRect();
            else {
                offset = this.offset();
                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while(offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.parentNode;
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }
            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while(offsetParent && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement;
            });
        }
    });
    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) win = elem;
                else if (elem.nodeType === 9) win = elem.defaultView;
                if (val === undefined) return win ? win[prop] : elem[method];
                if (win) win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                else elem[method] = val;
            }, method, val, arguments.length);
        };
    });
    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each([
        "top",
        "left"
    ], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (isWindow(elem)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) : // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function(_i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }
        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) return undefined;
        // Simulated bind
        args = slice.call(arguments, 2);
        proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };
        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
    };
    jQuery.holdReady = function(hold) {
        if (hold) jQuery.readyWait++;
        else jQuery.ready(true);
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "");
    };
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    if (typeof define === "function" && define.amd) define("jquery", [], function() {
        return jQuery;
    });
    var // Map over jQuery in case of overwrite
    _jQuery = window1.jQuery, // Map over the $ in case of overwrite
    _$ = window1.$;
    jQuery.noConflict = function(deep) {
        if (window1.$ === jQuery) window1.$ = _$;
        if (deep && window1.jQuery === jQuery) window1.jQuery = _jQuery;
        return jQuery;
    };
    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === "undefined") window1.jQuery = window1.$ = jQuery;
    return jQuery;
});

},{}],"4pi7m":[function(require,module,exports) {
module.exports = "body {\n  font-family: var(--body-font-family);\n  font-size: var(--body-font-size);\n  font-weight: var(--body-font-weight);\n  line-height: var(--body-line-height);\n  color: var(--body-color);\n  text-align: var(--body-text-align);\n  background-color: var(--body-bg);\n  -webkit-text-size-adjust: 100%;\n  -webkit-tap-highlight-color: transparent;\n  margin: 0;\n}\n\njuel-dialog-manager > *, .hide, .hidden {\n  display: none;\n}\n\n.fullscreen {\n  width: 100vw;\n  height: 100vh;\n}\n\n.flex {\n  flex-flow: column wrap;\n  display: flex;\n}\n\n.flex form {\n  flex-direction: column;\n  display: flex;\n}\n\n.item p {\n  margin: 0;\n}\n\nbody {\n  --icon-align-centre: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20d%3D%22M352%2064c0-17.7-14.3-32-32-32H128c-17.7%200-32%2014.3-32%2032s14.3%2032%2032%2032H320c17.7%200%2032-14.3%2032-32zm96%20128c0-17.7-14.3-32-32-32H32c-17.7%200-32%2014.3-32%2032s14.3%2032%2032%2032H416c17.7%200%2032-14.3%2032-32zM0%20448c0%2017.7%2014.3%2032%2032%2032H416c17.7%200%2032-14.3%2032-32s-14.3-32-32-32H32c-17.7%200-32%2014.3-32%2032zM352%20320c0-17.7-14.3-32-32-32H128c-17.7%200-32%2014.3-32%2032s14.3%2032%2032%2032H320c17.7%200%2032-14.3%2032-32z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-align-justify: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20d%3D%22M448%2064c0-17.7-14.3-32-32-32H32C14.3%2032%200%2046.3%200%2064S14.3%2096%2032%2096H416c17.7%200%2032-14.3%2032-32zm0%20256c0-17.7-14.3-32-32-32H32c-17.7%200-32%2014.3-32%2032s14.3%2032%2032%2032H416c17.7%200%2032-14.3%2032-32zM0%20192c0%2017.7%2014.3%2032%2032%2032H416c17.7%200%2032-14.3%2032-32s-14.3-32-32-32H32c-17.7%200-32%2014.3-32%2032zM448%20448c0-17.7-14.3-32-32-32H32c-17.7%200-32%2014.3-32%2032s14.3%2032%2032%2032H416c17.7%200%2032-14.3%2032-32z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-align-left: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20d%3D%22M288%2064c0%2017.7-14.3%2032-32%2032H32C14.3%2096%200%2081.7%200%2064S14.3%2032%2032%2032H256c17.7%200%2032%2014.3%2032%2032zm0%20256c0%2017.7-14.3%2032-32%2032H32c-17.7%200-32-14.3-32-32s14.3-32%2032-32H256c17.7%200%2032%2014.3%2032%2032zM0%20192c0-17.7%2014.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H32c-17.7%200-32-14.3-32-32zM448%20448c0%2017.7-14.3%2032-32%2032H32c-17.7%200-32-14.3-32-32s14.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-align-right: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20d%3D%22M448%2064c0%2017.7-14.3%2032-32%2032H192c-17.7%200-32-14.3-32-32s14.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032zm0%20256c0%2017.7-14.3%2032-32%2032H192c-17.7%200-32-14.3-32-32s14.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032zM0%20192c0-17.7%2014.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H32c-17.7%200-32-14.3-32-32zM448%20448c0%2017.7-14.3%2032-32%2032H32c-17.7%200-32-14.3-32-32s14.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-indent: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20d%3D%22M0%2064C0%2046.3%2014.3%2032%2032%2032H416c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H32C14.3%2096%200%2081.7%200%2064zM192%20192c0-17.7%2014.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H224c-17.7%200-32-14.3-32-32zm32%2096H416c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H224c-17.7%200-32-14.3-32-32s14.3-32%2032-32zM0%20448c0-17.7%2014.3-32%2032-32H416c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H32c-17.7%200-32-14.3-32-32zM127.8%20268.6L25.8%20347.9C15.3%20356.1%200%20348.6%200%20335.3V176.7c0-13.3%2015.3-20.8%2025.8-12.6l101.9%2079.3c8.2%206.4%208.2%2018.9%200%2025.3z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-outdent: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M32%2064c0-17.7%2014.3-32%2032-32H448c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H64C46.3%2096%2032%2081.7%2032%2064zM224%20192c0-17.7%2014.3-32%2032-32H448c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H256c-17.7%200-32-14.3-32-32zm32%2096H448c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H256c-17.7%200-32-14.3-32-32s14.3-32%2032-32zM32%20448c0-17.7%2014.3-32%2032-32H448c17.7%200%2032%2014.3%2032%2032s-14.3%2032-32%2032H64c-17.7%200-32-14.3-32-32zm.2-179.4c-8.2-6.4-8.2-18.9%200-25.3l101.9-79.3c10.5-8.2%2025.8-.7%2025.8%2012.6V335.3c0%2013.3-15.3%2020.8-25.8%2012.6L32.2%20268.6z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-smile: url(\"data:image/svg+xml,%3Csvg%20id%3D%22icon-smile%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20stroke%3D%22var%28--stroke%2C%20black%29%22%20d%3D%22M256%20352C293.2%20352%20319.2%20334.5%20334.4%20318.1C343.3%20308.4%20358.5%20307.7%20368.3%20316.7C378%20325.7%20378.6%20340.9%20369.6%20350.6C347.7%20374.5%20309.7%20400%20256%20400C202.3%20400%20164.3%20374.5%20142.4%20350.6C133.4%20340.9%20133.1%20325.7%20143.7%20316.7C153.5%20307.7%20168.7%20308.4%20177.6%20318.1C192.8%20334.5%20218.8%20352%20256%20352zM208.4%20208C208.4%20225.7%20194%20240%20176.4%20240C158.7%20240%20144.4%20225.7%20144.4%20208C144.4%20190.3%20158.7%20176%20176.4%20176C194%20176%20208.4%20190.3%20208.4%20208zM304.4%20208C304.4%20190.3%20318.7%20176%20336.4%20176C354%20176%20368.4%20190.3%20368.4%20208C368.4%20225.7%20354%20240%20336.4%20240C318.7%20240%20304.4%20225.7%20304.4%20208zM512%20256C512%20397.4%20397.4%20512%20256%20512C114.6%20512%200%20397.4%200%20256C0%20114.6%20114.6%200%20256%200C397.4%200%20512%20114.6%20512%20256zM256%2048C141.1%2048%2048%20141.1%2048%20256C48%20370.9%20141.1%20464%20256%20464C370.9%20464%20464%20370.9%20464%20256C464%20141.1%20370.9%2048%20256%2048z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n}\n\n.icon.align-centre {\n  background-image: var(--icon-align-centre);\n}\n\n.icon.align-justify {\n  background-image: var(--icon-align-justify);\n}\n\n.icon.align-left {\n  background-image: var(--icon-align-left);\n}\n\n.icon.align-right {\n  background-image: var(--icon-align-right);\n}\n\n.icon.indent {\n  background-image: var(--icon-indent);\n}\n\n.icon.outdent {\n  background-image: var(--icon-outdent);\n  background-image: var(--icon-smile);\n}\n\n.icon-lg {\n  width: 48px;\n  height: 48px;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n\n.icon-sm {\n  width: 16px;\n  height: 16px;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n\n.icon {\n  width: 32px;\n  height: 32px;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n\n.icon.access {\n  background-image: var(--icon-access);\n}\n\n:root {\n  --primary: #007bff;\n  --primary-text: #343a40;\n  --secondary: #6c757d;\n  --secondary-text: #f8f9fa;\n  --tertiary: salmon;\n  --tertiary-text: salmon;\n  --highlight: #007bff;\n  --active: #e7f1ff --light: #f8f9fa;\n  --dark: #343a40;\n  --success: #28a745;\n  --info: #17a2b8;\n  --warning: #ffc107;\n  --danger: #dc3545;\n  --highlight-text: #343a40;\n  --active-text: #0c63e4;\n  --light-text: #f8f9fa;\n  --dark-text: #343a40;\n  --success-text: #28a745;\n  --info-text: #343a40;\n  --warning-text: #343a40;\n  --danger-text: #dc3545;\n  --icon-previous: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20fill%3D%22var%28--fil%2C%20%2323fff%29%22%20d%3D%22M11.354%201.646a.5.5%200%200%201%200%20.708L5.707%208l5.647%205.646a.5.5%200%200%201-.708.708l-6-6a.5.5%200%200%201%200-.708l6-6a.5.5%200%200%201%20.708%200z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-next: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20fill%3D%22var%28--fill%2C%20%2323fff%29%22%20d%3D%22M4.646%201.646a.5.5%200%200%201%20.708%200l6%206a.5.5%200%200%201%200%20.708l-6%206a.5.5%200%200%201-.708-.708L10.293%208%204.646%202.354a.5.5%200%200%201%200-.708z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-indicator: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22rgba%28280%2C0%2C0%2C.5%29%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%222%22%20d%3D%22M5%2014l6-6-6-6%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-crosshair: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20id%3D%22root%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%3E%3Ccircle%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%3E%3C%2Fcircle%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%208%200%20L%208%206.5%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%200%208%20L%206.5%208%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%208%209.5%20L%208%2016%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%209.5%208%20L%2016%208%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-close: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220px%22%20height%3D%2220px%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20fill%3D%22var%28--fill%2C%20black%29%22%20d%3D%22M%204.7070312%203.2929688%20L%203.2929688%204.7070312%20L%2010.585938%2012%20L%203.2929688%2019.292969%20L%204.7070312%2020.707031%20L%2012%2013.414062%20L%2019.292969%2020.707031%20L%2020.707031%2019.292969%20L%2013.414062%2012%20L%2020.707031%204.7070312%20L%2019.292969%203.2929688%20L%2012%2010.585938%20L%204.7070312%203.2929688%20z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-tick: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2020%2020%22%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22var%28--stroke%2C%20white%29%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%223%22%20d%3D%22M6%2010l3%203l6-6%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-access: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M512%20256c0%20141.4-114.6%20256-256%20256S0%20397.4%200%20256S114.6%200%20256%200S512%20114.6%20512%20256zM161.5%20169.9c-12.2-5.2-26.3%20.4-31.5%2012.6s.4%2026.3%2012.6%2031.5l11.9%205.1c17.3%207.4%2035.2%2012.9%2053.6%2016.3v50.1c0%204.3-.7%208.6-2.1%2012.6l-28.7%2086.1c-4.2%2012.6%202.6%2026.2%2015.2%2030.4s26.2-2.6%2030.4-15.2l24.4-73.2c1.3-3.8%204.8-6.4%208.8-6.4s7.6%202.6%208.8%206.4l24.4%2073.2c4.2%2012.6%2017.8%2019.4%2030.4%2015.2s19.4-17.8%2015.2-30.4l-28.7-86.1c-1.4-4.1-2.1-8.3-2.1-12.6V235.5c18.4-3.5%2036.3-8.9%2053.6-16.3l11.9-5.1c12.2-5.2%2017.8-19.3%2012.6-31.5s-19.3-17.8-31.5-12.6L338.7%20175c-26.1%2011.2-54.2%2017-82.7%2017s-56.5-5.8-82.7-17l-11.9-5.1zM256%20160c22.1%200%2040-17.9%2040-40s-17.9-40-40-40s-40%2017.9-40%2040s17.9%2040%2040%2040z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --justify: center;\n  --padding-left: 32px;\n  --padding-right: 32px;\n  --body-color-rgb: 33, 37, 41;\n  --body-bg-rgb: 255, 255, 255;\n  --font-sans-serif: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Liberation Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n  --font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  --gradient: linear-gradient(180deg, #ffffff26, #fff0);\n  --body-font-family: var(--font-sans-serif);\n  --body-font-size: 1rem;\n  --body-font-weight: 400;\n  --body-line-height: 1.5;\n  --body-color: #212529;\n}\n\n::part(ripple) {\n  background-color: #ffffffb3;\n  border-radius: 50%;\n  animation: .6s linear ripple;\n  position: absolute;\n  transform: scale(0);\n}\n\n";

},{}],"5Z54X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IsMobile", ()=>IsMobile);
function IsMobile() {
    if ("isMobile" in window) return window.isMobile;
    else {
        window["isMobile"] = window.matchMedia("(max-device-width: 500px)").matches || window.matchMedia("(max-device-height: 500px)").matches;
        return window["isMobile"];
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6DlUO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vh", ()=>Vh);
function Vh() {
    let root = document.documentElement;
    function updateRealViewportDimensions() {
        root.style.setProperty("--vh", window.innerHeight / 100 + "px");
    }
    updateRealViewportDimensions();
    const vhChangeEventTypes = [
        "scroll",
        "resize",
        "fullscreenchange",
        "fullscreenerror",
        "touchcancel",
        "touchend",
        "touchmove",
        "touchstart",
        "mozbrowserscroll",
        "mozbrowserscrollareachanged",
        "mozbrowserscrollviewchange",
        "mozbrowserresize",
        "MozScrolledAreaChanged",
        "mozbrowserresize",
        "orientationchange"
    ];
    vhChangeEventTypes.forEach(function(type) {
        window.addEventListener(type, (event)=>updateRealViewportDimensions());
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cBFL0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelAccordion", ()=>JuelAccordion);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _accordionLess = require("bundle-text:./Accordion.less");
var _accordionLessDefault = parcelHelpers.interopDefault(_accordionLess);
var _childrenMap = require("../_Utils/ChildrenMap");
var _navigationBase = require("../_Base/NavigationBase");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelAccordion = class JuelAccordion extends (0, _navigationBase.NavigationBase) {
    constructor(){
        super();
        this.size = "500px";
        this.horizontal = false;
        this.multiple = false;
    }
    navigateToSelector(selector) {
        let children = $(this).children().not('[slot*="title"]');
        let el = this.querySelector(selector);
        if (el) {
            let index = children.index(el);
            console.log(index);
            if (index >= 0) this.navigateToIndex(index);
        }
    }
    navigateToIndex(index) {
        let el = this.shadowRoot.querySelector(`[data-index="${index}"]`);
        if (el) {
            el.classList.toggle("active");
            if (el.classList.contains("active")) $(el).siblings(".title").removeClass("active");
        }
    }
    titleClick(index) {
        let el = this.shadowRoot.querySelector(`[data-index="${index}"]`);
        if (el) {
            el.classList.toggle("active");
            if (el.classList.contains("active")) $(el).siblings(".title").removeClass("active");
        }
    }
    render() {
        return (0, _lit.html)`<div id="container" class="${this.horizontal == true ? "horizontal" : ""}">
            ${(0, _childrenMap.ChildrenMap)(this, (ele, index)=>{
            let id = ele.id ? ele.id : `accordion-section-${index}`;
            ele.setAttribute("slot", id);
            let hasTitleEl = false;
            let titleElId = `${id}-title`;
            let titleEl = ele.previousElementSibling;
            if (titleEl && titleEl.matches('[slot*="title"')) {
                hasTitleEl = true;
                titleEl.setAttribute("slot", titleElId);
                if (titleEl.hasAttribute("id") && ele.hasAttribute("id") == false) {
                    ele.id = titleEl.id;
                    titleEl.removeAttribute("id");
                }
            }
            return (0, _lit.html)`<div class="title" data-index="${index}" @click="${()=>this.titleClick(index)}">
                        ${hasTitleEl ? (0, _lit.html)`<slot name="${titleElId}"></slot>` : (0, _lit.html)`<span>
                                ${ele.dataset.title ? ele.dataset.title : ""}
                            </span>`}
                        </div>
                        <div class="panel">
                        <slot name="${id}"></slot>
                        </div>`;
        }, '[slot*="title"]')}
        </div>`;
    }
};
JuelAccordion.styles = (0, _lit.unsafeCSS)((0, _accordionLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelAccordion.prototype, "size", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelAccordion.prototype, "horizontal", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelAccordion.prototype, "multiple", void 0);
JuelAccordion = __decorate([
    (0, _decorators.customElement)("juel-accordion")
], JuelAccordion);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Accordion.less":"k4hT0","../_Utils/ChildrenMap":"hG10d","../_Base/NavigationBase":"847qf","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"l2dGb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _reactiveElement = require("@lit/reactive-element");
var _litHtml = require("lit-html");
var _litElementJs = require("lit-element/lit-element.js");
parcelHelpers.exportAll(_litElementJs, exports);
var _isServerJs = require("lit-html/is-server.js");
parcelHelpers.exportAll(_isServerJs, exports);

},{"@lit/reactive-element":"bEPUZ","lit-html":"ckCvK","lit-element/lit-element.js":"geGtJ","lit-html/is-server.js":"byFTV","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bEPUZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CSSResult", ()=>(0, _cssTagJs.CSSResult));
parcelHelpers.export(exports, "adoptStyles", ()=>(0, _cssTagJs.adoptStyles));
parcelHelpers.export(exports, "css", ()=>(0, _cssTagJs.css));
parcelHelpers.export(exports, "getCompatibleStyle", ()=>(0, _cssTagJs.getCompatibleStyle));
parcelHelpers.export(exports, "supportsAdoptingStyleSheets", ()=>(0, _cssTagJs.supportsAdoptingStyleSheets));
parcelHelpers.export(exports, "unsafeCSS", ()=>(0, _cssTagJs.unsafeCSS));
parcelHelpers.export(exports, "ReactiveElement", ()=>d);
parcelHelpers.export(exports, "defaultConverter", ()=>n);
parcelHelpers.export(exports, "notEqual", ()=>a);
var _cssTagJs = require("./css-tag.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var s;
const e = window, r = e.trustedTypes, h = r ? r.emptyScript : "", o = e.reactiveElementPolyfillSupport, n = {
    toAttribute (t, i) {
        switch(i){
            case Boolean:
                t = t ? h : null;
                break;
            case Object:
            case Array:
                t = null == t ? t : JSON.stringify(t);
        }
        return t;
    },
    fromAttribute (t, i) {
        let s = t;
        switch(i){
            case Boolean:
                s = null !== t;
                break;
            case Number:
                s = null === t ? null : Number(t);
                break;
            case Object:
            case Array:
                try {
                    s = JSON.parse(t);
                } catch (t1) {
                    s = null;
                }
        }
        return s;
    }
}, a = (t, i)=>i !== t && (i == i || t == t), l = {
    attribute: !0,
    type: String,
    converter: n,
    reflect: !1,
    hasChanged: a
};
class d extends HTMLElement {
    constructor(){
        super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u();
    }
    static addInitializer(t) {
        var i;
        null !== (i = this.h) && void 0 !== i || (this.h = []), this.h.push(t);
    }
    static get observedAttributes() {
        this.finalize();
        const t = [];
        return this.elementProperties.forEach((i, s)=>{
            const e = this._$Ep(s, i);
            void 0 !== e && (this._$Ev.set(e, s), t.push(e));
        }), t;
    }
    static createProperty(t, i = l) {
        if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {
            const s = "symbol" == typeof t ? Symbol() : "__" + t, e = this.getPropertyDescriptor(t, s, i);
            void 0 !== e && Object.defineProperty(this.prototype, t, e);
        }
    }
    static getPropertyDescriptor(t, i, s) {
        return {
            get () {
                return this[i];
            },
            set (e) {
                const r = this[t];
                this[i] = e, this.requestUpdate(t, r, s);
            },
            configurable: !0,
            enumerable: !0
        };
    }
    static getPropertyOptions(t) {
        return this.elementProperties.get(t) || l;
    }
    static finalize() {
        if (this.hasOwnProperty("finalized")) return !1;
        this.finalized = !0;
        const t = Object.getPrototypeOf(this);
        if (t.finalize(), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) {
            const t1 = this.properties, i = [
                ...Object.getOwnPropertyNames(t1),
                ...Object.getOwnPropertySymbols(t1)
            ];
            for (const s of i)this.createProperty(s, t1[s]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), !0;
    }
    static finalizeStyles(i) {
        const s = [];
        if (Array.isArray(i)) {
            const e = new Set(i.flat(1 / 0).reverse());
            for (const i1 of e)s.unshift((0, _cssTagJs.getCompatibleStyle)(i1));
        } else void 0 !== i && s.push((0, _cssTagJs.getCompatibleStyle)(i));
        return s;
    }
    static _$Ep(t, i) {
        const s = i.attribute;
        return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0;
    }
    u() {
        var t;
        this._$E_ = new Promise((t)=>this.enableUpdating = t), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach((t)=>t(this));
    }
    addController(t) {
        var i, s;
        (null !== (i = this._$ES) && void 0 !== i ? i : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t));
    }
    removeController(t) {
        var i;
        null === (i = this._$ES) || void 0 === i || i.splice(this._$ES.indexOf(t) >>> 0, 1);
    }
    _$Eg() {
        this.constructor.elementProperties.forEach((t, i)=>{
            this.hasOwnProperty(i) && (this._$Ei.set(i, this[i]), delete this[i]);
        });
    }
    createRenderRoot() {
        var t;
        const s = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
        return (0, _cssTagJs.adoptStyles)(s, this.constructor.elementStyles), s;
    }
    connectedCallback() {
        var t;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach((t)=>{
            var i;
            return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t);
        });
    }
    enableUpdating(t) {}
    disconnectedCallback() {
        var t;
        null === (t = this._$ES) || void 0 === t || t.forEach((t)=>{
            var i;
            return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t);
        });
    }
    attributeChangedCallback(t, i, s) {
        this._$AK(t, s);
    }
    _$EO(t, i, s = l) {
        var e;
        const r = this.constructor._$Ep(t, s);
        if (void 0 !== r && !0 === s.reflect) {
            const h = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : n).toAttribute(i, s.type);
            this._$El = t, null == h ? this.removeAttribute(r) : this.setAttribute(r, h), this._$El = null;
        }
    }
    _$AK(t, i) {
        var s;
        const e = this.constructor, r = e._$Ev.get(t);
        if (void 0 !== r && this._$El !== r) {
            const t1 = e.getPropertyOptions(r), h = "function" == typeof t1.converter ? {
                fromAttribute: t1.converter
            } : void 0 !== (null === (s = t1.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t1.converter : n;
            this._$El = r, this[r] = h.fromAttribute(i, t1.type), this._$El = null;
        }
    }
    requestUpdate(t, i, s) {
        let e = !0;
        void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || a)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
        this.isUpdatePending = !0;
        try {
            await this._$E_;
        } catch (t) {
            Promise.reject(t);
        }
        const t1 = this.scheduleUpdate();
        return null != t1 && await t1, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var t;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Ei && (this._$Ei.forEach((t, i)=>this[i] = t), this._$Ei = void 0);
        let i = !1;
        const s = this._$AL;
        try {
            i = this.shouldUpdate(s), i ? (this.willUpdate(s), null === (t = this._$ES) || void 0 === t || t.forEach((t)=>{
                var i;
                return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t);
            }), this.update(s)) : this._$Ek();
        } catch (t1) {
            throw i = !1, this._$Ek(), t1;
        }
        i && this._$AE(s);
    }
    willUpdate(t) {}
    _$AE(t) {
        var i;
        null === (i = this._$ES) || void 0 === i || i.forEach((t)=>{
            var i;
            return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t);
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
    }
    _$Ek() {
        this._$AL = new Map, this.isUpdatePending = !1;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$E_;
    }
    shouldUpdate(t) {
        return !0;
    }
    update(t) {
        void 0 !== this._$EC && (this._$EC.forEach((t, i)=>this._$EO(i, this[i], t)), this._$EC = void 0), this._$Ek();
    }
    updated(t) {}
    firstUpdated(t) {}
}
d.finalized = !0, d.elementProperties = new Map, d.elementStyles = [], d.shadowRootOptions = {
    mode: "open"
}, null == o || o({
    ReactiveElement: d
}), (null !== (s = e.reactiveElementVersions) && void 0 !== s ? s : e.reactiveElementVersions = []).push("1.4.1");

},{"./css-tag.js":"i5Kjj","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"i5Kjj":[function(require,module,exports) {
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CSSResult", ()=>o);
parcelHelpers.export(exports, "adoptStyles", ()=>S);
parcelHelpers.export(exports, "css", ()=>i);
parcelHelpers.export(exports, "getCompatibleStyle", ()=>c);
parcelHelpers.export(exports, "supportsAdoptingStyleSheets", ()=>e);
parcelHelpers.export(exports, "unsafeCSS", ()=>r);
const t = window, e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s = Symbol(), n = new WeakMap;
class o {
    constructor(t, e, n){
        if (this._$cssResult$ = !0, n !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t, this.t = e;
    }
    get styleSheet() {
        let t = this.o;
        const s = this.t;
        if (e && void 0 === t) {
            const e1 = void 0 !== s && 1 === s.length;
            e1 && (t = n.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText), e1 && n.set(s, t));
        }
        return t;
    }
    toString() {
        return this.cssText;
    }
}
const r = (t)=>new o("string" == typeof t ? t : t + "", void 0, s), i = (t, ...e)=>{
    const n = 1 === t.length ? t[0] : e.reduce((e, s, n)=>e + ((t)=>{
            if (!0 === t._$cssResult$) return t.cssText;
            if ("number" == typeof t) return t;
            throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
        })(s) + t[n + 1], t[0]);
    return new o(n, t, s);
}, S = (s, n)=>{
    e ? s.adoptedStyleSheets = n.map((t)=>t instanceof CSSStyleSheet ? t : t.styleSheet) : n.forEach((e)=>{
        const n = document.createElement("style"), o = t.litNonce;
        void 0 !== o && n.setAttribute("nonce", o), n.textContent = e.cssText, s.appendChild(n);
    });
}, c = e ? (t)=>t : (t)=>t instanceof CSSStyleSheet ? ((t)=>{
        let e = "";
        for (const s of t.cssRules)e += s.cssText;
        return r(e);
    })(t) : t;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ckCvK":[function(require,module,exports) {
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_$LH", ()=>L);
parcelHelpers.export(exports, "html", ()=>y);
parcelHelpers.export(exports, "noChange", ()=>x);
parcelHelpers.export(exports, "nothing", ()=>b);
parcelHelpers.export(exports, "render", ()=>Z);
parcelHelpers.export(exports, "svg", ()=>w);
var t;
const i = window, s = i.trustedTypes, e = s ? s.createPolicy("lit-html", {
    createHTML: (t)=>t
}) : void 0, o = `lit$${(Math.random() + "").slice(9)}$`, n = "?" + o, l = `<${n}>`, h = document, r = (t = "")=>h.createComment(t), d = (t)=>null === t || "object" != typeof t && "function" != typeof t, u = Array.isArray, c = (t)=>u(t) || "function" == typeof (null == t ? void 0 : t[Symbol.iterator]), v = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, a = /-->/g, f = />/g, _ = RegExp(">|[ 	\n\f\r](?:([^\\s\"'>=/]+)([ 	\n\f\r]*=[ 	\n\f\r]*(?:[^ 	\n\f\r\"'`<>=]|(\"|')|))|$)", "g"), m = /'/g, p = /"/g, $ = /^(?:script|style|textarea|title)$/i, g = (t)=>(i, ...s)=>({
            _$litType$: t,
            strings: i,
            values: s
        }), y = g(1), w = g(2), x = Symbol.for("lit-noChange"), b = Symbol.for("lit-nothing"), T = new WeakMap, A = h.createTreeWalker(h, 129, null, !1), E = (t, i)=>{
    const s = t.length - 1, n = [];
    let h, r = 2 === i ? "<svg>" : "", d = v;
    for(let i1 = 0; i1 < s; i1++){
        const s1 = t[i1];
        let e1, u, c = -1, g = 0;
        for(; g < s1.length && (d.lastIndex = g, u = d.exec(s1), null !== u);)g = d.lastIndex, d === v ? "!--" === u[1] ? d = a : void 0 !== u[1] ? d = f : void 0 !== u[2] ? ($.test(u[2]) && (h = RegExp("</" + u[2], "g")), d = _) : void 0 !== u[3] && (d = _) : d === _ ? ">" === u[0] ? (d = null != h ? h : v, c = -1) : void 0 === u[1] ? c = -2 : (c = d.lastIndex - u[2].length, e1 = u[1], d = void 0 === u[3] ? _ : '"' === u[3] ? p : m) : d === p || d === m ? d = _ : d === a || d === f ? d = v : (d = _, h = void 0);
        const y = d === _ && t[i1 + 1].startsWith("/>") ? " " : "";
        r += d === v ? s1 + l : c >= 0 ? (n.push(e1), s1.slice(0, c) + "$lit$" + s1.slice(c) + o + y) : s1 + o + (-2 === c ? (n.push(void 0), i1) : y);
    }
    const u1 = r + (t[s] || "<?>") + (2 === i ? "</svg>" : "");
    if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [
        void 0 !== e ? e.createHTML(u1) : u1,
        n
    ];
};
class C {
    constructor({ strings: t , _$litType$: i  }, e){
        let l;
        this.parts = [];
        let h = 0, d = 0;
        const u = t.length - 1, c = this.parts, [v, a] = E(t, i);
        if (this.el = C.createElement(v, e), A.currentNode = this.el.content, 2 === i) {
            const t1 = this.el.content, i1 = t1.firstChild;
            i1.remove(), t1.append(...i1.childNodes);
        }
        for(; null !== (l = A.nextNode()) && c.length < u;){
            if (1 === l.nodeType) {
                if (l.hasAttributes()) {
                    const t2 = [];
                    for (const i2 of l.getAttributeNames())if (i2.endsWith("$lit$") || i2.startsWith(o)) {
                        const s1 = a[d++];
                        if (t2.push(i2), void 0 !== s1) {
                            const t3 = l.getAttribute(s1.toLowerCase() + "$lit$").split(o), i3 = /([.?@])?(.*)/.exec(s1);
                            c.push({
                                type: 1,
                                index: h,
                                name: i3[2],
                                strings: t3,
                                ctor: "." === i3[1] ? M : "?" === i3[1] ? k : "@" === i3[1] ? H : S
                            });
                        } else c.push({
                            type: 6,
                            index: h
                        });
                    }
                    for (const i4 of t2)l.removeAttribute(i4);
                }
                if ($.test(l.tagName)) {
                    const t4 = l.textContent.split(o), i5 = t4.length - 1;
                    if (i5 > 0) {
                        l.textContent = s ? s.emptyScript : "";
                        for(let s2 = 0; s2 < i5; s2++)l.append(t4[s2], r()), A.nextNode(), c.push({
                            type: 2,
                            index: ++h
                        });
                        l.append(t4[i5], r());
                    }
                }
            } else if (8 === l.nodeType) {
                if (l.data === n) c.push({
                    type: 2,
                    index: h
                });
                else {
                    let t5 = -1;
                    for(; -1 !== (t5 = l.data.indexOf(o, t5 + 1));)c.push({
                        type: 7,
                        index: h
                    }), t5 += o.length - 1;
                }
            }
            h++;
        }
    }
    static createElement(t, i) {
        const s = h.createElement("template");
        return s.innerHTML = t, s;
    }
}
function P(t, i, s = t, e) {
    var o, n, l, h;
    if (i === x) return i;
    let r = void 0 !== e ? null === (o = s._$Co) || void 0 === o ? void 0 : o[e] : s._$Cl;
    const u = d(i) ? void 0 : i._$litDirective$;
    return (null == r ? void 0 : r.constructor) !== u && (null === (n = null == r ? void 0 : r._$AO) || void 0 === n || n.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Co) && void 0 !== l ? l : h._$Co = [])[e] = r : s._$Cl = r), void 0 !== r && (i = P(t, r._$AS(t, i.values), r, e)), i;
}
class V {
    constructor(t, i){
        this.u = [], this._$AN = void 0, this._$AD = t, this._$AM = i;
    }
    get parentNode() {
        return this._$AM.parentNode;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    v(t) {
        var i;
        const { el: { content: s  } , parts: e  } = this._$AD, o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : h).importNode(s, !0);
        A.currentNode = o;
        let n = A.nextNode(), l = 0, r = 0, d = e[0];
        for(; void 0 !== d;){
            if (l === d.index) {
                let i1;
                2 === d.type ? i1 = new N(n, n.nextSibling, this, t) : 1 === d.type ? i1 = new d.ctor(n, d.name, d.strings, this, t) : 6 === d.type && (i1 = new I(n, this, t)), this.u.push(i1), d = e[++r];
            }
            l !== (null == d ? void 0 : d.index) && (n = A.nextNode(), l++);
        }
        return o;
    }
    p(t) {
        let i = 0;
        for (const s of this.u)void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;
    }
}
class N {
    constructor(t, i, s, e){
        var o;
        this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cm = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;
    }
    get _$AU() {
        var t, i;
        return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cm;
    }
    get parentNode() {
        let t = this._$AA.parentNode;
        const i = this._$AM;
        return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t;
    }
    get startNode() {
        return this._$AA;
    }
    get endNode() {
        return this._$AB;
    }
    _$AI(t, i = this) {
        t = P(this, t, i), d(t) ? t === b || null == t || "" === t ? (this._$AH !== b && this._$AR(), this._$AH = b) : t !== this._$AH && t !== x && this.g(t) : void 0 !== t._$litType$ ? this.$(t) : void 0 !== t.nodeType ? this.T(t) : c(t) ? this.k(t) : this.g(t);
    }
    O(t, i = this._$AB) {
        return this._$AA.parentNode.insertBefore(t, i);
    }
    T(t) {
        this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
    }
    g(t) {
        this._$AH !== b && d(this._$AH) ? this._$AA.nextSibling.data = t : this.T(h.createTextNode(t)), this._$AH = t;
    }
    $(t) {
        var i;
        const { values: s , _$litType$: e  } = t, o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = C.createElement(e.h, this.options)), e);
        if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.p(s);
        else {
            const t1 = new V(o, this), i1 = t1.v(this.options);
            t1.p(s), this.T(i1), this._$AH = t1;
        }
    }
    _$AC(t) {
        let i = T.get(t.strings);
        return void 0 === i && T.set(t.strings, i = new C(t)), i;
    }
    k(t) {
        u(this._$AH) || (this._$AH = [], this._$AR());
        const i = this._$AH;
        let s, e = 0;
        for (const o of t)e === i.length ? i.push(s = new N(this.O(r()), this.O(r()), this, this.options)) : s = i[e], s._$AI(o), e++;
        e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);
    }
    _$AR(t = this._$AA.nextSibling, i) {
        var s;
        for(null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;){
            const i1 = t.nextSibling;
            t.remove(), t = i1;
        }
    }
    setConnected(t) {
        var i;
        void 0 === this._$AM && (this._$Cm = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));
    }
}
class S {
    constructor(t, i, s, e, o){
        this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String), this.strings = s) : this._$AH = b;
    }
    get tagName() {
        return this.element.tagName;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t, i = this, s, e) {
        const o = this.strings;
        let n = !1;
        if (void 0 === o) t = P(this, t, i, 0), n = !d(t) || t !== this._$AH && t !== x, n && (this._$AH = t);
        else {
            const e1 = t;
            let l, h;
            for(t = o[0], l = 0; l < o.length - 1; l++)h = P(this, e1[s + l], i, l), h === x && (h = this._$AH[l]), n || (n = !d(h) || h !== this._$AH[l]), h === b ? t = b : t !== b && (t += (null != h ? h : "") + o[l + 1]), this._$AH[l] = h;
        }
        n && !e && this.j(t);
    }
    j(t) {
        t === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");
    }
}
class M extends S {
    constructor(){
        super(...arguments), this.type = 3;
    }
    j(t) {
        this.element[this.name] = t === b ? void 0 : t;
    }
}
const R = s ? s.emptyScript : "";
class k extends S {
    constructor(){
        super(...arguments), this.type = 4;
    }
    j(t) {
        t && t !== b ? this.element.setAttribute(this.name, R) : this.element.removeAttribute(this.name);
    }
}
class H extends S {
    constructor(t, i, s, e, o){
        super(t, i, s, e, o), this.type = 5;
    }
    _$AI(t, i = this) {
        var s;
        if ((t = null !== (s = P(this, t, i, 0)) && void 0 !== s ? s : b) === x) return;
        const e = this._$AH, o = t === b && e !== b || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive, n = t !== b && (e === b || o);
        o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;
    }
    handleEvent(t) {
        var i, s;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);
    }
}
class I {
    constructor(t, i, s){
        this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t) {
        P(this, t);
    }
}
const L = {
    P: "$lit$",
    A: o,
    M: n,
    C: 1,
    L: E,
    R: V,
    D: c,
    V: P,
    I: N,
    H: S,
    N: k,
    U: H,
    B: M,
    F: I
}, z = i.litHtmlPolyfillSupport;
null == z || z(C, N), (null !== (t = i.litHtmlVersions) && void 0 !== t ? t : i.litHtmlVersions = []).push("2.4.0");
const Z = (t, i, s)=>{
    var e, o;
    const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;
    let l = n._$litPart$;
    if (void 0 === l) {
        const t1 = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;
        n._$litPart$ = l = new N(i.insertBefore(r(), t1), t1, void 0, null != s ? s : {});
    }
    return l._$AI(t), l;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"geGtJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LitElement", ()=>s);
parcelHelpers.export(exports, "UpdatingElement", ()=>r);
parcelHelpers.export(exports, "_$LE", ()=>h);
var _reactiveElement = require("@lit/reactive-element");
parcelHelpers.exportAll(_reactiveElement, exports);
var _litHtml = require("lit-html");
parcelHelpers.exportAll(_litHtml, exports);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var l, o;
const r = (0, _reactiveElement.ReactiveElement);
class s extends (0, _reactiveElement.ReactiveElement) {
    constructor(){
        super(...arguments), this.renderOptions = {
            host: this
        }, this._$Do = void 0;
    }
    createRenderRoot() {
        var t, e;
        const i = super.createRenderRoot();
        return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = i.firstChild), i;
    }
    update(t) {
        const i = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = (0, _litHtml.render)(i, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
        var t;
        super.connectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!0);
    }
    disconnectedCallback() {
        var t;
        super.disconnectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!1);
    }
    render() {
        return 0, _litHtml.noChange;
    }
}
s.finalized = !0, s._$litElement$ = !0, null === (l = globalThis.litElementHydrateSupport) || void 0 === l || l.call(globalThis, {
    LitElement: s
});
const n = globalThis.litElementPolyfillSupport;
null == n || n({
    LitElement: s
});
const h = {
    _$AK: (t, e, i)=>{
        t._$AK(e, i);
    },
    _$AL: (t)=>t._$AL
};
(null !== (o = globalThis.litElementVersions) && void 0 !== o ? o : globalThis.litElementVersions = []).push("3.2.2");

},{"@lit/reactive-element":"bEPUZ","lit-html":"ckCvK","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"byFTV":[function(require,module,exports) {
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isServer", ()=>o);
const o = !1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"04xNl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _customElementJs = require("@lit/reactive-element/decorators/custom-element.js");
parcelHelpers.exportAll(_customElementJs, exports);
var _propertyJs = require("@lit/reactive-element/decorators/property.js");
parcelHelpers.exportAll(_propertyJs, exports);
var _stateJs = require("@lit/reactive-element/decorators/state.js");
parcelHelpers.exportAll(_stateJs, exports);
var _eventOptionsJs = require("@lit/reactive-element/decorators/event-options.js");
parcelHelpers.exportAll(_eventOptionsJs, exports);
var _queryJs = require("@lit/reactive-element/decorators/query.js");
parcelHelpers.exportAll(_queryJs, exports);
var _queryAllJs = require("@lit/reactive-element/decorators/query-all.js");
parcelHelpers.exportAll(_queryAllJs, exports);
var _queryAsyncJs = require("@lit/reactive-element/decorators/query-async.js");
parcelHelpers.exportAll(_queryAsyncJs, exports);
var _queryAssignedElementsJs = require("@lit/reactive-element/decorators/query-assigned-elements.js");
parcelHelpers.exportAll(_queryAssignedElementsJs, exports);
var _queryAssignedNodesJs = require("@lit/reactive-element/decorators/query-assigned-nodes.js");
parcelHelpers.exportAll(_queryAssignedNodesJs, exports);

},{"@lit/reactive-element/decorators/custom-element.js":"kED4T","@lit/reactive-element/decorators/property.js":"64KE2","@lit/reactive-element/decorators/state.js":"5U04d","@lit/reactive-element/decorators/event-options.js":"7pt0U","@lit/reactive-element/decorators/query.js":"1z8RC","@lit/reactive-element/decorators/query-all.js":"6ENMr","@lit/reactive-element/decorators/query-async.js":"hEkL9","@lit/reactive-element/decorators/query-assigned-elements.js":"k0xzb","@lit/reactive-element/decorators/query-assigned-nodes.js":"fVXUl","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"kED4T":[function(require,module,exports) {
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "customElement", ()=>e);
const e = (e)=>(n)=>"function" == typeof n ? ((e, n)=>(customElements.define(e, n), n))(e, n) : ((e, n)=>{
            const { kind: t , elements: s  } = n;
            return {
                kind: t,
                elements: s,
                finisher (n) {
                    customElements.define(e, n);
                }
            };
        })(e, n);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"64KE2":[function(require,module,exports) {
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "property", ()=>e);
const i = (i, e)=>"method" === e.kind && e.descriptor && !("value" in e.descriptor) ? {
        ...e,
        finisher (n) {
            n.createProperty(e.key, i);
        }
    } : {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: e.key,
        initializer () {
            "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this));
        },
        finisher (n) {
            n.createProperty(e.key, i);
        }
    };
function e(e) {
    return (n, t)=>void 0 !== t ? ((i, e, n)=>{
            e.constructor.createProperty(n, i);
        })(e, n, t) : i(e, n);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5U04d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "state", ()=>t);
var _propertyJs = require("./property.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function t(t) {
    return (0, _propertyJs.property)({
        ...t,
        state: !0
    });
}

},{"./property.js":"64KE2","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7pt0U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventOptions", ()=>e);
var _baseJs = require("./base.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function e(e) {
    return (0, _baseJs.decorateProperty)({
        finisher: (r, t)=>{
            Object.assign(r.prototype[t], e);
        }
    });
}

},{"./base.js":"11bbH","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"11bbH":[function(require,module,exports) {
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decorateProperty", ()=>o);
parcelHelpers.export(exports, "legacyPrototypeMethod", ()=>e);
parcelHelpers.export(exports, "standardPrototypeMethod", ()=>t);
const e = (e, t, o)=>{
    Object.defineProperty(t, o, e);
}, t = (e, t)=>({
        kind: "method",
        placement: "prototype",
        key: t.key,
        descriptor: e
    }), o = ({ finisher: e , descriptor: t  })=>(o, n)=>{
        var r;
        if (void 0 === n) {
            const n1 = null !== (r = o.originalKey) && void 0 !== r ? r : o.key, i = null != t ? {
                kind: "method",
                placement: "prototype",
                key: n1,
                descriptor: t(o.key)
            } : {
                ...o,
                key: n1
            };
            return null != e && (i.finisher = function(t) {
                e(t, n1);
            }), i;
        }
        {
            const r1 = o.constructor;
            void 0 !== t && Object.defineProperty(o, n, t(n)), null == e || e(r1, n);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1z8RC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "query", ()=>i);
var _baseJs = require("./base.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function i(i, n) {
    return (0, _baseJs.decorateProperty)({
        descriptor: (o)=>{
            const t = {
                get () {
                    var o, n;
                    return null !== (n = null === (o = this.renderRoot) || void 0 === o ? void 0 : o.querySelector(i)) && void 0 !== n ? n : null;
                },
                enumerable: !0,
                configurable: !0
            };
            if (n) {
                const n1 = "symbol" == typeof o ? Symbol() : "__" + o;
                t.get = function() {
                    var o, t;
                    return void 0 === this[n1] && (this[n1] = null !== (t = null === (o = this.renderRoot) || void 0 === o ? void 0 : o.querySelector(i)) && void 0 !== t ? t : null), this[n1];
                };
            }
            return t;
        }
    });
}

},{"./base.js":"11bbH","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6ENMr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "queryAll", ()=>e);
var _baseJs = require("./base.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function e(e) {
    return (0, _baseJs.decorateProperty)({
        descriptor: (r)=>({
                get () {
                    var r, o;
                    return null !== (o = null === (r = this.renderRoot) || void 0 === r ? void 0 : r.querySelectorAll(e)) && void 0 !== o ? o : [];
                },
                enumerable: !0,
                configurable: !0
            })
    });
}

},{"./base.js":"11bbH","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hEkL9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "queryAsync", ()=>e);
var _baseJs = require("./base.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function e(e) {
    return (0, _baseJs.decorateProperty)({
        descriptor: (r)=>({
                async get () {
                    var r;
                    return await this.updateComplete, null === (r = this.renderRoot) || void 0 === r ? void 0 : r.querySelector(e);
                },
                enumerable: !0,
                configurable: !0
            })
    });
}

},{"./base.js":"11bbH","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"k0xzb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "queryAssignedElements", ()=>l);
var _baseJs = require("./base.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var n;
const e = null != (null === (n = window.HTMLSlotElement) || void 0 === n ? void 0 : n.prototype.assignedElements) ? (o, n)=>o.assignedElements(n) : (o, n)=>o.assignedNodes(n).filter((o)=>o.nodeType === Node.ELEMENT_NODE);
function l(n) {
    const { slot: l , selector: t  } = null != n ? n : {};
    return (0, _baseJs.decorateProperty)({
        descriptor: (o)=>({
                get () {
                    var o;
                    const r = "slot" + (l ? `[name=${l}]` : ":not([name])"), i = null === (o = this.renderRoot) || void 0 === o ? void 0 : o.querySelector(r), s = null != i ? e(i, n) : [];
                    return t ? s.filter((o)=>o.matches(t)) : s;
                },
                enumerable: !0,
                configurable: !0
            })
    });
}

},{"./base.js":"11bbH","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fVXUl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "queryAssignedNodes", ()=>o);
var _baseJs = require("./base.js");
var _queryAssignedElementsJs = require("./query-assigned-elements.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function o(o, n, r) {
    let l, s = o;
    return "object" == typeof o ? (s = o.slot, l = o) : l = {
        flatten: n
    }, r ? (0, _queryAssignedElementsJs.queryAssignedElements)({
        slot: s,
        flatten: n,
        selector: r
    }) : (0, _baseJs.decorateProperty)({
        descriptor: (e)=>({
                get () {
                    var e, t;
                    const o = "slot" + (s ? `[name=${s}]` : ":not([name])"), n = null === (e = this.renderRoot) || void 0 === e ? void 0 : e.querySelector(o);
                    return null !== (t = null == n ? void 0 : n.assignedNodes(l)) && void 0 !== t ? t : [];
                },
                enumerable: !0,
                configurable: !0
            })
    });
}

},{"./base.js":"11bbH","./query-assigned-elements.js":"k0xzb","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"k4hT0":[function(require,module,exports) {
module.exports = ":host {\n  width: 100%;\n  display: block;\n}\n\n#container {\n  height: 100%;\n  flex-direction: column;\n  display: flex;\n}\n\n#container .title {\n  width: 100%;\n  text-align: left;\n  overflow-anchor: none;\n  background-color: var(--light, #fff);\n  color: var(--dark-text, #212529);\n  cursor: pointer;\n  border: 0;\n  border-radius: 0;\n  align-items: center;\n  padding: 1rem 1.25rem;\n  font-size: 1rem;\n  transition: color .15s;\n  display: flex;\n  position: relative;\n}\n\n#container .title.active {\n  background-color: var(--active, #e7f1ff);\n  color: var(--active-text);\n  box-shadow: inset 0 -1px #00000020;\n}\n\n#container .title.active + .panel {\n  max-height: 100%;\n}\n\n#container .title:hover {\n  background-color: var(--active);\n  color: var(--active-text);\n}\n\n#container .panel {\n  max-height: 0;\n  background-color: --light;\n  border: 1px solid #00000020;\n  padding: 0 18px;\n  transition: max-height .2s ease-out, max-width .2s ease-out;\n  overflow: auto;\n}\n\n#container .panel:first-of-type {\n  border-top-left-radius: .25rem;\n  border-top-right-radius: .25rem;\n}\n\n#container.horizontal {\n  flex-direction: row;\n}\n\n#container.horizontal .title.active + .panel {\n  max-width: 100%;\n}\n\n#container.horizontal .panel {\n  max-width: 0;\n}\n\n";

},{}],"hG10d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChildrenMap", ()=>ChildrenMap);
function ChildrenMap(el, map, ...exclude) {
    let children = Array.prototype.slice.call(el.children);
    if (exclude && exclude.length > 0) return children.filter((el)=>exclude.some((str)=>!el.matches(str))).map(map);
    else return children.map(map);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"847qf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NavigationBase", ()=>NavigationBase);
var _decorators = require("lit/decorators");
var _juelComponent = require("./JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class NavigationBase extends (0, _juelComponent.JuelComponent) {
    firstLoad() {
        if (window.location.hash) this.navigateToSelector(window.location.hash);
    }
    navigateTo(index) {}
    navigateToSelector(selector) {}
}
__decorate([
    (0, _decorators.property)()
], NavigationBase.prototype, "position", void 0);

},{"lit/decorators":"04xNl","./JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bVHZk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelComponent", ()=>JuelComponent);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class JuelComponent extends (0, _lit.LitElement) {
    constructor(){
        super(...arguments);
        this.loaded = false;
    }
    firstUpdated(_changedProperties) {
        setTimeout(()=>{
            this.requestUpdate();
            setTimeout(()=>{
                this.firstLoad();
            });
        });
        super.firstUpdated(_changedProperties);
    }
    firstLoad() {}
    childrenRendered() {}
    updated(_changedProperties) {
        setTimeout(()=>{
            setTimeout(()=>{
                this.load(_changedProperties);
            });
        });
        this.loaded = true;
        super.updated(_changedProperties);
    }
    load(_changedProperties) {}
    get(property) {
        if (property in this) return this[property];
        return null;
    }
    set(property, value) {
        if (property in this) this[property] = value;
    }
}
__decorate([
    (0, _decorators.property)()
], JuelComponent.prototype, "juelParent", void 0);

},{"lit":"l2dGb","lit/decorators":"04xNl","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"l43kz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelCarousel", ()=>JuelCarousel);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _when = require("lit/directives/when");
var _childrenMap = require("../_Utils/ChildrenMap");
var _carouselLess = require("bundle-text:./Carousel.less");
var _carouselLessDefault = parcelHelpers.interopDefault(_carouselLess);
var _navigationBase = require("../_Base/NavigationBase");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelCarousel = class JuelCarousel extends (0, _navigationBase.NavigationBase) {
    constructor(){
        super();
        this.position = 0;
        this.controls = "true";
    }
    navigateTo(index) {
        const currItm = $(this.shadowRoot.querySelector(`[data-index="${index}"]`));
        if (currItm && currItm.length > 0) {
            currItm.siblings(".item").removeClass("active");
            currItm.addClass("active");
            let w = currItm.outerWidth();
            if (w > 0) this.style.setProperty("--item-width", w.toString());
            let h = currItm.outerHeight();
            if (h > 0) this.style.setProperty("--item-height", h.toString());
        }
    }
    navigateToSelector(selector) {
        let el = this.querySelector(selector);
        if (el) {
            let children = $(this).children().not('[slot*="caption"]');
            let index = children.index(el);
            if (index >= 0) {
                this.position = index;
                this.navigateTo(index);
            }
        }
    }
    firstLoad() {
        super.firstLoad();
        if (this.controls.includes(" ")) {
            let splity = this.controls.split(" ");
            this.setInterval(splity[0]);
        } else this.setInterval(this.controls);
        if (this.interval) this.intervalHandler = setInterval(()=>{
            this.next(null);
        }, this.interval);
    }
    setInterval(str) {
        if (str.endsWith("ms")) this.interval = parseInt(str.replace("ms", ""));
        else if (str.endsWith("s")) this.interval = parseInt(str.replace("s", "")) * 1000;
    }
    prev(e) {
        this.isForward = false;
        if (this.position == 0) this.position = this.itemsCount - 1;
        else this.position--;
        this.navigateTo(this.position);
    }
    next(e) {
        this.isForward = true;
        if (e && this.intervalHandler) clearInterval(this.intervalHandler);
        if (this.position == this.itemsCount - 1) this.position = 0;
        else this.position++;
        this.navigateTo(this.position);
    }
    itemClick(e) {
        if (e) e.stopPropagation();
    }
    render() {
        let hasCtrls = this.controls.includes("true");
        this.itemsCount = 0;
        return (0, _lit.html)`${(0, _when.when)(hasCtrls, ()=>(0, _lit.html)`<div id="previous" @click="${this.prev}"><span></span></div>`)}
        <div class="container">
        ${(0, _childrenMap.ChildrenMap)(this, (el, index)=>{
            this.itemsCount++;
            let id = el.id ? el.id : `item-${index}`;
            let klass = "item";
            if (index == this.position) {
                klass += " active";
                let $el = $(el);
                let w = $el.outerWidth();
                if (w > 0) this.style.setProperty("--item-width", w.toString());
                let h = $el.outerHeight();
                if (h > 0) this.style.setProperty("--item-height", h.toString());
            }
            let hasTitleEl = false;
            let titleElId = `${id}-caption`;
            let titleEl = el.nextElementSibling;
            if (titleEl && titleEl.matches('[slot*="caption"]')) {
                hasTitleEl = true;
                titleEl.setAttribute("slot", titleElId);
            }
            el.setAttribute("slot", id);
            el.classList.add("item");
            el.setAttribute("draggable", "false");
            el.setAttribute("ondragstart", "event.preventDefault();");
            return (0, _lit.html)`
                        <div class="${klass}" data-index="${index}" draggable="false" @click="${this.itemClick}">
                        <slot name="${id}"></slot>
                        ${(0, _when.when)(hasTitleEl, ()=>(0, _lit.html)`<div class="caption"><slot name="${titleElId}"</div>`)}
                        ${(0, _when.when)(el.hasAttribute("data-caption"), ()=>(0, _lit.html)`<div class="caption">${el.dataset.caption}</div>`)}
                        </div>`;
        }, '[slot*="caption"]')}
        </div>
        ${(0, _when.when)(hasCtrls, ()=>(0, _lit.html)`<div id="next" @click="${this.next}"><span></span></div>`)}`;
    }
};
JuelCarousel.styles = (0, _lit.unsafeCSS)((0, _carouselLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelCarousel.prototype, "controls", void 0);
JuelCarousel = __decorate([
    (0, _decorators.customElement)("juel-carousel")
], JuelCarousel);

},{"lit":"l2dGb","lit/decorators":"04xNl","lit/directives/when":"dbNPy","../_Utils/ChildrenMap":"hG10d","bundle-text:./Carousel.less":"aTx2h","../_Base/NavigationBase":"847qf","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dbNPy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _whenJs = require("lit-html/directives/when.js");
parcelHelpers.exportAll(_whenJs, exports);

},{"lit-html/directives/when.js":"2lZc0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2lZc0":[function(require,module,exports) {
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "when", ()=>n);
function n(n, o, r) {
    return n ? o() : null == r ? void 0 : r();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aTx2h":[function(require,module,exports) {
module.exports = ":host {\n  display: inline-flex;\n  position: relative;\n}\n\n.item {\n  pointer-events: none;\n  display: none;\n}\n\n.item.active {\n  pointer-events: all;\n  display: block;\n}\n\n.caption {\n  color: #fff;\n  text-align: center;\n  padding-top: 1.25rem;\n  padding-bottom: 1.25rem;\n  position: absolute;\n  bottom: 1.25rem;\n  left: 15%;\n  right: 15%;\n}\n\n::slotted(.carousel-item) {\n  width: 100%;\n  height: 100%;\n}\n\n::slotted(div[slot*=\"caption\"]) {\n  display: inline;\n}\n\n#previous {\n  z-index: 1;\n  width: 10%;\n  text-align: center;\n  opacity: .25;\n  cursor: pointer;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n}\n\n#previous:hover {\n  opacity: .45;\n}\n\n#previous span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-previous);\n  filter: invert();\n}\n\n#next {\n  z-index: 1;\n  width: 10%;\n  text-align: center;\n  opacity: .25;\n  cursor: pointer;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n\n#next:hover {\n  opacity: .45;\n}\n\n#next span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-next);\n  filter: invert();\n}\n\n";

},{}],"jsbjR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelLoading", ()=>JuelLoading);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _loadingLess = require("bundle-text:./Loading.less");
var _loadingLessDefault = parcelHelpers.interopDefault(_loadingLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelLoading = class JuelLoading extends (0, _lit.LitElement) {
    render() {
        let c = "loading";
        if (this.screen == true) c += " fixed";
        if (this.visible == false) c += " hidden";
        return (0, _lit.html)`
        <div class="${c}">
            <div class="circle"></div>
            ${this.src ? (0, _lit.html)`<img src="${this.src}" alt="">` : ``}
        </div>`;
    }
};
JuelLoading.styles = (0, _lit.unsafeCSS)((0, _loadingLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelLoading.prototype, "src", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelLoading.prototype, "visible", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelLoading.prototype, "screen", void 0);
JuelLoading = __decorate([
    (0, _decorators.customElement)("juel-loading")
], JuelLoading);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Loading.less":"j1sqj","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"j1sqj":[function(require,module,exports) {
module.exports = ".fixed {\n  position: fixed;\n  inset: 0;\n}\n\n.loading {\n  width: 100%;\n  height: 100%;\n  z-index: 100;\n  background-color: #f7f7f7;\n  justify-content: center;\n  align-items: center;\n  transition: all .6s;\n  display: flex;\n}\n\n.loading img {\n  height: 80px;\n  z-index: 101;\n  position: absolute;\n}\n\n.loading .circle {\n  width: 100px;\n  height: 100px;\n  background-color: #0061f2;\n  border: 4px solid #0000;\n  border-top-color: gold;\n  border-radius: 50%;\n  transition: all .6s;\n  animation: 2s infinite zoom;\n  position: relative;\n  box-shadow: 4px 1px 5px 2px #19c8ce26;\n}\n\n.hidden {\n  visibility: hidden;\n  opacity: 0;\n  transition: visibility 0s 2s, opacity 2s linear;\n}\n\n@keyframes zoom {\n  0% {\n    -o-transition: .6s;\n    transition: all .6s;\n    transform: rotate(0);\n  }\n\n  100% {\n    -o-transition: .6s;\n    transition: all .6s;\n    transform: rotate(360deg);\n  }\n}\n\n";

},{}],"htWbt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Tooltip", ()=>Tooltip);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _tippyJs = require("tippy.js");
var _tippyJsDefault = parcelHelpers.interopDefault(_tippyJs);
var _tippyCss = require("bundle-text:tippy.js/dist/tippy.css");
var _tippyCssDefault = parcelHelpers.interopDefault(_tippyCss);
var _tooltipLess = require("bundle-text:./Tooltip.less");
var _tooltipLessDefault = parcelHelpers.interopDefault(_tooltipLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Tooltip_1;
let Tooltip = Tooltip_1 = class Tooltip extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.trigger = "mouseenter";
        if (!Tooltip_1.stylesSet) {
            let style = document.createElement("style");
            style.textContent = (0, _lit.unsafeCSS)((0, _tippyCssDefault.default)).cssText;
            document.body.prepend(style);
            Tooltip_1.stylesSet = true;
        }
    }
    firstUpdated() {
        let el = this.shadowRoot.getElementById("tip");
        let contentEl = this.querySelector('[slot="tip"]');
        let content = this.text;
        let interact = false;
        if (contentEl) {
            content = contentEl;
            interact = true;
            this.trigger = "mousedown";
        }
        (0, _tippyJsDefault.default)(el, {
            content: content,
            appendTo: this,
            trigger: this.trigger,
            interactive: interact
        });
    }
    render() {
        return (0, _lit.html)`<div id="tip"><slot></slot>
          </div>`;
    }
};
Tooltip.styles = (0, _lit.unsafeCSS)((0, _tooltipLessDefault.default));
Tooltip.stylesSet = false;
__decorate([
    (0, _decorators.property)()
], Tooltip.prototype, "text", void 0);
__decorate([
    (0, _decorators.property)()
], Tooltip.prototype, "trigger", void 0);
Tooltip = Tooltip_1 = __decorate([
    (0, _decorators.customElement)("juel-tooltip")
], Tooltip);

},{"lit":"l2dGb","lit/decorators":"04xNl","tippy.js":"5lz5R","bundle-text:tippy.js/dist/tippy.css":"l0GIu","bundle-text:./Tooltip.less":"1CyfK","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5lz5R":[function(require,module,exports) {
/**!
* tippy.js v6.3.7
* (c) 2017-2021 atomiks
* MIT License
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "animateFill", ()=>animateFill);
parcelHelpers.export(exports, "createSingleton", ()=>createSingleton);
parcelHelpers.export(exports, "delegate", ()=>delegate);
parcelHelpers.export(exports, "followCursor", ()=>followCursor);
parcelHelpers.export(exports, "hideAll", ()=>hideAll);
parcelHelpers.export(exports, "inlinePositioning", ()=>inlinePositioning);
parcelHelpers.export(exports, "roundArrow", ()=>ROUND_ARROW);
parcelHelpers.export(exports, "sticky", ()=>sticky);
var _core = require("@popperjs/core");
var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
    passive: true,
    capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
    return document.body;
};
function hasOwnProperty(obj, key) {
    return ({}).hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }
    return value;
}
function isType(value, type) {
    var str = ({}).toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) return fn;
    var timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            fn(arg);
        }, ms);
    };
}
function removeProperties(obj, keys) {
    var clone = Object.assign({}, obj);
    keys.forEach(function(key) {
        delete clone[key];
    });
    return clone;
}
function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
    return [].concat(value);
}
function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) arr.push(value);
}
function unique(arr) {
    return arr.filter(function(item, index) {
        return arr.indexOf(item) === index;
    });
}
function getBasePlacement(placement) {
    return placement.split("-")[0];
}
function arrayFrom(value) {
    return [].slice.call(value);
}
function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
        if (obj[key] !== undefined) acc[key] = obj[key];
        return acc;
    }, {});
}
function div() {
    return document.createElement("div");
}
function isElement(value) {
    return [
        "Element",
        "Fragment"
    ].some(function(type) {
        return isType(value, type);
    });
}
function isNodeList(value) {
    return isType(value, "NodeList");
}
function isMouseEvent(value) {
    return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
    if (isElement(value)) return [
        value
    ];
    if (isNodeList(value)) return arrayFrom(value);
    if (Array.isArray(value)) return value;
    return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
    els.forEach(function(el) {
        if (el) el.style.transitionDuration = value + "ms";
    });
}
function setVisibilityState(els, state) {
    els.forEach(function(el) {
        if (el) el.setAttribute("data-state", state);
    });
}
function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
        var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;
        if (!offsetData) return true;
        var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
        var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
}
function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
    // `webkitTransitionEnd`...
    [
        "transitionend",
        "webkitTransitionEnd"
    ].forEach(function(event) {
        box[method](event, listener);
    });
}
/**
 * Compared to xxx.contains, this function works for dom structures with shadow
 * dom
 */ function actualContains(parent, child) {
    var target = child;
    while(target){
        var _target$getRootNode;
        if (parent.contains(target)) return true;
        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
}
var currentInput = {
    isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */ function onDocumentTouchStart() {
    if (currentInput.isTouch) return;
    currentInput.isTouch = true;
    if (window.performance) document.addEventListener("mousemove", onDocumentMouseMove);
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */ function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */ function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;
        if (activeElement.blur && !instance.state.isVisible) activeElement.blur();
    }
}
function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? !!window.msCrypto : false;
function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [
        method + "() was called on a" + txt + "destroyed instance. This is a no-op but",
        "indicates a potential memory leak."
    ].join(" ");
}
function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77‍ This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
    return [
        getDevMessage(message),
        "color: #00C584; font-size: 1.3em; font-weight: bold;",
        "line-height: 1.5",
        "color: #a6a095;"
    ];
} // Assume warnings and errors never have the same message
var visitedMessages;
function resetVisitedMessages() {
    visitedMessages = new Set();
}
function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
        var _console;
        visitedMessages.add(message);
        (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
}
function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
        var _console2;
        visitedMessages.add(message);
        (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
}
function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, [
        "tippy() was passed",
        "`" + String(targets) + "`",
        "as its targets (first) argument. Valid types are: String, Element,",
        "Element[], or NodeList."
    ].join(" "));
    errorWhen(didPassPlainObject, [
        "tippy() was passed a plain object which is not supported as an argument",
        "for virtual positioning. Use props.getReferenceClientRect instead."
    ].join(" "));
}
var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
};
var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
};
var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
        content: "auto",
        expanded: "auto"
    },
    delay: 0,
    duration: [
        300,
        250
    ],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [
        0,
        10
    ],
    onAfterUpdate: function onAfterUpdate() {},
    onBeforeUpdate: function onBeforeUpdate() {},
    onCreate: function onCreate() {},
    onDestroy: function onDestroy() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    onClickOutside: function onClickOutside() {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
        defaultProps[key] = partialProps[key];
    });
};
function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps = plugins.reduce(function(acc, plugin) {
        var name = plugin.name, defaultValue = plugin.defaultValue;
        if (name) {
            var _name;
            acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
        }
        return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
        if (!valueAsString) return acc;
        if (key === "content") acc[key] = valueAsString;
        else try {
            acc[key] = JSON.parse(valueAsString);
        } catch (e) {
            acc[key] = valueAsString;
        }
        return acc;
    }, {});
    return props;
}
function evaluateProps(reference, props) {
    var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [
            reference
        ])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
        expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
        content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
}
function validateProps(partialProps, plugins) {
    if (partialProps === void 0) partialProps = {};
    if (plugins === void 0) plugins = [];
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`
        if (didPassUnknownProp) didPassUnknownProp = plugins.filter(function(plugin) {
            return plugin.name === prop;
        }).length === 0;
        warnWhen(didPassUnknownProp, [
            "`" + prop + "`",
            "is not a valid prop. You may have spelled it incorrectly, or if it's",
            "a plugin, forgot to pass it in an array as props.plugins.",
            "\n\n",
            "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n",
            "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"
        ].join(" "));
    });
}
var innerHTML = function innerHTML() {
    return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
}
function createArrowElement(value) {
    var arrow = div();
    if (value === true) arrow.className = ARROW_CLASS;
    else {
        arrow.className = SVG_ARROW_CLASS;
        if (isElement(value)) arrow.appendChild(value);
        else dangerouslySetInnerHTML(arrow, value);
    }
    return arrow;
}
function setContent(content, props) {
    if (isElement(props.content)) {
        dangerouslySetInnerHTML(content, "");
        content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
        if (props.allowHTML) dangerouslySetInnerHTML(content, props.content);
        else content.textContent = props.content;
    }
}
function getChildren(popper) {
    var box = popper.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
        box: box,
        content: boxChildren.find(function(node) {
            return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function(node) {
            return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function(node) {
            return node.classList.contains(BACKDROP_CLASS);
        })
    };
}
function render(instance) {
    var popper = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper), box = _getChildren.box, content = _getChildren.content, arrow = _getChildren.arrow;
        if (nextProps.theme) box.setAttribute("data-theme", nextProps.theme);
        else box.removeAttribute("data-theme");
        if (typeof nextProps.animation === "string") box.setAttribute("data-animation", nextProps.animation);
        else box.removeAttribute("data-animation");
        if (nextProps.inertia) box.setAttribute("data-inertia", "");
        else box.removeAttribute("data-inertia");
        box.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
        if (nextProps.role) box.setAttribute("role", nextProps.role);
        else box.removeAttribute("role");
        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) setContent(content, instance.props);
        if (nextProps.arrow) {
            if (!arrow) box.appendChild(createArrowElement(nextProps.arrow));
            else if (prevProps.arrow !== nextProps.arrow) {
                box.removeChild(arrow);
                box.appendChild(createArrowElement(nextProps.arrow));
            }
        } else if (arrow) box.removeChild(arrow);
    }
    return {
        popper: popper,
        onUpdate: onUpdate
    };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`
var mountedInstances = [];
function createTippy(reference, passedProps) {
    var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
    // 🔒 Private members
    // ===========================================================================
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
    var currentTarget; // ===========================================================================
    // 🔑 Public members
    // ===========================================================================
    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
    };
    var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
    }; // TODO: Investigate why this early return causes a TDZ error in the tests —
    // it doesn't seem to happen in the browser
    /* istanbul ignore if */ if (!props.render) return instance;
     // ===========================================================================
    // Initial mutations
    // ===========================================================================
    var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper.setAttribute("data-tippy-root", "");
    popper.id = "tippy-" + instance.id;
    instance.popper = popper;
    reference._tippy = instance;
    popper._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin) {
        return plugin.fn(instance);
    });
    var hasAriaExpanded = reference.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [
        instance
    ]);
    if (props.showOnCreate) scheduleShow();
     // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding
    popper.addEventListener("mouseenter", function() {
        if (instance.props.interactive && instance.state.isVisible) instance.clearDelayTimeouts();
    });
    popper.addEventListener("mouseleave", function() {
        if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    });
    return instance; // ===========================================================================
    // 🔒 Private methods
    // ===========================================================================
    function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [
            touch,
            0
        ];
    }
    function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
        var _instance$props$rende;
        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
        return currentTarget || reference;
    }
    function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
        return getChildren(popper);
    }
    function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") return 0;
        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
        if (fromHide === void 0) fromHide = false;
        popper.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
        popper.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) shouldInvokePropsHook = true;
        pluginsHooks.forEach(function(pluginHooks) {
            if (pluginHooks[hook]) pluginHooks[hook].apply(pluginHooks, args);
        });
        if (shouldInvokePropsHook) {
            var _instance$props;
            (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
    }
    function handleAriaContentAttribute() {
        var aria = instance.props.aria;
        if (!aria.content) return;
        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function(node) {
            var currentValue = node.getAttribute(attr);
            if (instance.state.isVisible) node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
            else {
                var nextValue = currentValue && currentValue.replace(id, "").trim();
                if (nextValue) node.setAttribute(attr, nextValue);
                else node.removeAttribute(attr);
            }
        });
    }
    function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) return;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function(node) {
            if (instance.props.interactive) node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
            else node.removeAttribute("aria-expanded");
        });
    }
    function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
            return listener !== debouncedOnMouseMove;
        });
    }
    function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
            if (didTouchMove || event.type === "mousedown") return;
        }
        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper
        if (instance.props.interactive && actualContains(popper, actualTarget)) return;
         // Clicked on the event listeners target
        if (normalizeToArray(instance.props.triggerTarget || reference).some(function(el) {
            return actualContains(el, actualTarget);
        })) {
            if (currentInput.isTouch) return;
            if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) return;
        } else invokeHook("onClickOutside", [
            instance,
            event
        ]);
        if (instance.props.hideOnClick === true) {
            instance.clearDelayTimeouts();
            instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
            // currentTarget. This lets a tippy with `focus` trigger know that it
            // should not show
            didHideDueToDocumentMouseDown = true;
            setTimeout(function() {
                didHideDueToDocumentMouseDown = false;
            }); // The listener gets added in `scheduleShow()`, but this may be hiding it
            // before it shows, and hide()'s early bail-out behavior can prevent it
            // from being cleaned up
            if (!instance.state.isMounted) removeDocumentPress();
        }
    }
    function onTouchMove() {
        didTouchMove = true;
    }
    function onTouchStart() {
        didTouchMove = false;
    }
    function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener("mousedown", onDocumentPress, true);
        doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener("mousedown", onDocumentPress, true);
        doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function() {
            if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) callback();
        });
    }
    function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;
        function listener(event) {
            if (event.target === box) {
                updateTransitionEndListener(box, "remove", listener);
                callback();
            }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise
        if (duration === 0) return callback();
        updateTransitionEndListener(box, "remove", currentTransitionEndListener);
        updateTransitionEndListener(box, "add", listener);
        currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
        if (options === void 0) options = false;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function(node) {
            node.addEventListener(eventType, handler, options);
            listeners.push({
                node: node,
                eventType: eventType,
                handler: handler,
                options: options
            });
        });
    }
    function addListeners() {
        if (getIsCustomTouchBehavior()) {
            on("touchstart", onTrigger, {
                passive: true
            });
            on("touchend", onMouseLeave, {
                passive: true
            });
        }
        splitBySpaces(instance.props.trigger).forEach(function(eventType) {
            if (eventType === "manual") return;
            on(eventType, onTrigger);
            switch(eventType){
                case "mouseenter":
                    on("mouseleave", onMouseLeave);
                    break;
                case "focus":
                    on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
                    break;
                case "focusin":
                    on("focusout", onBlurOrFocusOut);
                    break;
            }
        });
    }
    function removeListeners() {
        listeners.forEach(function(_ref) {
            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
            node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
    }
    function onTrigger(event) {
        var _lastTriggerEvent;
        var shouldScheduleClickHide = false;
        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) return;
        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();
        if (!instance.state.isVisible && isMouseEvent(event)) // If scrolling, `mouseenter` events can be fired if the cursor lands
        // over a new target, but `mousemove` events don't get fired. This
        // causes interactive tooltips to get stuck open until the cursor is
        // moved
        mouseMoveListeners.forEach(function(listener) {
            return listener(event);
        });
         // Toggle show/hide when clicking click-triggered tooltips
        if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) shouldScheduleClickHide = true;
        else scheduleShow(event);
        if (event.type === "click") isVisibleFromClick = !shouldScheduleClickHide;
        if (shouldScheduleClickHide && !wasFocused) scheduleHide(event);
    }
    function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
        if (event.type === "mousemove" && isCursorOverReferenceOrPopper) return;
        var popperTreeData = getNestedPopperTree().concat(popper).map(function(popper) {
            var _instance$popperInsta;
            var instance = popper._tippy;
            var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
            if (state) return {
                popperRect: popper.getBoundingClientRect(),
                popperState: state,
                props: props
            };
            return null;
        }).filter(Boolean);
        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
            cleanupInteractiveMouseListeners();
            scheduleHide(event);
        }
    }
    function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
        if (shouldBail) return;
        if (instance.props.interactive) {
            instance.hideWithInteractivity(event);
            return;
        }
        scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) return;
         // If focus was moved to within the popper
        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) return;
        scheduleHide(event);
    }
    function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
            getBoundingClientRect: getReferenceClientRect,
            contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
            name: "$$tippy",
            enabled: true,
            phase: "beforeWrite",
            requires: [
                "computeStyles"
            ],
            fn: function fn(_ref2) {
                var state = _ref2.state;
                if (getIsDefaultRenderFn()) {
                    var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
                    [
                        "placement",
                        "reference-hidden",
                        "escaped"
                    ].forEach(function(attr) {
                        if (attr === "placement") box.setAttribute("data-placement", state.placement);
                        else if (state.attributes.popper["data-popper-" + attr]) box.setAttribute("data-" + attr, "");
                        else box.removeAttribute("data-" + attr);
                    });
                    state.attributes.popper = {};
                }
            }
        };
        var modifiers = [
            {
                name: "offset",
                options: {
                    offset: offset
                }
            },
            {
                name: "preventOverflow",
                options: {
                    padding: {
                        top: 2,
                        bottom: 2,
                        left: 5,
                        right: 5
                    }
                }
            },
            {
                name: "flip",
                options: {
                    padding: 5
                }
            },
            {
                name: "computeStyles",
                options: {
                    adaptive: !moveTransition
                }
            },
            tippyModifier
        ];
        if (getIsDefaultRenderFn() && arrow) modifiers.push({
            name: "arrow",
            options: {
                element: arrow,
                padding: 3
            }
        });
        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = (0, _core.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {
            placement: placement,
            onFirstUpdate: onFirstUpdate,
            modifiers: modifiers
        }));
    }
    function destroyPopperInstance() {
        if (instance.popperInstance) {
            instance.popperInstance.destroy();
            instance.popperInstance = null;
        }
    }
    function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually
        var node = getCurrentTarget();
        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") parentNode = node.parentNode;
        else parentNode = invokeWithArgsOrReturn(appendTo, [
            node
        ]);
         // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions
        if (!parentNode.contains(popper)) parentNode.appendChild(popper);
        instance.state.isMounted = true;
        createPopperInstance();
    }
    function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
        instance.clearDelayTimeouts();
        if (event) invokeHook("onTrigger", [
            instance,
            event
        ]);
        addDocumentPress();
        var delay = getDelay(true);
        var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
        if (currentInput.isTouch && touchValue === "hold" && touchDelay) delay = touchDelay;
        if (delay) showTimeout = setTimeout(function() {
            instance.show();
        }, delay);
        else instance.show();
    }
    function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook("onUntrigger", [
            instance,
            event
        ]);
        if (!instance.state.isVisible) {
            removeDocumentPress();
            return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.
        if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && [
            "mouseleave",
            "mousemove"
        ].indexOf(event.type) >= 0 && isVisibleFromClick) return;
        var delay = getDelay(false);
        if (delay) hideTimeout = setTimeout(function() {
            if (instance.state.isVisible) instance.hide();
        }, delay);
        else // Fixes a `transitionend` problem when it fires 1 frame too
        // late sometimes, we don't want hide() to be called.
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
            instance.hide();
        });
    } // ===========================================================================
    // 🔑 Public methods
    // ===========================================================================
    function enable() {
        instance.state.isEnabled = true;
    }
    function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
        if (instance.state.isDestroyed) return;
        invokeHook("onBeforeUpdate", [
            instance,
            partialProps
        ]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
            ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();
        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
            cleanupInteractiveMouseListeners();
            debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed
        if (prevProps.triggerTarget && !nextProps.triggerTarget) normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
            node.removeAttribute("aria-expanded");
        });
        else if (nextProps.triggerTarget) reference.removeAttribute("aria-expanded");
        handleAriaExpandedAttribute();
        handleStyles();
        if (onUpdate) onUpdate(prevProps, nextProps);
        if (instance.popperInstance) {
            createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
            // and the nested ones get re-rendered first.
            // https://github.com/atomiks/tippyjs-react/issues/177
            // TODO: find a cleaner / more efficient solution(!)
            getNestedPopperTree().forEach(function(nestedPopper) {
                // React (and other UI libs likely) requires a rAF wrapper as it flushes
                // its work in one
                requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
            });
        }
        invokeHook("onAfterUpdate", [
            instance,
            partialProps
        ]);
    }
    function setContent(content) {
        instance.setProps({
            content: content
        });
    }
    function show() {
        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) return;
         // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.
        if (getCurrentTarget().hasAttribute("disabled")) return;
        invokeHook("onShow", [
            instance
        ], false);
        if (instance.props.onShow(instance) === false) return;
        instance.state.isVisible = true;
        if (getIsDefaultRenderFn()) popper.style.visibility = "visible";
        handleStyles();
        addDocumentPress();
        if (!instance.state.isMounted) popper.style.transition = "none";
         // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration
        if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
            setTransitionDuration([
                box,
                content
            ], 0);
        }
        onFirstUpdate = function onFirstUpdate() {
            var _instance$popperInsta2;
            if (!instance.state.isVisible || ignoreOnFirstUpdate) return;
            ignoreOnFirstUpdate = true; // reflow
            popper.offsetHeight;
            popper.style.transition = instance.props.moveTransition;
            if (getIsDefaultRenderFn() && instance.props.animation) {
                var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
                setTransitionDuration([
                    _box,
                    _content
                ], duration);
                setVisibilityState([
                    _box,
                    _content
                ], "visible");
            }
            handleAriaContentAttribute();
            handleAriaExpandedAttribute();
            pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
            // popper has been positioned for the first time
            (_instance$popperInsta2 = instance.popperInstance) == null || _instance$popperInsta2.forceUpdate();
            invokeHook("onMount", [
                instance
            ]);
            if (instance.props.animation && getIsDefaultRenderFn()) onTransitionedIn(duration, function() {
                instance.state.isShown = true;
                invokeHook("onShown", [
                    instance
                ]);
            });
        };
        mount();
    }
    function hide() {
        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
        if (isAlreadyHidden || isDestroyed || isDisabled) return;
        invokeHook("onHide", [
            instance
        ], false);
        if (instance.props.onHide(instance) === false) return;
        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;
        if (getIsDefaultRenderFn()) popper.style.visibility = "hidden";
        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles(true);
        if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
            if (instance.props.animation) {
                setTransitionDuration([
                    box,
                    content
                ], duration);
                setVisibilityState([
                    box,
                    content
                ], "hidden");
            }
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        if (instance.props.animation) {
            if (getIsDefaultRenderFn()) onTransitionedOut(duration, instance.unmount);
        } else instance.unmount();
    }
    function hideWithInteractivity(event) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
    }
    function unmount() {
        if (instance.state.isVisible) instance.hide();
        if (!instance.state.isMounted) return;
        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible
        getNestedPopperTree().forEach(function(nestedPopper) {
            nestedPopper._tippy.unmount();
        });
        if (popper.parentNode) popper.parentNode.removeChild(popper);
        mountedInstances = mountedInstances.filter(function(i) {
            return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook("onHidden", [
            instance
        ]);
    }
    function destroy() {
        if (instance.state.isDestroyed) return;
        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook("onDestroy", [
            instance
        ]);
    }
}
function tippy(targets, optionalProps) {
    if (optionalProps === void 0) optionalProps = {};
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
    });
    var elements = getArrayOfElements(targets);
    var isSingleContentElement, isMoreThanOneReferenceElement;
    var instances = elements.reduce(function(acc, reference) {
        var instance = reference && createTippy(reference, passedProps);
        if (instance) acc.push(instance);
        return acc;
    }, []);
    return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = function hideAll(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, excludedReferenceOrInstance = _ref.exclude, duration = _ref.duration;
    mountedInstances.forEach(function(instance) {
        var isExcluded = false;
        if (excludedReferenceOrInstance) isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
        if (!isExcluded) {
            var originalDuration = instance.props.duration;
            instance.setProps({
                duration: duration
            });
            instance.hide();
            if (!instance.state.isDestroyed) instance.setProps({
                duration: originalDuration
            });
        }
    });
};
// every time the popper is destroyed (i.e. a new target), removing the styles
// and causing transitions to break for singletons when the console is open, but
// most notably for non-transform styles being used, `gpuAcceleration: false`.
var applyStylesModifier = Object.assign({}, (0, _core.applyStyles), {
    effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
            popper: {
                position: state.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;
        if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
         // intentionally return no cleanup function
    // return () => { ... }
    }
});
var createSingleton = function createSingleton(tippyInstances, optionalProps) {
    var _optionalProps$popper;
    if (optionalProps === void 0) optionalProps = {};
    var individualInstances = tippyInstances;
    var references = [];
    var triggerTargets = [];
    var currentTarget;
    var overrides = optionalProps.overrides;
    var interceptSetPropsCleanups = [];
    var shownOnCreate = false;
    function setTriggerTargets() {
        triggerTargets = individualInstances.map(function(instance) {
            return normalizeToArray(instance.props.triggerTarget || instance.reference);
        }).reduce(function(acc, item) {
            return acc.concat(item);
        }, []);
    }
    function setReferences() {
        references = individualInstances.map(function(instance) {
            return instance.reference;
        });
    }
    function enableInstances(isEnabled) {
        individualInstances.forEach(function(instance) {
            if (isEnabled) instance.enable();
            else instance.disable();
        });
    }
    function interceptSetProps(singleton) {
        return individualInstances.map(function(instance) {
            var originalSetProps = instance.setProps;
            instance.setProps = function(props) {
                originalSetProps(props);
                if (instance.reference === currentTarget) singleton.setProps(props);
            };
            return function() {
                instance.setProps = originalSetProps;
            };
        });
    } // have to pass singleton, as it maybe undefined on first call
    function prepareInstance(singleton, target) {
        var index = triggerTargets.indexOf(target); // bail-out
        if (target === currentTarget) return;
        currentTarget = target;
        var overrideProps = (overrides || []).concat("content").reduce(function(acc, prop) {
            acc[prop] = individualInstances[index].props[prop];
            return acc;
        }, {});
        singleton.setProps(Object.assign({}, overrideProps, {
            getReferenceClientRect: typeof overrideProps.getReferenceClientRect === "function" ? overrideProps.getReferenceClientRect : function() {
                var _references$index;
                return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();
            }
        }));
    }
    enableInstances(false);
    setReferences();
    setTriggerTargets();
    var plugin = {
        fn: function fn() {
            return {
                onDestroy: function onDestroy() {
                    enableInstances(true);
                },
                onHidden: function onHidden() {
                    currentTarget = null;
                },
                onClickOutside: function onClickOutside(instance) {
                    if (instance.props.showOnCreate && !shownOnCreate) {
                        shownOnCreate = true;
                        currentTarget = null;
                    }
                },
                onShow: function onShow(instance) {
                    if (instance.props.showOnCreate && !shownOnCreate) {
                        shownOnCreate = true;
                        prepareInstance(instance, references[0]);
                    }
                },
                onTrigger: function onTrigger(instance, event) {
                    prepareInstance(instance, event.currentTarget);
                }
            };
        }
    };
    var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, [
        "overrides"
    ]), {
        plugins: [
            plugin
        ].concat(optionalProps.plugins || []),
        triggerTarget: triggerTargets,
        popperOptions: Object.assign({}, optionalProps.popperOptions, {
            modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [
                applyStylesModifier
            ])
        })
    }));
    var originalShow = singleton.show;
    singleton.show = function(target) {
        originalShow(); // first time, showOnCreate or programmatic call with no params
        // default to showing first instance
        if (!currentTarget && target == null) return prepareInstance(singleton, references[0]);
         // triggered from event (do nothing as prepareInstance already called by onTrigger)
        // programmatic call with no params when already visible (do nothing again)
        if (currentTarget && target == null) return;
         // target is index of instance
        if (typeof target === "number") return references[target] && prepareInstance(singleton, references[target]);
         // target is a child tippy instance
        if (individualInstances.indexOf(target) >= 0) {
            var ref = target.reference;
            return prepareInstance(singleton, ref);
        } // target is a ReferenceElement
        if (references.indexOf(target) >= 0) return prepareInstance(singleton, target);
    };
    singleton.showNext = function() {
        var first = references[0];
        if (!currentTarget) return singleton.show(0);
        var index = references.indexOf(currentTarget);
        singleton.show(references[index + 1] || first);
    };
    singleton.showPrevious = function() {
        var last = references[references.length - 1];
        if (!currentTarget) return singleton.show(last);
        var index = references.indexOf(currentTarget);
        var target = references[index - 1] || last;
        singleton.show(target);
    };
    var originalSetProps = singleton.setProps;
    singleton.setProps = function(props) {
        overrides = props.overrides || overrides;
        originalSetProps(props);
    };
    singleton.setInstances = function(nextInstances) {
        enableInstances(true);
        interceptSetPropsCleanups.forEach(function(fn) {
            return fn();
        });
        individualInstances = nextInstances;
        enableInstances(false);
        setReferences();
        setTriggerTargets();
        interceptSetPropsCleanups = interceptSetProps(singleton);
        singleton.setProps({
            triggerTarget: triggerTargets
        });
    };
    interceptSetPropsCleanups = interceptSetProps(singleton);
    return singleton;
};
var BUBBLING_EVENTS_MAP = {
    mouseover: "mouseenter",
    focusin: "focus",
    click: "click"
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */ function delegate(targets, props) {
    var listeners = [];
    var childTippyInstances = [];
    var disabled = false;
    var target = props.target;
    var nativeProps = removeProperties(props, [
        "target"
    ]);
    var parentProps = Object.assign({}, nativeProps, {
        trigger: "manual",
        touch: false
    });
    var childProps = Object.assign({
        touch: defaultProps.touch
    }, nativeProps, {
        showOnCreate: true
    });
    var returnValue = tippy(targets, parentProps);
    var normalizedReturnValue = normalizeToArray(returnValue);
    function onTrigger(event) {
        if (!event.target || disabled) return;
        var targetNode = event.target.closest(target);
        if (!targetNode) return;
         // Get relevant trigger with fallbacks:
        // 1. Check `data-tippy-trigger` attribute on target node
        // 2. Fallback to `trigger` passed to `delegate()`
        // 3. Fallback to `defaultProps.trigger`
        var trigger = targetNode.getAttribute("data-tippy-trigger") || props.trigger || defaultProps.trigger; // @ts-ignore
        if (targetNode._tippy) return;
        if (event.type === "touchstart" && typeof childProps.touch === "boolean") return;
        if (event.type !== "touchstart" && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) return;
        var instance = tippy(targetNode, childProps);
        if (instance) childTippyInstances = childTippyInstances.concat(instance);
    }
    function on(node, eventType, handler, options) {
        if (options === void 0) options = false;
        node.addEventListener(eventType, handler, options);
        listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
        });
    }
    function addEventListeners(instance) {
        var reference = instance.reference;
        on(reference, "touchstart", onTrigger, TOUCH_OPTIONS);
        on(reference, "mouseover", onTrigger);
        on(reference, "focusin", onTrigger);
        on(reference, "click", onTrigger);
    }
    function removeEventListeners() {
        listeners.forEach(function(_ref) {
            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
            node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
    }
    function applyMutations(instance) {
        var originalDestroy = instance.destroy;
        var originalEnable = instance.enable;
        var originalDisable = instance.disable;
        instance.destroy = function(shouldDestroyChildInstances) {
            if (shouldDestroyChildInstances === void 0) shouldDestroyChildInstances = true;
            if (shouldDestroyChildInstances) childTippyInstances.forEach(function(instance) {
                instance.destroy();
            });
            childTippyInstances = [];
            removeEventListeners();
            originalDestroy();
        };
        instance.enable = function() {
            originalEnable();
            childTippyInstances.forEach(function(instance) {
                return instance.enable();
            });
            disabled = false;
        };
        instance.disable = function() {
            originalDisable();
            childTippyInstances.forEach(function(instance) {
                return instance.disable();
            });
            disabled = true;
        };
        addEventListeners(instance);
    }
    normalizedReturnValue.forEach(applyMutations);
    return returnValue;
}
var animateFill = {
    name: "animateFill",
    defaultValue: false,
    fn: function fn(instance) {
        var _instance$props$rende;
        // @ts-ignore
        if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) return {};
        var _getChildren = getChildren(instance.popper), box = _getChildren.box, content = _getChildren.content;
        var backdrop = instance.props.animateFill ? createBackdropElement() : null;
        return {
            onCreate: function onCreate() {
                if (backdrop) {
                    box.insertBefore(backdrop, box.firstElementChild);
                    box.setAttribute("data-animatefill", "");
                    box.style.overflow = "hidden";
                    instance.setProps({
                        arrow: false,
                        animation: "shift-away"
                    });
                }
            },
            onMount: function onMount() {
                if (backdrop) {
                    var transitionDuration = box.style.transitionDuration;
                    var duration = Number(transitionDuration.replace("ms", "")); // The content should fade in after the backdrop has mostly filled the
                    // tooltip element. `clip-path` is the other alternative but is not
                    // well-supported and is buggy on some devices.
                    content.style.transitionDelay = Math.round(duration / 10) + "ms";
                    backdrop.style.transitionDuration = transitionDuration;
                    setVisibilityState([
                        backdrop
                    ], "visible");
                }
            },
            onShow: function onShow() {
                if (backdrop) backdrop.style.transitionDuration = "0ms";
            },
            onHide: function onHide() {
                if (backdrop) setVisibilityState([
                    backdrop
                ], "hidden");
            }
        };
    }
};
function createBackdropElement() {
    var backdrop = div();
    backdrop.className = BACKDROP_CLASS;
    setVisibilityState([
        backdrop
    ], "hidden");
    return backdrop;
}
var mouseCoords = {
    clientX: 0,
    clientY: 0
};
var activeInstances = [];
function storeMouseCoords(_ref) {
    var clientX = _ref.clientX, clientY = _ref.clientY;
    mouseCoords = {
        clientX: clientX,
        clientY: clientY
    };
}
function addMouseCoordsListener(doc) {
    doc.addEventListener("mousemove", storeMouseCoords);
}
function removeMouseCoordsListener(doc) {
    doc.removeEventListener("mousemove", storeMouseCoords);
}
var followCursor = {
    name: "followCursor",
    defaultValue: false,
    fn: function fn(instance) {
        var reference = instance.reference;
        var doc = getOwnerDocument(instance.props.triggerTarget || reference);
        var isInternalUpdate = false;
        var wasFocusEvent = false;
        var isUnmounted = true;
        var prevProps = instance.props;
        function getIsInitialBehavior() {
            return instance.props.followCursor === "initial" && instance.state.isVisible;
        }
        function addListener() {
            doc.addEventListener("mousemove", onMouseMove);
        }
        function removeListener() {
            doc.removeEventListener("mousemove", onMouseMove);
        }
        function unsetGetReferenceClientRect() {
            isInternalUpdate = true;
            instance.setProps({
                getReferenceClientRect: null
            });
            isInternalUpdate = false;
        }
        function onMouseMove(event) {
            // If the instance is interactive, avoid updating the position unless it's
            // over the reference element
            var isCursorOverReference = event.target ? reference.contains(event.target) : true;
            var followCursor = instance.props.followCursor;
            var clientX = event.clientX, clientY = event.clientY;
            var rect = reference.getBoundingClientRect();
            var relativeX = clientX - rect.left;
            var relativeY = clientY - rect.top;
            if (isCursorOverReference || !instance.props.interactive) instance.setProps({
                // @ts-ignore - unneeded DOMRect properties
                getReferenceClientRect: function getReferenceClientRect() {
                    var rect = reference.getBoundingClientRect();
                    var x = clientX;
                    var y = clientY;
                    if (followCursor === "initial") {
                        x = rect.left + relativeX;
                        y = rect.top + relativeY;
                    }
                    var top = followCursor === "horizontal" ? rect.top : y;
                    var right = followCursor === "vertical" ? rect.right : x;
                    var bottom = followCursor === "horizontal" ? rect.bottom : y;
                    var left = followCursor === "vertical" ? rect.left : x;
                    return {
                        width: right - left,
                        height: bottom - top,
                        top: top,
                        right: right,
                        bottom: bottom,
                        left: left
                    };
                }
            });
        }
        function create() {
            if (instance.props.followCursor) {
                activeInstances.push({
                    instance: instance,
                    doc: doc
                });
                addMouseCoordsListener(doc);
            }
        }
        function destroy() {
            activeInstances = activeInstances.filter(function(data) {
                return data.instance !== instance;
            });
            if (activeInstances.filter(function(data) {
                return data.doc === doc;
            }).length === 0) removeMouseCoordsListener(doc);
        }
        return {
            onCreate: create,
            onDestroy: destroy,
            onBeforeUpdate: function onBeforeUpdate() {
                prevProps = instance.props;
            },
            onAfterUpdate: function onAfterUpdate(_, _ref2) {
                var followCursor = _ref2.followCursor;
                if (isInternalUpdate) return;
                if (followCursor !== undefined && prevProps.followCursor !== followCursor) {
                    destroy();
                    if (followCursor) {
                        create();
                        if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) addListener();
                    } else {
                        removeListener();
                        unsetGetReferenceClientRect();
                    }
                }
            },
            onMount: function onMount() {
                if (instance.props.followCursor && !wasFocusEvent) {
                    if (isUnmounted) {
                        onMouseMove(mouseCoords);
                        isUnmounted = false;
                    }
                    if (!getIsInitialBehavior()) addListener();
                }
            },
            onTrigger: function onTrigger(_, event) {
                if (isMouseEvent(event)) mouseCoords = {
                    clientX: event.clientX,
                    clientY: event.clientY
                };
                wasFocusEvent = event.type === "focus";
            },
            onHidden: function onHidden() {
                if (instance.props.followCursor) {
                    unsetGetReferenceClientRect();
                    removeListener();
                    isUnmounted = true;
                }
            }
        };
    }
};
function getProps(props, modifier) {
    var _props$popperOptions;
    return {
        popperOptions: Object.assign({}, props.popperOptions, {
            modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function(_ref) {
                var name = _ref.name;
                return name !== modifier.name;
            }), [
                modifier
            ])
        })
    };
}
var inlinePositioning = {
    name: "inlinePositioning",
    defaultValue: false,
    fn: function fn(instance) {
        var reference = instance.reference;
        function isEnabled() {
            return !!instance.props.inlinePositioning;
        }
        var placement;
        var cursorRectIndex = -1;
        var isInternalUpdate = false;
        var triedPlacements = [];
        var modifier = {
            name: "tippyInlinePositioning",
            enabled: true,
            phase: "afterWrite",
            fn: function fn(_ref2) {
                var state = _ref2.state;
                if (isEnabled()) {
                    if (triedPlacements.indexOf(state.placement) !== -1) triedPlacements = [];
                    if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {
                        triedPlacements.push(state.placement);
                        instance.setProps({
                            // @ts-ignore - unneeded DOMRect properties
                            getReferenceClientRect: function getReferenceClientRect() {
                                return _getReferenceClientRect(state.placement);
                            }
                        });
                    }
                    placement = state.placement;
                }
            }
        };
        function _getReferenceClientRect(placement) {
            return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
        }
        function setInternalProps(partialProps) {
            isInternalUpdate = true;
            instance.setProps(partialProps);
            isInternalUpdate = false;
        }
        function addModifier() {
            if (!isInternalUpdate) setInternalProps(getProps(instance.props, modifier));
        }
        return {
            onCreate: addModifier,
            onAfterUpdate: addModifier,
            onTrigger: function onTrigger(_, event) {
                if (isMouseEvent(event)) {
                    var rects = arrayFrom(instance.reference.getClientRects());
                    var cursorRect = rects.find(function(rect) {
                        return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
                    });
                    var index = rects.indexOf(cursorRect);
                    cursorRectIndex = index > -1 ? index : cursorRectIndex;
                }
            },
            onHidden: function onHidden() {
                cursorRectIndex = -1;
            }
        };
    }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
    // Not an inline element, or placement is not yet known
    if (clientRects.length < 2 || currentBasePlacement === null) return boundingRect;
     // There are two rects and they are disjoined
    if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) return clientRects[cursorRectIndex] || boundingRect;
    switch(currentBasePlacement){
        case "top":
        case "bottom":
            var firstRect = clientRects[0];
            var lastRect = clientRects[clientRects.length - 1];
            var isTop = currentBasePlacement === "top";
            var top = firstRect.top;
            var bottom = lastRect.bottom;
            var left = isTop ? firstRect.left : lastRect.left;
            var right = isTop ? firstRect.right : lastRect.right;
            var width = right - left;
            var height = bottom - top;
            return {
                top: top,
                bottom: bottom,
                left: left,
                right: right,
                width: width,
                height: height
            };
        case "left":
        case "right":
            var minLeft = Math.min.apply(Math, clientRects.map(function(rects) {
                return rects.left;
            }));
            var maxRight = Math.max.apply(Math, clientRects.map(function(rects) {
                return rects.right;
            }));
            var measureRects = clientRects.filter(function(rect) {
                return currentBasePlacement === "left" ? rect.left === minLeft : rect.right === maxRight;
            });
            var _top = measureRects[0].top;
            var _bottom = measureRects[measureRects.length - 1].bottom;
            var _left = minLeft;
            var _right = maxRight;
            var _width = _right - _left;
            var _height = _bottom - _top;
            return {
                top: _top,
                bottom: _bottom,
                left: _left,
                right: _right,
                width: _width,
                height: _height
            };
        default:
            return boundingRect;
    }
}
var sticky = {
    name: "sticky",
    defaultValue: false,
    fn: function fn(instance) {
        var reference = instance.reference, popper = instance.popper;
        function getReference() {
            return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
        }
        function shouldCheck(value) {
            return instance.props.sticky === true || instance.props.sticky === value;
        }
        var prevRefRect = null;
        var prevPopRect = null;
        function updatePosition() {
            var currentRefRect = shouldCheck("reference") ? getReference().getBoundingClientRect() : null;
            var currentPopRect = shouldCheck("popper") ? popper.getBoundingClientRect() : null;
            if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
                if (instance.popperInstance) instance.popperInstance.update();
            }
            prevRefRect = currentRefRect;
            prevPopRect = currentPopRect;
            if (instance.state.isMounted) requestAnimationFrame(updatePosition);
        }
        return {
            onMount: function onMount() {
                if (instance.props.sticky) updatePosition();
            }
        };
    }
};
function areRectsDifferent(rectA, rectB) {
    if (rectA && rectB) return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
    return true;
}
tippy.setDefaultProps({
    render: render
});
exports.default = tippy;

},{"@popperjs/core":"a0hlq","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"a0hlq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
parcelHelpers.export(exports, "createPopperBase", ()=>(0, _createPopperJs.createPopper));
parcelHelpers.export(exports, "createPopper", ()=>(0, _popperJs.createPopper)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopperLite", ()=>(0, _popperLiteJs.createPopper));
var _enumsJs = require("./enums.js");
parcelHelpers.exportAll(_enumsJs, exports);
var _indexJs = require("./modifiers/index.js"); // eslint-disable-next-line import/no-unused-modules
parcelHelpers.exportAll(_indexJs, exports);
var _createPopperJs = require("./createPopper.js");
var _popperJs = require("./popper.js");
var _popperLiteJs = require("./popper-lite.js");

},{"./enums.js":"6tt9g","./modifiers/index.js":"4qeAD","./createPopper.js":"7Xj0L","./popper.js":"hNdY0","./popper-lite.js":"7fTeN","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6tt9g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "top", ()=>top);
parcelHelpers.export(exports, "bottom", ()=>bottom);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "auto", ()=>auto);
parcelHelpers.export(exports, "basePlacements", ()=>basePlacements);
parcelHelpers.export(exports, "start", ()=>start);
parcelHelpers.export(exports, "end", ()=>end);
parcelHelpers.export(exports, "clippingParents", ()=>clippingParents);
parcelHelpers.export(exports, "viewport", ()=>viewport);
parcelHelpers.export(exports, "popper", ()=>popper);
parcelHelpers.export(exports, "reference", ()=>reference);
parcelHelpers.export(exports, "variationPlacements", ()=>variationPlacements);
parcelHelpers.export(exports, "placements", ()=>placements);
parcelHelpers.export(exports, "beforeRead", ()=>beforeRead);
parcelHelpers.export(exports, "read", ()=>read);
parcelHelpers.export(exports, "afterRead", ()=>afterRead);
parcelHelpers.export(exports, "beforeMain", ()=>beforeMain);
parcelHelpers.export(exports, "main", ()=>main);
parcelHelpers.export(exports, "afterMain", ()=>afterMain);
parcelHelpers.export(exports, "beforeWrite", ()=>beforeWrite);
parcelHelpers.export(exports, "write", ()=>write);
parcelHelpers.export(exports, "afterWrite", ()=>afterWrite);
parcelHelpers.export(exports, "modifierPhases", ()=>modifierPhases);
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /*#__PURE__*/ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []); // modifiers that need to read the DOM
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead"; // pure-logic modifiers
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain"; // modifier with the purpose to write to the DOM (or write into a framework state)
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"4qeAD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyStyles", ()=>(0, _applyStylesJsDefault.default));
parcelHelpers.export(exports, "arrow", ()=>(0, _arrowJsDefault.default));
parcelHelpers.export(exports, "computeStyles", ()=>(0, _computeStylesJsDefault.default));
parcelHelpers.export(exports, "eventListeners", ()=>(0, _eventListenersJsDefault.default));
parcelHelpers.export(exports, "flip", ()=>(0, _flipJsDefault.default));
parcelHelpers.export(exports, "hide", ()=>(0, _hideJsDefault.default));
parcelHelpers.export(exports, "offset", ()=>(0, _offsetJsDefault.default));
parcelHelpers.export(exports, "popperOffsets", ()=>(0, _popperOffsetsJsDefault.default));
parcelHelpers.export(exports, "preventOverflow", ()=>(0, _preventOverflowJsDefault.default));
var _applyStylesJs = require("./applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _arrowJs = require("./arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _computeStylesJs = require("./computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _eventListenersJs = require("./eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _hideJs = require("./hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _offsetJs = require("./offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _popperOffsetsJs = require("./popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _preventOverflowJs = require("./preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);

},{"./applyStyles.js":"fwNRP","./arrow.js":"e90wO","./computeStyles.js":"hEwUe","./eventListeners.js":"cdfa7","./flip.js":"g2hwl","./hide.js":"jwxh6","./offset.js":"a0b9G","./popperOffsets.js":"5YgYV","./preventOverflow.js":"65wIT","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fwNRP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("../dom-utils/getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements
        if (!(0, _instanceOfJs.isHTMLElement)(element) || !(0, _getNodeNameJsDefault.default)(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? "" : value);
        });
    });
}
function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style = styleProperties.reduce(function(style, property) {
                style[property] = "";
                return style;
            }, {}); // arrow is optional + virtual elements
            if (!(0, _instanceOfJs.isHTMLElement)(element) || !(0, _getNodeNameJsDefault.default)(element)) return;
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect,
    requires: [
        "computeStyles"
    ]
};

},{"../dom-utils/getNodeName.js":"dHJWN","../dom-utils/instanceOf.js":"iYMxC","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dHJWN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
}
exports.default = getNodeName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iYMxC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isElement", ()=>isElement);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function isElement(node) {
    var OwnElement = (0, _getWindowJsDefault.default)(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = (0, _getWindowJsDefault.default)(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === "undefined") return false;
    var OwnElement = (0, _getWindowJsDefault.default)(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":"ijoT7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ijoT7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}
exports.default = getWindow;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"e90wO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _containsJs = require("../dom-utils/contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _withinJs = require("../utils/within.js");
var _mergePaddingObjectJs = require("../utils/mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("../utils/expandToHashMap.js");
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // eslint-disable-next-line import/no-unused-modules
var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
    })) : padding;
    return (0, _mergePaddingObjectJsDefault.default)(typeof padding !== "number" ? padding : (0, _expandToHashMapJsDefault.default)(padding, (0, _enumsJs.basePlacements)));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = (0, _getBasePlacementJsDefault.default)(state.placement);
    var axis = (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement);
    var isVertical = [
        (0, _enumsJs.left),
        (0, _enumsJs.right)
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = (0, _getLayoutRectJsDefault.default)(arrowElement);
    var minProp = axis === "y" ? (0, _enumsJs.top) : (0, _enumsJs.left);
    var maxProp = axis === "y" ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = (0, _getOffsetParentJsDefault.default)(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = (0, _withinJs.within)(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!(0, _containsJsDefault.default)(state.elements.popper, arrowElement)) return;
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect,
    requires: [
        "popperOffsets"
    ],
    requiresIfExists: [
        "preventOverflow"
    ]
};

},{"../utils/getBasePlacement.js":"liZkm","../dom-utils/getLayoutRect.js":"ccwej","../dom-utils/contains.js":"2bp6b","../dom-utils/getOffsetParent.js":"ccO2Y","../utils/getMainAxisFromPlacement.js":"h9MDh","../utils/within.js":"aEfY3","../utils/mergePaddingObject.js":"bTQBb","../utils/expandToHashMap.js":"7XZuj","../enums.js":"6tt9g","../dom-utils/instanceOf.js":"iYMxC","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"liZkm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
function getBasePlacement(placement) {
    return placement.split("-")[0];
}
exports.default = getBasePlacement;

},{"../enums.js":"6tt9g","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ccwej":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js"); // Returns the layout rect of an element relative to its offsetParent. Layout
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
function getLayoutRect(element) {
    var clientRect = (0, _getBoundingClientRectJsDefault.default)(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}
exports.default = getLayoutRect;

},{"./getBoundingClientRect.js":"46QPJ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"46QPJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
var _mathJs = require("../utils/math.js");
function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) includeScale = false;
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if ((0, _instanceOfJs.isHTMLElement)(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`
        if (offsetWidth > 0) scaleX = (0, _mathJs.round)(rect.width) / offsetWidth || 1;
        if (offsetHeight > 0) scaleY = (0, _mathJs.round)(rect.height) / offsetHeight || 1;
    }
    return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
    };
}
exports.default = getBoundingClientRect;

},{"./instanceOf.js":"iYMxC","../utils/math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aS4w0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "round", ()=>round);
var max = Math.max;
var min = Math.min;
var round = Math.round;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2bp6b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && (0, _instanceOfJs.isShadowRoot)(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next);
    } // Give up, the result is false
    return false;
}
exports.default = contains;

},{"./instanceOf.js":"iYMxC","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ccO2Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _isTableElementJs = require("./isTableElement.js");
var _isTableElementJsDefault = parcelHelpers.interopDefault(_isTableElementJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
function getTrueOffsetParent(element) {
    if (!(0, _instanceOfJs.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
    (0, _getComputedStyleJsDefault.default)(element).position === "fixed") return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && (0, _instanceOfJs.isHTMLElement)(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = (0, _getComputedStyleJsDefault.default)(element);
        if (elementCss.position === "fixed") return null;
    }
    var currentNode = (0, _getParentNodeJsDefault.default)(element);
    if ((0, _instanceOfJs.isShadowRoot)(currentNode)) currentNode = currentNode.host;
    while((0, _instanceOfJs.isHTMLElement)(currentNode) && [
        "html",
        "body"
    ].indexOf((0, _getNodeNameJsDefault.default)(currentNode)) < 0){
        var css = (0, _getComputedStyleJsDefault.default)(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [
            "transform",
            "perspective"
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
function getOffsetParent(element) {
    var window = (0, _getWindowJsDefault.default)(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && (0, _isTableElementJsDefault.default)(offsetParent) && (0, _getComputedStyleJsDefault.default)(offsetParent).position === "static")offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && ((0, _getNodeNameJsDefault.default)(offsetParent) === "html" || (0, _getNodeNameJsDefault.default)(offsetParent) === "body" && (0, _getComputedStyleJsDefault.default)(offsetParent).position === "static")) return window;
    return offsetParent || getContainingBlock(element) || window;
}
exports.default = getOffsetParent;

},{"./getWindow.js":"ijoT7","./getNodeName.js":"dHJWN","./getComputedStyle.js":"8M19W","./instanceOf.js":"iYMxC","./isTableElement.js":"fIrfv","./getParentNode.js":"6t49o","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8M19W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getComputedStyle(element) {
    return (0, _getWindowJsDefault.default)(element).getComputedStyle(element);
}
exports.default = getComputedStyle;

},{"./getWindow.js":"ijoT7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fIrfv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
function isTableElement(element) {
    return [
        "table",
        "td",
        "th"
    ].indexOf((0, _getNodeNameJsDefault.default)(element)) >= 0;
}
exports.default = isTableElement;

},{"./getNodeName.js":"dHJWN","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6t49o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _instanceOfJs = require("./instanceOf.js");
function getParentNode(element) {
    if ((0, _getNodeNameJsDefault.default)(element) === "html") return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ((0, _instanceOfJs.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElementJsDefault.default)(element) // fallback
    );
}
exports.default = getParentNode;

},{"./getNodeName.js":"dHJWN","./getDocumentElement.js":"lbV1I","./instanceOf.js":"iYMxC","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lbV1I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return (((0, _instanceOfJs.isElement)(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
exports.default = getDocumentElement;

},{"./instanceOf.js":"iYMxC","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"h9MDh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getMainAxisFromPlacement(placement) {
    return [
        "top",
        "bottom"
    ].indexOf(placement) >= 0 ? "x" : "y";
}
exports.default = getMainAxisFromPlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aEfY3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "within", ()=>within);
parcelHelpers.export(exports, "withinMaxClamp", ()=>withinMaxClamp);
var _mathJs = require("./math.js");
function within(min, value, max) {
    return (0, _mathJs.max)(min, (0, _mathJs.min)(value, max));
}
function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
}

},{"./math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bTQBb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getFreshSideObjectJs = require("./getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
function mergePaddingObject(paddingObject) {
    return Object.assign({}, (0, _getFreshSideObjectJsDefault.default)(), paddingObject);
}
exports.default = mergePaddingObject;

},{"./getFreshSideObject.js":"kkcaj","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"kkcaj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}
exports.default = getFreshSideObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7XZuj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}
exports.default = expandToHashMap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hEwUe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToStyles", ()=>mapToStyles);
var _enumsJs = require("../enums.js");
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getWindowJs = require("../dom-utils/getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("../dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _mathJs = require("../utils/math.js"); // eslint-disable-next-line import/no-unused-modules
var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: (0, _mathJs.round)(x * dpr) / dpr || 0,
        y: (0, _mathJs.round)(y * dpr) / dpr || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = (0, _enumsJs.left);
    var sideY = (0, _enumsJs.top);
    var win = window;
    if (adaptive) {
        var offsetParent = (0, _getOffsetParentJsDefault.default)(popper);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === (0, _getWindowJsDefault.default)(popper)) {
            offsetParent = (0, _getDocumentElementJsDefault.default)(popper);
            if ((0, _getComputedStyleJsDefault.default)(offsetParent).position !== "static" && position === "absolute") {
                heightProp = "scrollHeight";
                widthProp = "scrollWidth";
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        offsetParent;
        if (placement === (0, _enumsJs.top) || (placement === (0, _enumsJs.left) || placement === (0, _enumsJs.right)) && variation === (0, _enumsJs.end)) {
            sideY = (0, _enumsJs.bottom);
            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === (0, _enumsJs.left) || (placement === (0, _enumsJs.top) || placement === (0, _enumsJs.bottom)) && variation === (0, _enumsJs.end)) {
            sideX = (0, _enumsJs.right);
            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var transitionProperty, property;
    var commonStyles = {
        placement: (0, _getBasePlacementJsDefault.default)(state.placement),
        variation: (0, _getVariationJsDefault.default)(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
};

},{"../enums.js":"6tt9g","../dom-utils/getOffsetParent.js":"ccO2Y","../dom-utils/getWindow.js":"ijoT7","../dom-utils/getDocumentElement.js":"lbV1I","../dom-utils/getComputedStyle.js":"8M19W","../utils/getBasePlacement.js":"liZkm","../utils/getVariation.js":"d4wcz","../utils/math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"d4wcz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getVariation(placement) {
    return placement.split("-")[1];
}
exports.default = getVariation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cdfa7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("../dom-utils/getWindow.js"); // eslint-disable-next-line import/no-unused-modules
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var passive = {
    passive: true
};
function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window = (0, _getWindowJsDefault.default)(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
    });
    if (resize) window.addEventListener("resize", instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
        });
        if (resize) window.removeEventListener("resize", instance.update, passive);
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {},
    effect: effect,
    data: {}
};

},{"../dom-utils/getWindow.js":"ijoT7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"g2hwl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getOppositePlacementJs = require("../utils/getOppositePlacement.js");
var _getOppositePlacementJsDefault = parcelHelpers.interopDefault(_getOppositePlacementJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getOppositeVariationPlacementJs = require("../utils/getOppositeVariationPlacement.js");
var _getOppositeVariationPlacementJsDefault = parcelHelpers.interopDefault(_getOppositeVariationPlacementJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _computeAutoPlacementJs = require("../utils/computeAutoPlacement.js");
var _computeAutoPlacementJsDefault = parcelHelpers.interopDefault(_computeAutoPlacementJs);
var _enumsJs = require("../enums.js");
var _getVariationJs = require("../utils/getVariation.js"); // eslint-disable-next-line import/no-unused-modules
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
function getExpandedFallbackPlacements(placement) {
    if ((0, _getBasePlacementJsDefault.default)(placement) === (0, _enumsJs.auto)) return [];
    var oppositePlacement = (0, _getOppositePlacementJsDefault.default)(placement);
    return [
        (0, _getOppositeVariationPlacementJsDefault.default)(placement),
        oppositePlacement,
        (0, _getOppositeVariationPlacementJsDefault.default)(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = (0, _getBasePlacementJsDefault.default)(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        (0, _getOppositePlacementJsDefault.default)(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat((0, _getBasePlacementJsDefault.default)(placement) === (0, _enumsJs.auto) ? (0, _computeAutoPlacementJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement = placements[i];
        var _basePlacement = (0, _getBasePlacementJsDefault.default)(placement);
        var isStartVariation = (0, _getVariationJsDefault.default)(placement) === (0, _enumsJs.start);
        var isVertical = [
            (0, _enumsJs.top),
            (0, _enumsJs.bottom)
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = (0, _detectOverflowJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? (0, _enumsJs.right) : (0, _enumsJs.left) : isStartVariation ? (0, _enumsJs.bottom) : (0, _enumsJs.top);
        if (referenceRect[len] > popperRect[len]) mainVariationSide = (0, _getOppositePlacementJsDefault.default)(mainVariationSide);
        var altVariationSide = (0, _getOppositePlacementJsDefault.default)(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i = numberOfChecks; _i > 0; _i--){
            var _ret = _loop(_i);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: [
        "offset"
    ],
    data: {
        _skip: false
    }
};

},{"../utils/getOppositePlacement.js":"lUPHL","../utils/getBasePlacement.js":"liZkm","../utils/getOppositeVariationPlacement.js":"9SiIX","../utils/detectOverflow.js":"12ud3","../utils/computeAutoPlacement.js":"iteTK","../enums.js":"6tt9g","../utils/getVariation.js":"d4wcz","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lUPHL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}
exports.default = getOppositePlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9SiIX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hash = {
    start: "end",
    end: "start"
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
    });
}
exports.default = getOppositeVariationPlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"12ud3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getClippingRectJs = require("../dom-utils/getClippingRect.js");
var _getClippingRectJsDefault = parcelHelpers.interopDefault(_getClippingRectJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getBoundingClientRectJs = require("../dom-utils/getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _computeOffsetsJs = require("./computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
var _rectToClientRectJs = require("./rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js");
var _mergePaddingObjectJs = require("./mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("./expandToHashMap.js"); // eslint-disable-next-line import/no-unused-modules
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
function detectOverflow(state, options) {
    if (options === void 0) options = {};
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? (0, _enumsJs.clippingParents) : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? (0, _enumsJs.viewport) : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? (0, _enumsJs.popper) : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = (0, _mergePaddingObjectJsDefault.default)(typeof padding !== "number" ? padding : (0, _expandToHashMapJsDefault.default)(padding, (0, _enumsJs.basePlacements)));
    var altContext = elementContext === (0, _enumsJs.popper) ? (0, _enumsJs.reference) : (0, _enumsJs.popper);
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = (0, _getClippingRectJsDefault.default)((0, _instanceOfJs.isElement)(element) ? element : element.contextElement || (0, _getDocumentElementJsDefault.default)(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = (0, _getBoundingClientRectJsDefault.default)(state.elements.reference);
    var popperOffsets = (0, _computeOffsetsJsDefault.default)({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement: placement
    });
    var popperClientRect = (0, _rectToClientRectJsDefault.default)(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === (0, _enumsJs.popper) ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === (0, _enumsJs.popper) && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                (0, _enumsJs.right),
                (0, _enumsJs.bottom)
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                (0, _enumsJs.top),
                (0, _enumsJs.bottom)
            ].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}
exports.default = detectOverflow;

},{"../dom-utils/getClippingRect.js":"2XO5q","../dom-utils/getDocumentElement.js":"lbV1I","../dom-utils/getBoundingClientRect.js":"46QPJ","./computeOffsets.js":"bR2mq","./rectToClientRect.js":"gyipo","../enums.js":"6tt9g","../dom-utils/instanceOf.js":"iYMxC","./mergePaddingObject.js":"bTQBb","./expandToHashMap.js":"7XZuj","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2XO5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getViewportRectJs = require("./getViewportRect.js");
var _getViewportRectJsDefault = parcelHelpers.interopDefault(_getViewportRectJs);
var _getDocumentRectJs = require("./getDocumentRect.js");
var _getDocumentRectJsDefault = parcelHelpers.interopDefault(_getDocumentRectJs);
var _listScrollParentsJs = require("./listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _rectToClientRectJs = require("../utils/rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _mathJs = require("../utils/math.js");
function getInnerBoundingClientRect(element) {
    var rect = (0, _getBoundingClientRectJsDefault.default)(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === (0, _enumsJs.viewport) ? (0, _rectToClientRectJsDefault.default)((0, _getViewportRectJsDefault.default)(element)) : (0, _instanceOfJs.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent) : (0, _rectToClientRectJsDefault.default)((0, _getDocumentRectJsDefault.default)((0, _getDocumentElementJsDefault.default)(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element) {
    var clippingParents = (0, _listScrollParentsJsDefault.default)((0, _getParentNodeJsDefault.default)(element));
    var canEscapeClipping = [
        "absolute",
        "fixed"
    ].indexOf((0, _getComputedStyleJsDefault.default)(element).position) >= 0;
    var clipperElement = canEscapeClipping && (0, _instanceOfJs.isHTMLElement)(element) ? (0, _getOffsetParentJsDefault.default)(element) : element;
    if (!(0, _instanceOfJs.isElement)(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return (0, _instanceOfJs.isElement)(clippingParent) && (0, _containsJsDefault.default)(clippingParent, clipperElement) && (0, _getNodeNameJsDefault.default)(clippingParent) !== "body";
    });
} // Gets the maximum area that the element is visible in due to any number of
function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = (0, _mathJs.max)(rect.top, accRect.top);
        accRect.right = (0, _mathJs.min)(rect.right, accRect.right);
        accRect.bottom = (0, _mathJs.min)(rect.bottom, accRect.bottom);
        accRect.left = (0, _mathJs.max)(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}
exports.default = getClippingRect;

},{"../enums.js":"6tt9g","./getViewportRect.js":"klJPU","./getDocumentRect.js":"7ye4e","./listScrollParents.js":"6bByf","./getOffsetParent.js":"ccO2Y","./getDocumentElement.js":"lbV1I","./getComputedStyle.js":"8M19W","./instanceOf.js":"iYMxC","./getBoundingClientRect.js":"46QPJ","./getParentNode.js":"6t49o","./contains.js":"2bp6b","./getNodeName.js":"dHJWN","../utils/rectToClientRect.js":"gyipo","../utils/math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"klJPU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
function getViewportRect(element) {
    var win = (0, _getWindowJsDefault.default)(element);
    var html = (0, _getDocumentElementJsDefault.default)(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent
        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + (0, _getWindowScrollBarXJsDefault.default)(element),
        y: y
    };
}
exports.default = getViewportRect;

},{"./getWindow.js":"ijoT7","./getDocumentElement.js":"lbV1I","./getWindowScrollBarX.js":"dPDlY","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dPDlY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return (0, _getBoundingClientRectJsDefault.default)((0, _getDocumentElementJsDefault.default)(element)).left + (0, _getWindowScrollJsDefault.default)(element).scrollLeft;
}
exports.default = getWindowScrollBarX;

},{"./getBoundingClientRect.js":"46QPJ","./getDocumentElement.js":"lbV1I","./getWindowScroll.js":"j6HTF","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"j6HTF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getWindowScroll(node) {
    var win = (0, _getWindowJsDefault.default)(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}
exports.default = getWindowScroll;

},{"./getWindow.js":"ijoT7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7ye4e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _mathJs = require("../utils/math.js"); // Gets the entire size of the scrollable document area, even extending outside
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = (0, _getDocumentElementJsDefault.default)(element);
    var winScroll = (0, _getWindowScrollJsDefault.default)(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = (0, _mathJs.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = (0, _mathJs.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + (0, _getWindowScrollBarXJsDefault.default)(element);
    var y = -winScroll.scrollTop;
    if ((0, _getComputedStyleJsDefault.default)(body || html).direction === "rtl") x += (0, _mathJs.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
exports.default = getDocumentRect;

},{"./getDocumentElement.js":"lbV1I","./getComputedStyle.js":"8M19W","./getWindowScrollBarX.js":"dPDlY","./getWindowScroll.js":"j6HTF","../utils/math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6bByf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getScrollParentJs = require("./getScrollParent.js");
var _getScrollParentJsDefault = parcelHelpers.interopDefault(_getScrollParentJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = (0, _getScrollParentJsDefault.default)(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = (0, _getWindowJsDefault.default)(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], (0, _isScrollParentJsDefault.default)(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents((0, _getParentNodeJsDefault.default)(target)));
}
exports.default = listScrollParents;

},{"./getScrollParent.js":"hv2U5","./getParentNode.js":"6t49o","./getWindow.js":"ijoT7","./isScrollParent.js":"8rdzU","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hv2U5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
function getScrollParent(node) {
    if ([
        "html",
        "body",
        "#document"
    ].indexOf((0, _getNodeNameJsDefault.default)(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if ((0, _instanceOfJs.isHTMLElement)(node) && (0, _isScrollParentJsDefault.default)(node)) return node;
    return getScrollParent((0, _getParentNodeJsDefault.default)(node));
}
exports.default = getScrollParent;

},{"./getParentNode.js":"6t49o","./isScrollParent.js":"8rdzU","./getNodeName.js":"dHJWN","./instanceOf.js":"iYMxC","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8rdzU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = (0, _getComputedStyleJsDefault.default)(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
exports.default = isScrollParent;

},{"./getComputedStyle.js":"8M19W","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"gyipo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function rectToClientRect(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}
exports.default = rectToClientRect;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bR2mq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getMainAxisFromPlacementJs = require("./getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _enumsJs = require("../enums.js");
function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? (0, _getBasePlacementJsDefault.default)(placement) : null;
    var variation = placement ? (0, _getVariationJsDefault.default)(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case 0, _enumsJs.top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case 0, _enumsJs.bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 0, _enumsJs.right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 0, _enumsJs.left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch(variation){
            case 0, _enumsJs.start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case 0, _enumsJs.end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}
exports.default = computeOffsets;

},{"./getBasePlacement.js":"liZkm","./getVariation.js":"d4wcz","./getMainAxisFromPlacement.js":"h9MDh","../enums.js":"6tt9g","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iteTK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("./detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {};
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? (0, _enumsJs.placements) : _options$allowedAutoP;
    var variation = (0, _getVariationJsDefault.default)(placement);
    var placements = variation ? flipVariations ? (0, _enumsJs.variationPlacements) : (0, _enumsJs.variationPlacements).filter(function(placement) {
        return (0, _getVariationJsDefault.default)(placement) === variation;
    }) : (0, _enumsJs.basePlacements);
    var allowedPlacements = placements.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) allowedPlacements = placements;
     // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = (0, _detectOverflowJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[(0, _getBasePlacementJsDefault.default)(placement)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}
exports.default = computeAutoPlacement;

},{"./getVariation.js":"d4wcz","../enums.js":"6tt9g","./detectOverflow.js":"12ud3","./getBasePlacement.js":"liZkm","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"jwxh6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function isAnySideFullyClipped(overflow) {
    return [
        (0, _enumsJs.top),
        (0, _enumsJs.right),
        (0, _enumsJs.bottom),
        (0, _enumsJs.left)
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = (0, _detectOverflowJsDefault.default)(state, {
        elementContext: "reference"
    });
    var popperAltOverflow = (0, _detectOverflowJsDefault.default)(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: [
        "preventOverflow"
    ],
    fn: hide
};

},{"../enums.js":"6tt9g","../utils/detectOverflow.js":"12ud3","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"a0b9G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distanceAndSkiddingToXY", ()=>distanceAndSkiddingToXY);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = (0, _getBasePlacementJsDefault.default)(placement);
    var invertDistance = [
        (0, _enumsJs.left),
        (0, _enumsJs.top)
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
        placement: placement
    })) : offset, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        (0, _enumsJs.left),
        (0, _enumsJs.right)
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = (0, _enumsJs.placements).reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: [
        "popperOffsets"
    ],
    fn: offset
};

},{"../utils/getBasePlacement.js":"liZkm","../enums.js":"6tt9g","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5YgYV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeOffsetsJs = require("../utils/computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = (0, _computeOffsetsJsDefault.default)({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
};

},{"../utils/computeOffsets.js":"bR2mq","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"65wIT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _getAltAxisJs = require("../utils/getAltAxis.js");
var _getAltAxisJsDefault = parcelHelpers.interopDefault(_getAltAxisJs);
var _withinJs = require("../utils/within.js");
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getFreshSideObjectJs = require("../utils/getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
var _mathJs = require("../utils/math.js");
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = (0, _detectOverflowJsDefault.default)(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = (0, _getBasePlacementJsDefault.default)(state.placement);
    var variation = (0, _getVariationJsDefault.default)(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement);
    var altAxis = (0, _getAltAxisJsDefault.default)(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? (0, _enumsJs.top) : (0, _enumsJs.left);
        var altSide = mainAxis === "y" ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
        var len = mainAxis === "y" ? "height" : "width";
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === (0, _enumsJs.start) ? referenceRect[len] : popperRect[len];
        var maxLen = variation === (0, _enumsJs.start) ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? (0, _getLayoutRectJsDefault.default)(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : (0, _getFreshSideObjectJsDefault.default)();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = (0, _withinJs.within)(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParentJsDefault.default)(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = (0, _withinJs.within)(tether ? (0, _mathJs.min)(min, tetherMin) : min, offset, tether ? (0, _mathJs.max)(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? (0, _enumsJs.top) : (0, _enumsJs.left);
        var _altSide = mainAxis === "x" ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            (0, _enumsJs.top),
            (0, _enumsJs.left)
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? (0, _withinJs.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _withinJs.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: [
        "offset"
    ]
};

},{"../enums.js":"6tt9g","../utils/getBasePlacement.js":"liZkm","../utils/getMainAxisFromPlacement.js":"h9MDh","../utils/getAltAxis.js":"5PvIk","../utils/within.js":"aEfY3","../dom-utils/getLayoutRect.js":"ccwej","../dom-utils/getOffsetParent.js":"ccO2Y","../utils/detectOverflow.js":"12ud3","../utils/getVariation.js":"d4wcz","../utils/getFreshSideObject.js":"kkcaj","../utils/math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5PvIk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
}
exports.default = getAltAxis;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7Xj0L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>popperGenerator);
parcelHelpers.export(exports, "createPopper", ()=>createPopper);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _detectOverflowJsDefault.default));
var _getCompositeRectJs = require("./dom-utils/getCompositeRect.js");
var _getCompositeRectJsDefault = parcelHelpers.interopDefault(_getCompositeRectJs);
var _getLayoutRectJs = require("./dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _listScrollParentsJs = require("./dom-utils/listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getComputedStyleJs = require("./dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _orderModifiersJs = require("./utils/orderModifiers.js");
var _orderModifiersJsDefault = parcelHelpers.interopDefault(_orderModifiersJs);
var _debounceJs = require("./utils/debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _validateModifiersJs = require("./utils/validateModifiers.js");
var _validateModifiersJsDefault = parcelHelpers.interopDefault(_validateModifiersJs);
var _uniqueByJs = require("./utils/uniqueBy.js");
var _uniqueByJsDefault = parcelHelpers.interopDefault(_uniqueByJs);
var _getBasePlacementJs = require("./utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _mergeByNameJs = require("./utils/mergeByName.js");
var _mergeByNameJsDefault = parcelHelpers.interopDefault(_mergeByNameJs);
var _detectOverflowJs = require("./utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _instanceOfJs = require("./dom-utils/instanceOf.js");
var _enumsJs = require("./enums.js");
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {};
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
        if (options === void 0) options = defaultOptions;
        var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference,
                popper: popper
            },
            attributes: {},
            styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options);
                state.scrollParents = {
                    reference: (0, _instanceOfJs.isElement)(reference) ? (0, _listScrollParentsJsDefault.default)(reference) : reference.contextElement ? (0, _listScrollParentsJsDefault.default)(reference.contextElement) : [],
                    popper: (0, _listScrollParentsJsDefault.default)(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = (0, _orderModifiersJsDefault.default)((0, _mergeByNameJsDefault.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers
                state.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                }); // Validate the provided modifiers so that the consumer will get warned
                var modifiers, _ref, name, flipModifier, _ref2, name1, _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, margin;
                runModifierEffects();
                return instance.update();
            },
            // Sync update – it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!areValidElements(reference, popper)) return;
                 // Store the reference and popper rects to be read by modifiers
                state.rects = {
                    reference: (0, _getCompositeRectJsDefault.default)(reference, (0, _getOffsetParentJsDefault.default)(popper), state.options.strategy === "fixed"),
                    popper: (0, _getLayoutRectJsDefault.default)(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state.orderedModifiers.forEach(function(modifier) {
                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                var __debug_loops__ = 0;
                for(var index = 0; index < state.orderedModifiers.length; index++){
                    if (state.reset === true) {
                        state.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === "function") state = fn({
                        state: state,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state;
                }
            },
            // Async and optimistically optimized update – it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: (0, _debounceJsDefault.default)(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference, popper)) return instance;
        instance.setOptions(options).then(function(state) {
            if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref3) {
                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;
                if (typeof effect === "function") {
                    var cleanupFn = effect({
                        state: state,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var createPopper = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":"5npvX","./dom-utils/getLayoutRect.js":"ccwej","./dom-utils/listScrollParents.js":"6bByf","./dom-utils/getOffsetParent.js":"ccO2Y","./dom-utils/getComputedStyle.js":"8M19W","./utils/orderModifiers.js":"k1vKY","./utils/debounce.js":"b31ss","./utils/validateModifiers.js":"qbS6X","./utils/uniqueBy.js":"iYuVW","./utils/getBasePlacement.js":"liZkm","./utils/mergeByName.js":"5kKAh","./utils/detectOverflow.js":"12ud3","./dom-utils/instanceOf.js":"iYMxC","./enums.js":"6tt9g","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5npvX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getNodeScrollJs = require("./getNodeScroll.js");
var _getNodeScrollJsDefault = parcelHelpers.interopDefault(_getNodeScrollJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _mathJs = require("../utils/math.js");
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = (0, _mathJs.round)(rect.width) / element.offsetWidth || 1;
    var scaleY = (0, _mathJs.round)(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = (0, _instanceOfJs.isHTMLElement)(offsetParent);
    var offsetParentIsScaled = (0, _instanceOfJs.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
    var documentElement = (0, _getDocumentElementJsDefault.default)(offsetParent);
    var rect = (0, _getBoundingClientRectJsDefault.default)(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, _getNodeNameJsDefault.default)(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        (0, _isScrollParentJsDefault.default)(documentElement)) scroll = (0, _getNodeScrollJsDefault.default)(offsetParent);
        if ((0, _instanceOfJs.isHTMLElement)(offsetParent)) {
            offsets = (0, _getBoundingClientRectJsDefault.default)(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = (0, _getWindowScrollBarXJsDefault.default)(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
exports.default = getCompositeRect;

},{"./getBoundingClientRect.js":"46QPJ","./getNodeScroll.js":"k3iJT","./getNodeName.js":"dHJWN","./instanceOf.js":"iYMxC","./getWindowScrollBarX.js":"dPDlY","./getDocumentElement.js":"lbV1I","./isScrollParent.js":"8rdzU","../utils/math.js":"aS4w0","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"k3iJT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _instanceOfJs = require("./instanceOf.js");
var _getHTMLElementScrollJs = require("./getHTMLElementScroll.js");
var _getHTMLElementScrollJsDefault = parcelHelpers.interopDefault(_getHTMLElementScrollJs);
function getNodeScroll(node) {
    if (node === (0, _getWindowJsDefault.default)(node) || !(0, _instanceOfJs.isHTMLElement)(node)) return (0, _getWindowScrollJsDefault.default)(node);
    else return (0, _getHTMLElementScrollJsDefault.default)(node);
}
exports.default = getNodeScroll;

},{"./getWindowScroll.js":"j6HTF","./getWindow.js":"ijoT7","./instanceOf.js":"iYMxC","./getHTMLElementScroll.js":"lUTLQ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lUTLQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}
exports.default = getHTMLElementScroll;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"k1vKY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js"); // source: https://stackoverflow.com/questions/49875255
function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase
    return (0, _enumsJs.modifierPhases).reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}
exports.default = orderModifiers;

},{"../enums.js":"6tt9g","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"b31ss":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function debounce(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}
exports.default = debounce;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"qbS6X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formatJs = require("./format.js");
var _formatJsDefault = parcelHelpers.interopDefault(_formatJs);
var _enumsJs = require("../enums.js");
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = [
    "name",
    "enabled",
    "phase",
    "fn",
    "effect",
    "requires",
    "options"
];
function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function(value, index, self) {
            return self.indexOf(value) === index;
        }).forEach(function(key) {
            switch(key){
                case "name":
                    if (typeof modifier.name !== "string") console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
                    break;
                case "enabled":
                    if (typeof modifier.enabled !== "boolean") console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
                    break;
                case "phase":
                    if ((0, _enumsJs.modifierPhases).indexOf(modifier.phase) < 0) console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + (0, _enumsJs.modifierPhases).join(", "), '"' + String(modifier.phase) + '"'));
                    break;
                case "fn":
                    if (typeof modifier.fn !== "function") console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
                    break;
                case "effect":
                    if (modifier.effect != null && typeof modifier.effect !== "function") console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
                    break;
                case "requires":
                    if (modifier.requires != null && !Array.isArray(modifier.requires)) console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
                    break;
                case "requiresIfExists":
                    if (!Array.isArray(modifier.requiresIfExists)) console.error((0, _formatJsDefault.default)(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
                    break;
                case "options":
                case "data":
                    break;
                default:
                    console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
                        return '"' + s + '"';
                    }).join(", ") + '; but "' + key + '" was provided.');
            }
            modifier.requires && modifier.requires.forEach(function(requirement) {
                if (modifiers.find(function(mod) {
                    return mod.name === requirement;
                }) == null) console.error((0, _formatJsDefault.default)(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            });
        });
    });
}
exports.default = validateModifiers;

},{"./format.js":"40NNo","../enums.js":"6tt9g","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"40NNo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function format(str) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
    return [].concat(args).reduce(function(p, c) {
        return p.replace(/%s/, c);
    }, str);
}
exports.default = format;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iYuVW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function uniqueBy(arr, fn) {
    var identifiers = new Set();
    return arr.filter(function(item) {
        var identifier = fn(item);
        if (!identifiers.has(identifier)) {
            identifiers.add(identifier);
            return true;
        }
    });
}
exports.default = uniqueBy;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5kKAh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
    }, {}); // IE11 does not support Object.values
    return Object.keys(merged).map(function(key) {
        return merged[key];
    });
}
exports.default = mergeByName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hNdY0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopperLite", ()=>(0, _popperLiteJs.createPopper)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopper", ()=>createPopper) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator));
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _offsetJs = require("./modifiers/offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _flipJs = require("./modifiers/flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _preventOverflowJs = require("./modifiers/preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);
var _arrowJs = require("./modifiers/arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _hideJs = require("./modifiers/hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _popperLiteJs = require("./popper-lite.js");
var _indexJs = require("./modifiers/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var defaultModifiers = [
    (0, _eventListenersJsDefault.default),
    (0, _popperOffsetsJsDefault.default),
    (0, _computeStylesJsDefault.default),
    (0, _applyStylesJsDefault.default),
    (0, _offsetJsDefault.default),
    (0, _flipJsDefault.default),
    (0, _preventOverflowJsDefault.default),
    (0, _arrowJsDefault.default),
    (0, _hideJsDefault.default)
];
var createPopper = /*#__PURE__*/ (0, _createPopperJs.popperGenerator)({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"7Xj0L","./modifiers/eventListeners.js":"cdfa7","./modifiers/popperOffsets.js":"5YgYV","./modifiers/computeStyles.js":"hEwUe","./modifiers/applyStyles.js":"fwNRP","./modifiers/offset.js":"a0b9G","./modifiers/flip.js":"g2hwl","./modifiers/preventOverflow.js":"65wIT","./modifiers/arrow.js":"e90wO","./modifiers/hide.js":"jwxh6","./popper-lite.js":"7fTeN","./modifiers/index.js":"4qeAD","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7fTeN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper);
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator));
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var defaultModifiers = [
    (0, _eventListenersJsDefault.default),
    (0, _popperOffsetsJsDefault.default),
    (0, _computeStylesJsDefault.default),
    (0, _applyStylesJsDefault.default)
];
var createPopper = /*#__PURE__*/ (0, _createPopperJs.popperGenerator)({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"7Xj0L","./modifiers/eventListeners.js":"cdfa7","./modifiers/popperOffsets.js":"5YgYV","./modifiers/computeStyles.js":"hEwUe","./modifiers/applyStyles.js":"fwNRP","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"l0GIu":[function(require,module,exports) {
module.exports = ".tippy-box[data-animation=\"fade\"][data-state=\"hidden\"] {\n  opacity: 0;\n}\n\n[data-tippy-root] {\n  max-width: calc(100vw - 10px);\n}\n\n.tippy-box {\n  color: #fff;\n  white-space: normal;\n  background-color: #333;\n  border-radius: 4px;\n  outline: 0;\n  font-size: 14px;\n  line-height: 1.4;\n  transition-property: transform, visibility, opacity;\n  position: relative;\n}\n\n.tippy-box[data-placement^=\"top\"] > .tippy-arrow {\n  bottom: 0;\n}\n\n.tippy-box[data-placement^=\"top\"] > .tippy-arrow:before {\n  border-width: 8px 8px 0;\n  border-top-color: initial;\n  transform-origin: top;\n  bottom: -7px;\n  left: 0;\n}\n\n.tippy-box[data-placement^=\"bottom\"] > .tippy-arrow {\n  top: 0;\n}\n\n.tippy-box[data-placement^=\"bottom\"] > .tippy-arrow:before {\n  border-width: 0 8px 8px;\n  border-bottom-color: initial;\n  transform-origin: bottom;\n  top: -7px;\n  left: 0;\n}\n\n.tippy-box[data-placement^=\"left\"] > .tippy-arrow {\n  right: 0;\n}\n\n.tippy-box[data-placement^=\"left\"] > .tippy-arrow:before {\n  border-width: 8px 0 8px 8px;\n  border-left-color: initial;\n  transform-origin: 0;\n  right: -7px;\n}\n\n.tippy-box[data-placement^=\"right\"] > .tippy-arrow {\n  left: 0;\n}\n\n.tippy-box[data-placement^=\"right\"] > .tippy-arrow:before {\n  border-width: 8px 8px 8px 0;\n  border-right-color: initial;\n  transform-origin: 100%;\n  left: -7px;\n}\n\n.tippy-box[data-inertia][data-state=\"visible\"] {\n  transition-timing-function: cubic-bezier(.54, 1.5, .38, 1.11);\n}\n\n.tippy-arrow {\n  width: 16px;\n  height: 16px;\n  color: #333;\n}\n\n.tippy-arrow:before {\n  content: \"\";\n  border-style: solid;\n  border-color: #0000;\n  position: absolute;\n}\n\n.tippy-content {\n  z-index: 1;\n  padding: 5px 9px;\n  position: relative;\n}\n\n";

},{}],"1CyfK":[function(require,module,exports) {
module.exports = ":host {\n  position: relative;\n}\n\n:host #tip {\n  display: inline-block;\n}\n\n";

},{}],"6KMJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelTabs", ()=>JuelTabs);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _tabsLess = require("bundle-text:./Tabs.less");
var _tabsLessDefault = parcelHelpers.interopDefault(_tabsLess);
var _childrenMap = require("../_Utils/ChildrenMap");
var _juelComponent = require("../_Base/JuelComponent");
var _eventNames = require("../_Core/Events/EventNames");
var _when = require("lit/directives/when");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelTabs = class JuelTabs extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.ids = [];
        this.index = 0;
        this.vertical = false;
    }
    displayTab(evt, id) {
        var i, tabcontent, tablinks;
        tabcontent = this.shadowRoot.querySelectorAll(".panel");
        if (tabcontent) {
            for(i = 0; i < tabcontent.length; i++)tabcontent[i].style.display = "none";
            tablinks = this.shadowRoot.querySelectorAll(".title");
            for(i = 0; i < tablinks.length; i++)tablinks[i].classList.remove("active");
            let el = this.shadowRoot.querySelector(`#${id}`);
            if (el) {
                el.style.display = "block";
                if (evt && evt.target) evt.target.classList.add("active");
                else {
                    let tab = this.shadowRoot.querySelector(`#${id}-title`);
                    if (tab) {
                        let group = tab.closest(".group");
                        if (group) group.classList.add("open");
                        tab.classList.add("active");
                    }
                }
                let e = new CustomEvent((0, _eventNames.EventNames).Changed, {
                    detail: {
                        index: this.ids.indexOf(id)
                    }
                });
                this.dispatchEvent(e);
            }
        }
    }
    load() {
        this.openTab(this.index);
    }
    openTab(i) {
        if (i >= 0 && i < this.ids.length) {
            this.index = i;
            this.displayTab(null, this.ids[this.index]);
        }
    }
    childrenMap(level, idStr) {
        return (el, index)=>{
            let result = [];
            let id = el.id ? el.id : idStr ? `${idStr}-${index}` : `tab-section-${index}`;
            el.setAttribute("slot", id);
            if (level > 0) {
                el.remove();
                this.append(el);
            }
            let titleClass = "title";
            let hasTitleEl = false;
            let titleElId = `${id}-title`;
            let titleEl = el.previousElementSibling;
            if (titleEl && titleEl.matches("[slot$='title']")) {
                hasTitleEl = true;
                titleEl.setAttribute("slot", titleElId);
                if (level > 0) {
                    titleEl.remove();
                    this.append(titleEl);
                }
            }
            let children = el.children;
            let hasChildTabs;
            let hasContent = true;
            for (let child of children)if (child.matches("[data-title], [slot$='title']")) {
                hasChildTabs = true;
                hasContent = false;
            } else hasContent = true;
            let event;
            if (hasContent) {
                this.ids.push(id);
                event = (e)=>{
                    e.stopPropagation();
                    this.displayTab(e, id);
                };
            } else {
                titleClass += " group";
                event = (e)=>{
                    let el = e.target;
                    el.closest(".group").classList.toggle("open");
                };
            }
            return (0, _lit.html)`<div id="${titleElId}" has-content="${hasContent}" class="${titleClass}" @click="${event}">
                ${hasTitleEl ? (0, _lit.html)`<slot name="${titleElId}"></slot>` : (0, _lit.html)`<span>
                        ${el.dataset.title ? el.dataset.title : ""}
                    </span>`}
                ${(0, _when.when)(hasChildTabs, ()=>(0, _childrenMap.ChildrenMap)(el, this.childrenMap(level + 1, id), '[slot="header"], [slot="footer"], [slot="prepend"], [slot="append"], [slot$="title"]'))}
                </div>`;
        };
    }
    render() {
        return (0, _lit.html)`<slot name="header"></slot>
            <div id="tabs-container" class="${this.vertical ? `vertical` : ``}">
            <div id="tabs">
            <div><slot name="prepend"></slot></div>
            ${(0, _childrenMap.ChildrenMap)(this, this.childrenMap(0), '[slot="header"], [slot="footer"], [slot="prepend"], [slot="append"], [slot$="title"]')}
                <div><slot name="append"></slot></div>
                </div>
                ${this.ids.map((id)=>{
            return (0, _lit.html)`</div>
                        <div id="${id}" class="panel">
                        <slot name="${id}"></slot>
                        </div>`;
        })}
        </div>
        <slot name="footer"></slot>`;
    }
};
JuelTabs.styles = (0, _lit.unsafeCSS)((0, _tabsLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelTabs.prototype, "index", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelTabs.prototype, "vertical", void 0);
JuelTabs = __decorate([
    (0, _decorators.customElement)("juel-tabs")
], JuelTabs);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Tabs.less":"8vHod","../_Utils/ChildrenMap":"hG10d","../_Base/JuelComponent":"bVHZk","../_Core/Events/EventNames":"eFaYm","lit/directives/when":"dbNPy","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8vHod":[function(require,module,exports) {
module.exports = ":host {\n  width: 100%;\n}\n\n#tabs {\n  background-color: var(--light, #f1f1f1);\n  height: 80px;\n  border: 1px solid #ccc;\n  flex-direction: row;\n  display: flex;\n  overflow: visible;\n}\n\n#tabs-container {\n  flex-direction: column;\n  display: flex;\n}\n\n#tabs-container.vertical {\n  flex-direction: row;\n}\n\n#tabs-container.vertical #tabs {\n  flex-direction: column;\n}\n\n#tabs-container.vertical #tabs .group {\n  flex-direction: column;\n  display: flex;\n}\n\n#tabs .title {\n  background-color: inherit;\n  cursor: pointer;\n  border: none;\n  outline: none;\n  padding: 14px 16px;\n}\n\n#tabs .title.open {\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n}\n\n#tabs .title.open span {\n  padding-left: 16px;\n}\n\n#tabs .title.open div {\n  display: inline-block;\n}\n\n#tabs .title div {\n  display: none;\n}\n\n#tabs .title:hover {\n  background-color: var(--active, #ddd);\n}\n\n#tabs .title.active {\n  background-color: var(--active, #ccc);\n}\n\n.panel {\n  background-color: var(--light);\n  border: 1px solid #ccc;\n  border-top: none;\n  flex: 1;\n  padding: 6px 12px;\n  animation: 1s fadeEffect;\n  display: none;\n}\n\n@keyframes fadeEffect {\n  from {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n}\n\n";

},{}],"eFaYm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventNames", ()=>EventNames);
var EventNames;
(function(EventNames) {
    EventNames["ButtonClick"] = "button-click";
    EventNames["PreviousClick"] = "previous-click";
    EventNames["NextClick"] = "next-click";
    EventNames["Changed"] = "changed";
    EventNames["Selected"] = "selected";
    EventNames["Deselected"] = "deselected";
    EventNames["Disposed"] = "disposed";
    EventNames["ItemSelected"] = "item-selected";
})(EventNames || (EventNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"geKcT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelBadge", ()=>JuelBadge);
var _decorators = require("lit/decorators");
var _juelComponent = require("../_Base/JuelComponent");
var _alertTypes = require("../_Core/AlertTypes");
var _renderStyles = require("../_Core/RenderStyles");
var _badgeLess = require("bundle-text:./Badge.less");
var _badgeLessDefault = parcelHelpers.interopDefault(_badgeLess);
var _lit = require("lit");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelBadge = class JuelBadge extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.type = (0, _alertTypes.AlertTypes).Primary;
        this.renderStyle = (0, _renderStyles.RenderStyles).Default;
    }
    render() {
        let klass = this.type;
        if (this.renderStyle != (0, _renderStyles.RenderStyles).Default) klass += ` ${this.renderStyle}`;
        return (0, _lit.html)`<span id="root" class="${klass}"><slot>${this.label}<slot></span>`;
    }
};
JuelBadge.styles = (0, _lit.unsafeCSS)((0, _badgeLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelBadge.prototype, "label", void 0);
__decorate([
    (0, _decorators.property)()
], JuelBadge.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "render-style"
    })
], JuelBadge.prototype, "renderStyle", void 0);
JuelBadge = __decorate([
    (0, _decorators.customElement)("juel-badge")
], JuelBadge);

},{"lit/decorators":"04xNl","../_Base/JuelComponent":"bVHZk","../_Core/AlertTypes":"jxn0P","../_Core/RenderStyles":"9FZDh","bundle-text:./Badge.less":"gbuUV","lit":"l2dGb","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"jxn0P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlertTypes", ()=>AlertTypes);
var AlertTypes;
(function(AlertTypes) {
    AlertTypes["Primary"] = "primary";
    AlertTypes["Secondary"] = "secondary";
    AlertTypes["Tertiary"] = "tertiary";
    AlertTypes["Info"] = "info";
    AlertTypes["Success"] = "success";
    AlertTypes["Warning"] = "warning";
    AlertTypes["Danger"] = "danger";
    AlertTypes["Light"] = "light";
    AlertTypes["Dark"] = "dark";
})(AlertTypes || (AlertTypes = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9FZDh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RenderStyles", ()=>RenderStyles);
var RenderStyles;
(function(RenderStyles) {
    RenderStyles["Default"] = "default";
    RenderStyles["Outline"] = "outline";
})(RenderStyles || (RenderStyles = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"gbuUV":[function(require,module,exports) {
module.exports = ".primary {\n  background-color: var(--primary);\n  color: #fff;\n  border: 1px solid var(--primary);\n}\n\n.primary:hover {\n  background-color: #3395ff;\n  border-color: #3395ff;\n}\n\n.primary:active {\n  box-shadow: 0 0 10px var(--primary);\n}\n\n.primary.outline {\n  background-color: initial;\n  color: var(--primary);\n  border-color: var(--primary);\n}\n\n.primary.outline:hover {\n  background-color: var(--primary);\n  color: #fff;\n}\n\n.primary.right-rounded {\n  border-right: 1px solid var(--primary);\n}\n\n.primary.left-rounded {\n  border-left: 1px solid var(--primary);\n}\n\n.secondary {\n  background-color: var(--secondary);\n  color: #fff;\n  border: 1px solid var(--secondary);\n}\n\n.secondary:hover {\n  background-color: #868e96;\n  border-color: #868e96;\n}\n\n.secondary:active {\n  box-shadow: 0 0 10px var(--secondary);\n}\n\n.secondary.outline {\n  background-color: initial;\n  color: var(--secondary);\n  border-color: var(--secondary);\n}\n\n.secondary.outline:hover {\n  background-color: var(--secondary);\n  color: #fff;\n}\n\n.secondary.right-rounded {\n  border-right: 1px solid var(--secondary);\n}\n\n.secondary.left-rounded {\n  border-left: 1px solid var(--secondary);\n}\n\n.tertiary {\n  background-color: var(--tertiary);\n  color: #fff;\n  border: 1px solid var(--tertiary);\n}\n\n.tertiary:hover {\n  background-color: #fcaca3;\n  border-color: #fcaca3;\n}\n\n.tertiary:active {\n  box-shadow: 0 0 10px var(--tertiary);\n}\n\n.tertiary.outline {\n  background-color: initial;\n  color: var(--tertiary);\n  border-color: var(--tertiary);\n}\n\n.tertiary.outline:hover {\n  background-color: var(--tertiary);\n  color: #fff;\n}\n\n.tertiary.right-rounded {\n  border-right: 1px solid var(--tertiary);\n}\n\n.tertiary.left-rounded {\n  border-left: 1px solid var(--tertiary);\n}\n\n.light {\n  background-color: var(--light);\n  color: #000;\n  border: 1px solid var(--light);\n}\n\n.light:hover {\n  background-color: #dae0e5;\n  border-color: #dae0e5;\n}\n\n.light:active {\n  box-shadow: 0 0 10px var(--light);\n}\n\n.light.outline {\n  background-color: initial;\n  color: var(--light);\n  border-color: var(--light);\n}\n\n.light.outline:hover {\n  background-color: var(--light);\n  color: #000;\n}\n\n.light.right-rounded {\n  border-right: 1px solid var(--light);\n}\n\n.light.left-rounded {\n  border-left: 1px solid var(--light);\n}\n\n.dark {\n  background-color: var(--dark);\n  color: #fff;\n  border: 1px solid var(--dark);\n}\n\n.dark:hover {\n  background-color: #4b535c;\n  border-color: #4b535c;\n}\n\n.dark:active {\n  box-shadow: 0 0 10px var(--dark);\n}\n\n.dark.outline {\n  background-color: initial;\n  color: var(--dark);\n  border-color: var(--dark);\n}\n\n.dark.outline:hover {\n  background-color: var(--dark);\n  color: #fff;\n}\n\n.dark.right-rounded {\n  border-right: 1px solid var(--dark);\n}\n\n.dark.left-rounded {\n  border-left: 1px solid var(--dark);\n}\n\n.success {\n  background-color: var(--success);\n  color: #fff;\n  border: 1px solid var(--success);\n}\n\n.success:hover {\n  background-color: #34ce57;\n  border-color: #34ce57;\n}\n\n.success:active {\n  box-shadow: 0 0 10px var(--success);\n}\n\n.success.outline {\n  background-color: initial;\n  color: var(--success);\n  border-color: var(--success);\n}\n\n.success.outline:hover {\n  background-color: var(--success);\n  color: #fff;\n}\n\n.success.right-rounded {\n  border-right: 1px solid var(--success);\n}\n\n.success.left-rounded {\n  border-left: 1px solid var(--success);\n}\n\n.info {\n  background-color: var(--info);\n  color: #fff;\n  border: 1px solid var(--info);\n}\n\n.info:hover {\n  background-color: #1fc8e3;\n  border-color: #1fc8e3;\n}\n\n.info:active {\n  box-shadow: 0 0 10px var(--info);\n}\n\n.info.outline {\n  background-color: initial;\n  color: var(--info);\n  border-color: var(--info);\n}\n\n.info.outline:hover {\n  background-color: var(--info);\n  color: #fff;\n}\n\n.info.right-rounded {\n  border-right: 1px solid var(--info);\n}\n\n.info.left-rounded {\n  border-left: 1px solid var(--info);\n}\n\n.warning {\n  background-color: var(--warning);\n  color: #000;\n  border: 1px solid var(--warning);\n}\n\n.warning:hover {\n  background-color: #d39e00;\n  border-color: #d39e00;\n}\n\n.warning:active {\n  box-shadow: 0 0 10px var(--warning);\n}\n\n.warning.outline {\n  background-color: initial;\n  color: var(--warning);\n  border-color: var(--warning);\n}\n\n.warning.outline:hover {\n  background-color: var(--warning);\n  color: #000;\n}\n\n.warning.right-rounded {\n  border-right: 1px solid var(--warning);\n}\n\n.warning.left-rounded {\n  border-left: 1px solid var(--warning);\n}\n\n.danger {\n  background-color: var(--danger);\n  color: #fff;\n  border: 1px solid var(--danger);\n}\n\n.danger:hover {\n  background-color: #e4606d;\n  border-color: #e4606d;\n}\n\n.danger:active {\n  box-shadow: 0 0 10px var(--danger);\n}\n\n.danger.outline {\n  background-color: initial;\n  color: var(--danger);\n  border-color: var(--danger);\n}\n\n.danger.outline:hover {\n  background-color: var(--danger);\n  color: #fff;\n}\n\n.danger.right-rounded {\n  border-right: 1px solid var(--danger);\n}\n\n.danger.left-rounded {\n  border-left: 1px solid var(--danger);\n}\n\n#root {\n  color: #fff;\n  text-align: center;\n  white-space: nowrap;\n  vertical-align: baseline;\n  border-radius: .25rem;\n  padding: .35em .65em;\n  font-size: .75em;\n  font-weight: 700;\n  line-height: 1;\n  display: inline-block;\n}\n\n";

},{}],"71Q1X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Select", ()=>Select);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _unsafeHtmlJs = require("lit/directives/unsafe-html.js");
var _core = require("@popperjs/core");
var _selectLess = require("bundle-text:./Select.less");
var _selectLessDefault = parcelHelpers.interopDefault(_selectLess);
var _listBase = require("../_Base/ListBase");
var _when = require("lit/directives/when");
var _listItemsTemplate = require("../_Templates/ListItemsTemplate");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Select = class Select extends (0, _listBase.ListBase) {
    constructor(){
        super();
        this.menuShown = false;
        this.menuShown = false;
    }
    firstLoad() {
        this.items = this.shadowRoot.getElementById("items");
        this.items.style.display = "none";
    }
    toggle() {
        this.shadowRoot.getElementById("select").classList.toggle("open");
        if (this.menuShown == false) this.show();
        else this.hide();
    }
    hide() {
        this.items.style.display = "none";
        this.items.style.opacity = "0";
        this.menu = null;
        this.menuShown = false;
        if (this.input) {
            let el = this.shadowRoot.querySelector("input");
            if (el) el.value = this.getPlaceholder();
        }
    }
    show() {
        this.items.style.display = "inline-block";
        this.items.style.opacity = "1";
        this.menu = (0, _core.createPopper)(this.trigger, this.items);
        this.menuShown = true;
    }
    onInput(e) {
        this.show();
        super.onInput(e);
    }
    onItemSelected(index, el) {
        if (this.placeholderIndex == null || this.placeholderIndex != index && this.multiselect == false) this.placeholderIndex = index;
        if (this.input) {
            let el1 = this.shadowRoot.querySelector("input");
            if (el1 && !el1.value) el1.value = this.getPlaceholder();
        }
        if (!this.multiselect) this.hide();
    }
    onItemDeselected(index, el) {
        console.log("Item deselected");
        if (this.selectedIndexes.length > 0 && this.selectedIndexes.some((i)=>i == index) == false) this.placeholderIndex = this.selectedIndexes[0];
        else if (this.selectedIndexes.length == 0) this.placeholderIndex = null;
        if (!this.multiselect) this.hide();
    }
    render() {
        console.log(this.multiselect == true && this.selectedIndexes && this.selectedIndexes.length > 1);
        return (0, _lit.html)`<div id="select">
            ${(0, _when.when)(this.input, ()=>(0, _lit.html)`<div id="trigger"><input type="text" @input="${(e)=>this.onInput(e)}">
                ${(0, _when.when)(this.multiselect == true && this.selectedIndexes && this.selectedIndexes.length > 1, ()=>(0, _lit.html)`<juel-badge .label=${this.selectedIndexes.length - 1}></juel-label>`, ()=>(0, _lit.nothing))}
                <button id="dropdown-toggle" @click="${this.toggle}"></div></div>`, ()=>(0, _lit.html)`<div id="trigger" @click="${this.toggle}">
                <div id="selected-placeholder">
                    ${this.placeholderIndex != null ? (0, _unsafeHtmlJs.unsafeHTML)(this.getPlaceholder()) : (0, _lit.nothing)}
                </div>
                <button id="dropdown-toggle"></button>
                ${(0, _when.when)(this.multiselect == true && this.selectedIndexes && this.selectedIndexes.length > 1, ()=>(0, _lit.html)`<juel-badge .label=${this.selectedIndexes.length - 1}></juel-label>`, ()=>(0, _lit.nothing))}
            </div>`)}
            ${(0, _listItemsTemplate.ListItemsTemplate)(this)}
        </div>`;
    }
};
Select.styles = (0, _lit.unsafeCSS)((0, _selectLessDefault.default));
Select = __decorate([
    (0, _decorators.customElement)("juel-select")
], Select);

},{"lit":"l2dGb","lit/decorators":"04xNl","lit/directives/unsafe-html.js":"hLnZM","@popperjs/core":"a0hlq","bundle-text:./Select.less":"hCecr","../_Base/ListBase":"3lBG7","lit/directives/when":"dbNPy","../_Templates/ListItemsTemplate":"avDG7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hLnZM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _unsafeHtmlJs = require("lit-html/directives/unsafe-html.js");
parcelHelpers.exportAll(_unsafeHtmlJs, exports);

},{"lit-html/directives/unsafe-html.js":"91nIN","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"91nIN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsafeHTMLDirective", ()=>e);
parcelHelpers.export(exports, "unsafeHTML", ()=>o);
var _litHtmlJs = require("../lit-html.js");
var _directiveJs = require("../directive.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ class e extends (0, _directiveJs.Directive) {
    constructor(i){
        if (super(i), this.it = (0, _litHtmlJs.nothing), i.type !== (0, _directiveJs.PartType).CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(r) {
        if (r === (0, _litHtmlJs.nothing) || null == r) return this._t = void 0, this.it = r;
        if (r === (0, _litHtmlJs.noChange)) return r;
        if ("string" != typeof r) throw Error(this.constructor.directiveName + "() called with a non-string value");
        if (r === this.it) return this._t;
        this.it = r;
        const s = [
            r
        ];
        return s.raw = s, this._t = {
            _$litType$: this.constructor.resultType,
            strings: s,
            values: []
        };
    }
}
e.directiveName = "unsafeHTML", e.resultType = 1;
const o = (0, _directiveJs.directive)(e);

},{"../lit-html.js":"ckCvK","../directive.js":"c1vKO","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"c1vKO":[function(require,module,exports) {
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Directive", ()=>i);
parcelHelpers.export(exports, "PartType", ()=>t);
parcelHelpers.export(exports, "directive", ()=>e);
const t = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
}, e = (t)=>(...e)=>({
            _$litDirective$: t,
            values: e
        });
class i {
    constructor(t){}
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AT(t, e, i) {
        this._$Ct = t, this._$AM = e, this._$Ci = i;
    }
    _$AS(t, e) {
        return this.update(t, e);
    }
    update(t, e) {
        return this.render(...e);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hCecr":[function(require,module,exports) {
module.exports = "#dropdown-toggle {\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  border: 1px solid #0000;\n  padding: .375rem .75rem;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  display: inline-block;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n:host {\n  min-width: 130px;\n  height: 25px;\n  --items-height: 200px;\n  cursor: pointer;\n  border: 1px solid #000;\n  padding: 2px 4px;\n  font-family: Arial;\n  position: relative;\n}\n\n#trigger {\n  width: 100%;\n  height: 25px;\n  display: flex;\n}\n\n#items {\n  background-color: var(--light);\n  z-index: 101;\n  height: var(--items-height);\n  width: 100%;\n  border-radius: .25rem;\n  flex-direction: column;\n  margin-bottom: 0;\n  padding-left: 0;\n  display: flex;\n  overflow: hidden scroll;\n}\n\nli {\n  color: #212529;\n  background-color: #fff;\n  border: 1px solid #00000020;\n  padding: .5rem 1rem;\n  text-decoration: none;\n  display: block;\n  position: relative;\n}\n\nli.selected {\n  background-color: var(--primary);\n  color: #fff;\n}\n\nsvg {\n  width: 32px;\n  height: 32px;\n}\n\ndiv {\n  width: 100%;\n  display: inline-block;\n}\n\n#badge {\n  width: 16px;\n  height: 16px;\n  background: red;\n  border-radius: 25px;\n  place-content: center;\n  font-size: small;\n  display: flex;\n  position: absolute;\n  top: 6px;\n  left: 80%;\n}\n\n#badge:before {\n  content: \"✕\";\n}\n\n#selected-placeholder, input {\n  width: 100%;\n}\n\nselect {\n  display: none;\n}\n\n#select #arrow {\n  content: \"\";\n  width: 0;\n  height: 0;\n  border: 6px solid #0000;\n  border-color: var(--primary) transparent transparent transparent;\n  position: absolute;\n  top: 14px;\n  right: 10px;\n}\n\n#select.open #arrow {\n  border-color: transparent transparent var(--primary) transparent;\n  top: 7px;\n}\n\n#items, .selected {\n  cursor: pointer;\n  border: 1px solid #000;\n}\n\n#items {\n  display: inline-block;\n  position: absolute;\n}\n\n.item {\n  width: 100%;\n  display: inline-block;\n}\n\n.item.selected, .item:hover {\n  background-color: var(--primary);\n}\n\n";

},{}],"3lBG7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ListBase", ()=>ListBase);
var _decorators = require("lit/decorators");
var _dispatchFunction = require("../_Core/DispatchFunction");
var _eventNames = require("../_Core/Events/EventNames");
var _knownProperties = require("../_Core/KnownProperties");
var _juelDataComponent = require("./JuelDataComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ListBase extends (0, _juelDataComponent.JuelDataComponent) {
    constructor(){
        super();
        this.multiselect = false;
        this.placeholderIndex = null;
        this.selectedIndexes = [];
        this.selectedData = [];
    }
    getPlaceholder() {
        if (this.placeholderIndex != null) {
            if (this.selectedData && this.selectedData.length > 0) {
                let val;
                if (this.multiselect && this.selectedData.length > this.placeholderIndex) val = this.selectedData[this.placeholderIndex];
                else val = this.selectItem[0];
                if (this.textField && this.textField in val) return val[this.textField];
                else return (0, _knownProperties.GetDisplayKnownProperty)(val);
            } else {
                let el = this.getElementAtIndex(this.placeholderIndex);
                if (el) {
                    let slotted = this.getSlottedItem(el);
                    if (slotted) return slotted.textContent;
                }
            }
        }
    }
    createFormInput() {
        let sel = document.createElement("select");
        let options = this.data.map((item)=>{
            let opt = document.createElement("option");
            opt.textContent = item;
            opt.value = item;
            return opt;
        });
        for (let opt of options)sel.append(opt);
        return sel;
    }
    search(term) {
        this.selectedIndexes = [];
        this.selectedData = [];
        super.search(term);
    }
    getSelectedData() {
        return this.selectedData;
    }
    getElementAtIndex(index) {
        let el = this.shadowRoot.querySelector(`[data-index="${index}"]`);
        return el;
    }
    setSelectedIndexes(indexes) {
        for (let i of indexes)this.selectItem(i);
    }
    getSelectedIndexes() {
        return this.selectedIndexes;
    }
    getSlottedItem(el) {
        let slot = el.querySelector("slot");
        if (slot) {
            let slotted = this.querySelector(`[slot="${slot.name}"]`);
            return slotted;
        }
        return null;
    }
    selectItem(index) {
        let el = this.shadowRoot.querySelector(`[data-index="${index}"]`);
        if (el) {
            let $el = $(el);
            let value = $el.data(ListBase.ValueKey);
            if (!value && this.data && this.data.length > index) value = this.data[index];
            if (!this.multiselect) {
                $el.siblings().each((i, e)=>{
                    $(e).removeClass(ListBase.selectedClass);
                    let slotted = this.getSlottedItem(e);
                    if (slotted) $(slotted).find(`.${ListBase.appearClass}`).hide("slow");
                });
                this.selectedIndexes = [];
                this.selectedData = [];
            }
            if ($el.hasClass(ListBase.selectedClass)) {
                $el.removeClass(ListBase.selectedClass);
                let slotted = this.getSlottedItem(el);
                if (slotted) $(slotted).find(`.${ListBase.appearClass}`).hide("slow");
                this.selectedIndexes = this.selectedIndexes.filter((i)=>i != index);
                if (value) this.selectedData = this.selectedData.filter((val)=>val != value);
                this.onItemDeselected(index, el);
                let args = {
                    index: index,
                    value: value ? value : slotted ? slotted.textContent : el.textContent
                };
                (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).Deselected, args);
            } else {
                $el.addClass(ListBase.selectedClass);
                let slotted1 = this.getSlottedItem(el);
                if (slotted1) $(slotted1).find(`.${ListBase.appearClass}`).show("slow");
                this.selectedIndexes.push(index);
                if (value) this.selectedData.push(value);
                this.onItemSelected(index, el);
                let args1 = {
                    index: index,
                    value: value ? value : slotted1 ? slotted1.textContent : el.textContent
                };
                (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).Selected, args1);
            }
            this.requestUpdate();
        }
    }
    onItemSelected(index, el) {}
    onItemDeselected(index, el) {}
}
ListBase.selectedClass = "selected";
ListBase.appearClass = "juel-appear";
ListBase.ValueKey = "value";
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], ListBase.prototype, "multiselect", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], ListBase.prototype, "input", void 0);
__decorate([
    (0, _decorators.state)()
], ListBase.prototype, "placeholderIndex", void 0);

},{"lit/decorators":"04xNl","../_Core/DispatchFunction":"6kMCY","../_Core/Events/EventNames":"eFaYm","../_Core/KnownProperties":"hEMpF","./JuelDataComponent":"i9Fnw","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6kMCY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Dispatch", ()=>Dispatch);
function Dispatch(el, name, args) {
    let evt = new CustomEvent(name, {
        detail: args
    });
    el.dispatchEvent(evt);
    if (el.juelParent) el.juelParent.dispatchEvent(evt);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hEMpF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KnownProperties", ()=>KnownProperties);
parcelHelpers.export(exports, "GetDisplayKnownProperty", ()=>GetDisplayKnownProperty);
var KnownProperties;
(function(KnownProperties) {
    KnownProperties["id"] = "id";
    KnownProperties["name"] = "name";
    KnownProperties["description"] = "description";
    KnownProperties["text"] = "text";
    KnownProperties["label"] = "label";
})(KnownProperties || (KnownProperties = {}));
function GetDisplayKnownProperty(obj) {
    if (KnownProperties.description in obj) return obj[KnownProperties.description];
    else if (KnownProperties.name in obj) return obj[KnownProperties.name];
    else if (KnownProperties.text in obj) return obj[KnownProperties.text];
    else if (KnownProperties.label in obj) return obj[KnownProperties.label];
    return "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"i9Fnw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelDataComponent", ()=>JuelDataComponent);
var _decorators = require("lit/decorators");
var _fillTemplate = require("../_Utils/FillTemplate");
var _juelComponent = require("./JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class JuelDataComponent extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.data = [];
        this.textField = "text";
        this.fields = [];
    }
    firstLoad() {
        let template = this.querySelector("template");
        if (template) this.template = template.innerHTML;
        else this.template = `\${this.${this.textField}}`;
        if (template && !this.itemTemplate) this.itemTemplate = (value)=>{
            return new Promise((resolve, reject)=>{
                resolve((0, _fillTemplate.FillTemplate)(template.innerHTML, value));
            });
        };
    }
    onInput(e) {
        console.log("OnInput");
        let target = null;
        if (e.composed) target = e.composedPath()[0];
        else target = e.target;
        if (target && "value" in target) {
            let el = e.target;
            if (el.value) {
                console.log("search");
                this.search(el.value);
            } else this.searchResult = null;
        }
    }
    search(term) {
        if (this.textField && this.data && this.data.length > 0) {
            let matchedFields = [];
            let fieldNames = [];
            if (this.fields && this.fields.length > 0) fieldNames = this.fields.filter((x)=>x.visible).map((x)=>x.name);
            else fieldNames.unshift(this.textField);
            let suggestions = this.data.filter((x)=>{
                let match = false;
                for (let name of fieldNames)if (name in x) {
                    let txt = x[name].toString();
                    console.log(txt);
                    if (txt.toLowerCase().includes(term.toLowerCase())) {
                        matchedFields.push(name);
                        match = true;
                    }
                } else match = false;
                return match;
            }).map((value)=>{
                let obj = {
                    ...value
                };
                let regex = new RegExp(`(${term})`, "gi");
                for (let name of fieldNames){
                    let txt = obj[name].toString();
                    if (regex.test(txt)) {
                        txt = txt.replace(regex, "<b>$1</b>");
                        obj[name] = txt;
                    }
                }
                return obj;
            });
            this.searchResult = {
                data: suggestions,
                term: term,
                fields: matchedFields
            };
        } else {
            let children = [
                ...this.children
            ].filter((x)=>x.classList.contains("juel-item"));
            let suggestions1 = children.filter((x)=>{
                if (x.textContent.toLowerCase().includes(term.toLowerCase())) return true;
                else return false;
            }).map((el)=>{
                let obj = {};
                let regex = new RegExp(`(?<!<[\\w="\\s]*)(${term})(?![\\w\\s]*>)`, "gi");
                console.log(el.innerHTML);
                obj[this.textField] = el.innerHTML.replace(regex, "<b>$1</b>");
                return obj;
            });
            this.searchResult = {
                data: suggestions1,
                term: term
            };
        }
        console.log(this.searchResult);
    }
    retrieveDataStrings() {
        if (this.itemTemplate && this.data && this.data.length > 0) {
            if (!this.retrievedDataStrings) this.retrievedDataStrings = [];
            for (let x of this.data)this.itemTemplate(x).then((str)=>{
                this.retrievedDataStrings.push(str);
            });
        }
    }
}
__decorate([
    (0, _decorators.property)({
        type: Array
    })
], JuelDataComponent.prototype, "data", void 0);
__decorate([
    (0, _decorators.property)()
], JuelDataComponent.prototype, "itemTemplate", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "key-field"
    })
], JuelDataComponent.prototype, "keyField", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "text-field"
    })
], JuelDataComponent.prototype, "textField", void 0);
__decorate([
    (0, _decorators.property)({
        type: Array
    })
], JuelDataComponent.prototype, "fields", void 0);
__decorate([
    (0, _decorators.state)()
], JuelDataComponent.prototype, "searchResult", void 0);

},{"lit/decorators":"04xNl","../_Utils/FillTemplate":"cAWvu","./JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cAWvu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FillTemplate", ()=>FillTemplate);
parcelHelpers.export(exports, "FillTemplateUnsafe", ()=>FillTemplateUnsafe);
var _lit = require("lit");
var _unsafeHtml = require("lit/directives/unsafe-html");
function FillTemplate(templateString, data) {
    return new Function("html", "return html`" + templateString + "`;").call(data, (0, _lit.html));
}
function FillTemplateUnsafe(templateString, data) {
    let regex = /(this(\.\w+)+)/g;
    if (regex.test(templateString)) templateString = templateString.replace(/(this(\.\w+)+)/g, "unsafeHTML($1)");
    return new Function("html", "unsafeHTML", "return html`" + templateString + "`;").call(data, (0, _lit.html), (0, _unsafeHtml.unsafeHTML));
}

},{"lit":"l2dGb","lit/directives/unsafe-html":"hLnZM","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"avDG7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ListItemsTemplate", ()=>ListItemsTemplate);
var _lit = require("lit");
var _childrenItemsTempate = require("./ChildrenItemsTempate");
var _itemTemplate = require("./ItemTemplate");
var _tableTemplate = require("./TableTemplate");
function ListItemsTemplate(list) {
    if (list.fields && list.fields.length > 0) return (0, _tableTemplate.TableTemplate)(list);
    else {
        let position = -1;
        return (0, _lit.html)`<ul id="items">${list.searchResult ? (0, _lit.html)`${list.searchResult.data.map((value, index)=>{
            let res = (0, _itemTemplate.ItemTemplate)(list, value, index, position);
            position = res.position;
            return res.template;
        })}` : list.data && list.data.length > 0 ? (0, _lit.html)`${list.data.map((value, index)=>{
            let res = (0, _itemTemplate.ItemTemplate)(list, value, index, position);
            position = res.position;
            return res.template;
        })}` : (0, _childrenItemsTempate.ChildrenItemsTemplate)(list)}</ul>`;
    }
}

},{"lit":"l2dGb","./ChildrenItemsTempate":"4vAZs","./ItemTemplate":"b8BHW","./TableTemplate":"5Db7P","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"4vAZs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChildrenItemsTemplate", ()=>ChildrenItemsTemplate);
var _lit = require("lit");
var _childrenMap = require("../_Utils/ChildrenMap");
var _itemTemplate = require("./ItemTemplate");
function ChildrenItemsTemplate(list, exclude = null) {
    let position = -1;
    return (0, _lit.html)`${(0, _childrenMap.ChildrenMap)(list, (ele, i)=>{
        let res = (0, _itemTemplate.ItemTemplate)(list, ele, i, position);
        position = res.position;
        return res.template;
    }, exclude)}`;
}

},{"lit":"l2dGb","../_Utils/ChildrenMap":"hG10d","./ItemTemplate":"b8BHW","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"b8BHW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ItemTemplate", ()=>ItemTemplate);
var _lit = require("lit");
var _unsafeHtml = require("lit/directives/unsafe-html");
var _listBase = require("../_Base/ListBase");
var _dataDirective = require("../_Directives/DataDirective");
var _fillTemplate = require("../_Utils/FillTemplate");
function ItemTemplate(component, item, index, position) {
    let el = null;
    let list = null;
    let template = null;
    let isHeading = false;
    if ("selectItem" in component) list = component;
    if ("nodeName" in item) el = item;
    if (list && (el && el.tagName.startsWith("H") || "heading" in item && item.heading)) isHeading = true;
    else {
        position++;
        if (el) {
            el.classList.add("juel-item");
            $(el).find(".juel-appear").hide();
        }
    }
    let id = el && el.id ? el.id : `item-${index}`;
    if (el) el.setAttribute("slot", id);
    let klass = isHeading ? "heading" : "item";
    if (list && list.selectedIndexes && list.selectedIndexes.some((i)=>i == position)) klass += " selected";
    let ind = position;
    if (list) {
        if (el) {
            if (isHeading) template = (0, _lit.html)`<li class="${klass}")}>
                <slot name="${id}"></slot>
                </li>`;
            else template = (0, _lit.html)`<li @click="${()=>list.selectItem(ind)}" class="${klass}" data-index="${position}">
                <slot name="${id}"></slot>
                </li>`;
        } else if (list.fields && list.fields.length > 0) template = (0, _lit.html)`<tr class="${klass}"><tr>`;
        else template = (0, _lit.html)`<li @click="${()=>list.selectItem(ind)}" class="${klass}" ${(0, _dataDirective.data)((0, _listBase.ListBase).ValueKey, item)} data-index="${index}">
            ${list.searchResult ? component.template ? (0, _fillTemplate.FillTemplateUnsafe)(component.template, item) : (0, _unsafeHtml.unsafeHTML)(item[list.textField]) : (0, _fillTemplate.FillTemplate)(component.template, item)}
            </li>`;
    } else if (el) template = (0, _lit.html)`<div class="${klass}" data-index="${position}">
                <slot name="${id}"></slot>
                </div>`;
    else template = (0, _lit.html)`<div class="${klass}" ${(0, _dataDirective.data)("data", item)} data-index="${index}">
            ${(0, _fillTemplate.FillTemplate)(component.template, item)}
            </div>`;
    return {
        position: position,
        template: template
    };
}

},{"lit":"l2dGb","lit/directives/unsafe-html":"hLnZM","../_Base/ListBase":"3lBG7","../_Directives/DataDirective":"llrh1","../_Utils/FillTemplate":"cAWvu","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"llrh1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "data", ()=>data);
var _lit = require("lit");
var _directive = require("lit/directive");
class DataDirective extends (0, _directive.Directive) {
    update(part, [name, data]) {
        let el = part.element;
        if (el) $(el).data(name, data);
        return this.render(name, data);
    }
    render(name, data) {
        return 0, _lit.noChange;
    }
}
const data = (0, _directive.directive)(DataDirective);

},{"lit":"l2dGb","lit/directive":"45xFR","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"45xFR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _directiveJs = require("lit-html/directive.js");
parcelHelpers.exportAll(_directiveJs, exports);

},{"lit-html/directive.js":"c1vKO","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5Db7P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TableTemplate", ()=>TableTemplate);
var _lit = require("lit");
var _map = require("lit/directives/map");
var _tableRowTemplate = require("./TableRowTemplate");
function TableTemplate(list) {
    let position = -1;
    return (0, _lit.html)`<table id="items">
    <colgroup>
    ${(0, _map.map)(list.fields.filter((x)=>x.visible), (field, index)=>{
        return (0, _lit.html)`<col class="col-${field.name}">`;
    })}
    <colgroup>
    <thead><tr>
    ${(0, _map.map)(list.fields.filter((x)=>x.visible), (field)=>{
        return (0, _lit.html)`<th>${field.text}</th>`;
    })}
    </tr></thead>
    ${list.searchResult ? (0, _map.map)(list.searchResult.data, (item, index)=>{
        let res = (0, _tableRowTemplate.TableRowTemplate)(list, item, index, position);
        position = res.position;
        return res.template;
    }) : (0, _map.map)(list.data, (item, index)=>{
        let res = (0, _tableRowTemplate.TableRowTemplate)(list, item, index, position);
        position = res.position;
        return res.template;
    })}
    <table>`;
}

},{"lit":"l2dGb","lit/directives/map":"fVhm6","./TableRowTemplate":"aScbp","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fVhm6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("lit-html/directives/map.js");
parcelHelpers.exportAll(_mapJs, exports);

},{"lit-html/directives/map.js":"lYlm1","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lYlm1":[function(require,module,exports) {
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>o);
function* o(o, f) {
    if (void 0 !== o) {
        let i = 0;
        for (const t of o)yield f(t, i++);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aScbp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TableRowTemplate", ()=>TableRowTemplate);
var _lit = require("lit");
var _map = require("lit/directives/map");
var _unsafeHtml = require("lit/directives/unsafe-html");
var _listBase = require("../_Base/ListBase");
var _dataDirective = require("../_Directives/DataDirective");
function TableRowTemplate(component, item, index, position) {
    let template = null;
    position++;
    let klass = "item";
    if (component.selectedIndexes && component.selectedIndexes.some((i)=>i == position)) klass += " selected";
    let i = position;
    template = (0, _lit.html)`<tr ${(0, _dataDirective.data)((0, _listBase.ListBase).ValueKey, item)} @click="${(e)=>component.selectItem(i)}" data-index="${position}">
    ${(0, _map.map)(component.fields, (field)=>{
        if (field.name in item) return (0, _lit.html)`<td>${field.htmlFormatted || component.searchResult && component.searchResult.fields && component.searchResult.fields.includes(field.name) ? (0, _unsafeHtml.unsafeHTML)(item[field.name]) : item[field.name]}<td>`;
    })}
    </tr>`;
    return {
        position: position,
        template: template
    };
}

},{"lit":"l2dGb","lit/directives/map":"fVhm6","lit/directives/unsafe-html":"hLnZM","../_Base/ListBase":"3lBG7","../_Directives/DataDirective":"llrh1","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2rV7j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelScrollPane", ()=>JuelScrollPane);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _scrollPaneLess = require("bundle-text:./ScrollPane.less");
var _scrollPaneLessDefault = parcelHelpers.interopDefault(_scrollPaneLess);
var _childrenMap = require("../_Utils/ChildrenMap");
var _scrollPaneService = require("./ScrollPaneService");
var _hammerjs = require("hammerjs");
var _hammerjsDefault = parcelHelpers.interopDefault(_hammerjs);
var _navigationBase = require("../_Base/NavigationBase");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var JuelScrollPane_1;
let JuelScrollPane = JuelScrollPane_1 = class JuelScrollPane extends (0, _navigationBase.NavigationBase) {
    constructor(){
        super();
        this.positionHistory = [];
        this.service = new (0, _scrollPaneService.ScrollPaneService)(this);
        this.master = 0;
        this.width = null;
        this.position = 0;
        this.vertical = false;
        this.auto = false;
        this.interval = 3000;
        this.effect = "fade";
        this.easing = "swing";
        this.duration = 1000;
        this.controls = false;
        if (!("Hammer" in window)) window["Hammer"] = (0, _hammerjsDefault.default);
    }
    firstLoad() {
        super.firstLoad();
        this.container = this.shadowRoot.querySelector(".container");
        let mc = new (0, _hammerjsDefault.default)(this);
        mc.on("swipe", (e)=>{
            if (e.direction == 2) this.service.next();
            else if (e.direction == 4) this.service.previous();
        });
        this.service.init();
    }
    reset(resetChildren = false) {
        this.service.reset(resetChildren);
    }
    navigateTo(index) {
        let el = $(this.container.querySelectorAll(`[data-index="${index}"]`));
        let margin = 0;
        let prev = el.prevAll();
        console.log(prev);
        if (prev.length > 0) prev.each((i, sib)=>{
            margin += !this.width ? $(sib).outerWidth() : this.width;
        });
        if (!this.fullHeight) {
            let w = el.outerWidth();
            let h = el.outerHeight();
            if (w > 0) this.style.setProperty("--item-width", w.toString());
            if (window["isMobile"] == false && h > 0) this.style.setProperty("--item-height", h.toString());
        }
        console.log(`-${margin}px`);
        this.container.style.setProperty("--scroll-margin", margin.toString());
        this.position = index;
        let evt = new CustomEvent(JuelScrollPane_1.SCROLL, {
            detail: {
                index: index,
                element: el
            }
        });
        this.positionHistory.push(this.position);
        if (this.positionHistory.length == this.children.length) this.positionHistory = [];
        this.dispatchEvent(evt);
    }
    scrollNext(e) {
        if (e) e.stopPropagation();
        this.service.next();
    }
    scrollPrevious(e) {
        if (e) e.stopPropagation();
        this.service.previous();
    }
    itemClick(e) {
        if (e) e.stopPropagation();
    }
    render() {
        return (0, _lit.html)`${this.controls ? (0, _lit.html)`<div id="next" part="next" @click="${this.scrollNext}"><span></span></div>` : ``}
            <div class="container">
                ${(0, _childrenMap.ChildrenMap)(this, (el, index)=>{
            let klass = "item";
            if (index == this.position) {
                klass += " active";
                let $el = $(el);
                let w = $el.outerWidth();
                if (w > 0) this.style.setProperty("--item-width", w.toString());
                let h = $el.outerHeight();
                if (h > 0) this.style.setProperty("--item-height", h.toString());
            }
            let id = el.id ? el.id : `item-${index}`;
            el.setAttribute("slot", id);
            el.classList.add("item");
            el.setAttribute("draggable", "false");
            el.setAttribute("ondragstart", "event.preventDefault();");
            return (0, _lit.html)`
                        <div class="item" data-index="${index}" draggable="false" @click="${this.itemClick}">
                        <slot name="${id}"></slot>
                        </div>`;
        })}
            </div>
            ${this.controls ? (0, _lit.html)`<div id="previous" part="previous" @click="${this.scrollPrevious}"><span></span></div>` : ``}`;
    }
};
JuelScrollPane.SCROLL = "scroll";
JuelScrollPane.styles = (0, _lit.unsafeCSS)((0, _scrollPaneLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelScrollPane.prototype, "vertical", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelScrollPane.prototype, "auto", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "interval", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "effect", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "easing", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "duration", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelScrollPane.prototype, "controls", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "tabs", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "random", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "next", void 0);
__decorate([
    (0, _decorators.property)()
], JuelScrollPane.prototype, "previous", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelScrollPane.prototype, "master", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelScrollPane.prototype, "width", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelScrollPane.prototype, "autoHeight", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelScrollPane.prototype, "fullHeight", void 0);
JuelScrollPane = JuelScrollPane_1 = __decorate([
    (0, _decorators.customElement)("juel-scroll-pane")
], JuelScrollPane);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./ScrollPane.less":"hWu6K","../_Utils/ChildrenMap":"hG10d","./ScrollPaneService":"8Drzk","hammerjs":"doxZZ","../_Base/NavigationBase":"847qf","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hWu6K":[function(require,module,exports) {
module.exports = ":host {\n  transition: width .8s, height .8s;\n  display: flex;\n  overflow: hidden auto;\n}\n\n.container {\n  width: var(--item-width, 100%);\n  height: var(--item-height, 100%);\n  margin-left: var(--scroll-margin, 0);\n  align-items: flex-start;\n  transition: margin .8s, width .8s, height .8s;\n  display: inline-flex;\n}\n\n#previous {\n  z-index: 1;\n  width: 10%;\n  color: #fff;\n  text-align: center;\n  opacity: .25;\n  cursor: pointer;\n  background: #000;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n}\n\n#previous span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-previous);\n}\n\n#next {\n  z-index: 1;\n  width: 10%;\n  color: #fff;\n  text-align: center;\n  opacity: .25;\n  cursor: pointer;\n  background: #000;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n\n#next span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-next);\n}\n\n@media screen and (max-height: 500px) {\n  .item {\n    height: 100%;\n  }\n}\n\n";

},{}],"8Drzk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ScrollPaneService", ()=>ScrollPaneService);
var _randomInt = require("../_Utils/RandomInt");
var _scrollPane = require("./ScrollPane");
class ScrollPaneService {
    constructor(sp){
        this.sp = sp;
        this.positionHistory = [];
    }
    init() {
        this.container = this.sp.shadowRoot.querySelector(".container");
        let first = this.container.querySelector(".item");
        let w = $(first).outerWidth();
        let h = $(first).outerHeight();
        if (w > 0) {
            this.sp.style.width = `${w}px`;
            this.container.style.width = `${w}px`;
        } else if (this.sp.width) {
            this.sp.style.width = `${this.sp.width}px`;
            this.container.style.width = `${this.sp.width}px`;
        }
        if (this.sp.fullHeight) {
            this.sp.style.height = "100%";
            this.container.style.height = "100%";
        } else if (window["isMobile"] == false && h > 0) {
            this.sp.style.height = `${h}px`;
            this.container.style.height = `${h}px`;
        }
        this.children = $(this.container.querySelectorAll(".item"));
        this.randNumbers = [
            this.sp.position
        ];
        this.scrollTo(this.sp.position);
        this.startPosition = this.sp.position;
        if (this.sp.tabs) $(this.sp.tabs).each((index, el)=>{
            $(el).off("click").on("click", ()=>this.scrollTo(index));
        });
        if (this.sp.next) $(this.sp.next).off("click").on("click", ()=>this.next());
        if (this.sp.previous) $(this.sp.previous).off("click").on("click", ()=>this.previous());
        if (this.sp.random) $(this.sp.random).off("click").on("click", ()=>this.random());
        $(this.sp).children().each((index, el)=>{
            if (el.hasAttribute("data-toggle")) {
                let sel = el.dataset["toggle"];
                $(sel).off("click").on("click", ()=>{
                    console.log(this.sp.position + " " + index);
                    if (this.sp.position != index) this.scrollTo(index);
                    else this.scrollTo(this.sp.master);
                });
            }
        });
    }
    scrollTo(index) {
        console.log(this.container);
        let el = $(this.container.querySelectorAll(`[data-index="${index}"]`));
        let margin = 0;
        let prev = el.prevAll();
        console.log(prev);
        if (prev.length > 0) prev.each((i, sib)=>{
            margin += !this.sp.width ? $(sib).outerWidth() : this.sp.width;
        });
        if (!this.sp.fullHeight) {
            let w = el.outerWidth();
            let h = el.outerHeight();
            if (w > 0) this.sp.style.width = `${w}px`;
            if (window["isMobile"] == false && h > 0) this.sp.style.height = `${h}px`;
        }
        console.log(`-${margin}px`);
        this.container.style.marginLeft = `-${margin}px`;
        this.sp.position = index;
        let evt = new CustomEvent((0, _scrollPane.JuelScrollPane).SCROLL, {
            detail: {
                index: index,
                element: el
            }
        });
        this.positionHistory.push(this.sp.position);
        if (this.positionHistory.length == this.children.length) this.positionHistory = [];
        this.sp.dispatchEvent(evt);
    }
    next() {
        this.sp.position++;
        if (this.sp.position >= this.sp.children.length) this.sp.position = 0;
        let prevEl = this.sp.children[this.sp.position];
        while(prevEl && prevEl.classList.contains("hidden")){
            this.sp.position++;
            if (this.sp.position >= this.children.length) this.sp.position = 0;
        }
        this.scrollTo(this.sp.position);
    }
    previous() {
        this.sp.position--;
        if (this.sp.position < 0) this.sp.position = this.children.length - 1;
        let nextEl = this.sp.children[this.sp.position];
        while(nextEl && nextEl.classList.contains("hidden")){
            this.sp.position--;
            if (this.sp.position < 0) this.sp.position = this.children.length - 1;
        }
        this.scrollTo(this.sp.position);
    }
    random() {
        let index = (0, _randomInt.getRandomInt)(this.children.length);
        while(index == this.sp.position || this.positionHistory.some((n)=>n == index))index = (0, _randomInt.getRandomInt)(this.children.length);
        this.scrollTo(index);
        this.sp.position = index;
        this.randNumbers.push(index);
        if (this.randNumbers.length == this.children.length) this.randNumbers = [
            index
        ];
    }
    reset(resetChildren = false) {
        this.scrollTo(this.startPosition);
        if (resetChildren == true) {
            let toggles = this.sp.querySelectorAll("juel-toggle");
            for (let toggle of toggles)toggle.reset();
        }
    }
}

},{"../_Utils/RandomInt":"2Ngnt","./ScrollPane":"2rV7j","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2Ngnt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRandomInt", ()=>getRandomInt);
function getRandomInt(max) {
    return Math.floor(Math.random() * Math.floor(max));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"doxZZ":[function(require,module,exports) {
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */ (function(window1, document1, exportName, undefined) {
    "use strict";
    var VENDOR_PREFIXES = [
        "",
        "webkit",
        "Moz",
        "MS",
        "ms",
        "o"
    ];
    var TEST_ELEMENT = document1.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */ function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */ function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */ function each(obj, iterator, context) {
        var i;
        if (!obj) return;
        if (obj.forEach) obj.forEach(iterator, context);
        else if (obj.length !== undefined) {
            i = 0;
            while(i < obj.length){
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else for(i in obj)obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
    /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */ function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log = window1.console && (window1.console.warn || window1.console.log);
            if (log) log.call(window1.console, deprecationMessage, stack);
            return method.apply(this, arguments);
        };
    }
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */ var assign;
    if (typeof Object.assign !== "function") assign = function assign(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for(var nextKey in source)if (source.hasOwnProperty(nextKey)) output[nextKey] = source[nextKey];
            }
        }
        return output;
    };
    else assign = Object.assign;
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */ var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while(i < keys.length){
            if (!merge || merge && dest[keys[i]] === undefined) dest[keys[i]] = src[keys[i]];
            i++;
        }
        return dest;
    }, "extend", "Use `assign`.");
    /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */ var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, "merge", "Use `assign`.");
    /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */ function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) assign(childP, properties);
    }
    /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */ function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */ function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) return val.apply(args ? args[0] || undefined : undefined, args);
        return val;
    }
    /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */ function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */ function hasParent(node, parent) {
        while(node){
            if (node == parent) return true;
            node = node.parentNode;
        }
        return false;
    }
    /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */ function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */ function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */ function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) return src.indexOf(find);
        else {
            var i = 0;
            while(i < src.length){
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) return i;
                i++;
            }
            return -1;
        }
    }
    /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */ function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */ function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while(i < src.length){
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) results.push(src[i]);
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) results = results.sort();
            else results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
        return results;
    }
    /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */ function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while(i < VENDOR_PREFIXES.length){
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) return prop;
            i++;
        }
        return undefined;
    }
    /**
 * get a unique id
 * @returns {number} uniqueId
 */ var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */ function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window1;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window1;
    var SUPPORT_POINTER_EVENTS = prefixed(window1, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [
        "x",
        "y"
    ];
    var PROPS_CLIENT_XY = [
        "clientX",
        "clientY"
    ];
    /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */ function Input(manager, callback) {
        var self1 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [
                manager
            ])) self1.handler(ev);
        };
        this.init();
    }
    Input.prototype = {
        /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */ handler: function() {},
        /**
     * bind the events
     */ init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
     * unbind the events
     */ destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */ function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) Type = inputClass;
        else if (SUPPORT_POINTER_EVENTS) Type = PointerEventInput;
        else if (SUPPORT_ONLY_TOUCH) Type = TouchInput;
        else if (!SUPPORT_TOUCH) Type = MouseInput;
        else Type = TouchMouseInput;
        return new Type(manager, inputHandler);
    }
    /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */ function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) manager.session = {};
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */ function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) session.firstInput = simpleCloneInputData(input);
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
        else if (pointersLength === 1) session.firstMultiple = false;
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */ function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */ function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while(i < input.pointers.length){
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */ function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
        var x = 0, y = 0, i = 0;
        while(i < pointersLength){
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */ function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */ function getDirection(x, y) {
        if (x === y) return DIRECTION_NONE;
        if (abs(x) >= abs(y)) return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */ function getDistance(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */ function getAngle(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */ function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */ function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    /**
 * Mouse events input
 * @constructor
 * @extends Input
 */ function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) this.pressed = true;
            if (eventType & INPUT_MOVE && ev.which !== 1) eventType = INPUT_END;
            // mouse must be down
            if (!this.pressed) return;
            if (eventType & INPUT_END) this.pressed = false;
            this.callback(this.manager, eventType, {
                pointers: [
                    ev
                ],
                changedPointers: [
                    ev
                ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    // IE10 has prefixed support, and case-sensitive
    if (window1.MSPointerEvent && !window1.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    /**
 * Pointer events input
 * @constructor
 * @extends Input
 */ function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) removePointer = true;
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) return;
            // update the event in the store
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [
                    ev
                ],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) // remove from the store
            store.splice(storeIndex, 1);
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Touch events input
 * @constructor
 * @extends Input
 */ function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            // should we handle the touch events?
            if (type === INPUT_START) this.started = true;
            if (!this.started) return;
            var touches = normalizeSingleTouches.call(this, ev, type);
            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) this.started = false;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) all = uniqueArray(all.concat(changed), "identifier", true);
        return [
            all,
            changed
        ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */ function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) return;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [
                allTouches,
                allTouches
            ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while(i < targetTouches.length){
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while(i < changedTouches.length){
            if (targetIds[changedTouches[i].identifier]) changedTargetTouches.push(changedTouches[i]);
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) delete targetIds[changedTouches[i].identifier];
            i++;
        }
        if (!changedTargetTouches.length) return;
        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
        ];
    }
    /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */ var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
    }
    inherit(TouchMouseInput, Input, {
        /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */ handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) return;
            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) recordTouches.call(this, inputEvent, inputData);
            else if (isMouse && isSyntheticEvent.call(this, inputData)) return;
            this.callback(manager, inputEvent, inputData);
        },
        /**
     * remove the event listeners
     */ destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) setLastTouch.call(this, eventData);
    }
    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
                x: touch.clientX,
                y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) lts.splice(i, 1);
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }
    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for(var i = 0; i < this.lastTouches.length; i++){
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) return true;
        }
        return false;
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation"; // not implemented
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    var TOUCH_ACTION_MAP = getTouchActionProps();
    /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */ function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */ set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) value = this.compute();
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            this.actions = value.toLowerCase().trim();
        },
        /**
     * just re-set the touchAction value
     */ update: function() {
            this.set(this.manager.options.touchAction);
        },
        /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */ compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [
                    recognizer
                ])) actions = actions.concat(recognizer.getTouchAction());
            });
            return cleanTouchActions(actions.join(" "));
        },
        /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */ preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
                //do not prevent defaults if this is a tap gesture
                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;
                if (isTapPointer && isTapMovement && isTapTouchTime) return;
            }
            if (hasPanX && hasPanY) // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) return this.preventSrc(srcEvent);
        },
        /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */ preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */ function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
        // pan-x OR pan-y
        if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
        return TOUCH_ACTION_AUTO;
    }
    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) return false;
        var touchMap = {};
        var cssSupports = window1.CSS && window1.CSS.supports;
        [
            "auto",
            "manipulation",
            "pan-y",
            "pan-x",
            "pan-x pan-y",
            "none"
        ].forEach(function(val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window1.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
    }
    /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */ var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */ function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
     * @virtual
     * @type {Object}
     */ defaults: {},
        /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */ set: function(options) {
            assign(this.options, options);
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) return this;
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) return this;
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) this.requireFail.splice(index, 1);
            return this;
        },
        /**
     * has require failures boolean
     * @returns {boolean}
     */ hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */ canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */ emit: function(input) {
            var self1 = this;
            var state = this.state;
            function emit(event) {
                self1.manager.emit(event, input);
            }
            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) emit(self1.options.event + stateStr(state));
            emit(self1.options.event); // simple 'eventName' events
            if (input.additionalEvent) emit(input.additionalEvent);
            // panend and pancancel
            if (state >= STATE_ENDED) emit(self1.options.event + stateStr(state));
        },
        /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */ tryEmit: function(input) {
            if (this.canEmit()) return this.emit(input);
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
     * can we emit?
     * @returns {boolean}
     */ canEmit: function() {
            var i = 0;
            while(i < this.requireFail.length){
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) return false;
                i++;
            }
            return true;
        },
        /**
     * update the recognizer
     * @param {Object} inputData
     */ recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);
            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [
                this,
                inputDataClone
            ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) this.state = STATE_POSSIBLE;
            this.state = this.process(inputDataClone);
            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) this.tryEmit(inputDataClone);
        },
        /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */ process: function(inputData) {},
        /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */ getTouchAction: function() {},
        /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */ reset: function() {}
    };
    /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */ function stateStr(state) {
        if (state & STATE_CANCELLED) return "cancel";
        else if (state & STATE_ENDED) return "end";
        else if (state & STATE_CHANGED) return "move";
        else if (state & STATE_BEGAN) return "start";
        return "";
    }
    /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */ function directionStr(direction) {
        if (direction == DIRECTION_DOWN) return "down";
        else if (direction == DIRECTION_UP) return "up";
        else if (direction == DIRECTION_LEFT) return "left";
        else if (direction == DIRECTION_RIGHT) return "right";
        return "";
    }
    /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */ function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) return manager.get(otherRecognizer);
        return otherRecognizer;
    }
    /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */ function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof AttrRecognizer
     */ defaults: {
            /**
         * @type {Number}
         * @default 1
         */ pointers: 1
        },
        /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */ attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */ process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) return state | STATE_CANCELLED;
            else if (isRecognized || isValid) {
                if (eventType & INPUT_END) return state | STATE_ENDED;
                else if (!(state & STATE_BEGAN)) return STATE_BEGAN;
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PanRecognizer
     */ defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) actions.push(TOUCH_ACTION_PAN_Y);
            if (direction & DIRECTION_VERTICAL) actions.push(TOUCH_ACTION_PAN_X);
            return actions;
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) input.additionalEvent = this.options.event + direction;
            this._super.emit.call(this, input);
        }
    });
    /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */ function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });
    /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */ function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PressRecognizer
     */ defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9 // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_AUTO
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) this.reset();
            else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) return STATE_RECOGNIZED;
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) return;
            if (input && input.eventType & INPUT_END) this.manager.emit(this.options.event + "up", input);
            else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */ function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof RotateRecognizer
     */ defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof SwipeRecognizer
     */ defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) velocity = input.overallVelocity;
            else if (direction & DIRECTION_HORIZONTAL) velocity = input.overallVelocityX;
            else if (direction & DIRECTION_VERTICAL) velocity = input.overallVelocityY;
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) this.manager.emit(this.options.event + direction, input);
            this.manager.emit(this.options.event, input);
        }
    });
    /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */ function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_MANIPULATION
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) return this.failTimeout();
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) return this.failTimeout();
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) this.count = 1;
                else this.count += 1;
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) return STATE_RECOGNIZED;
                    else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
 * @const {string}
 */ Hammer.VERSION = "2.0.7";
    /**
 * default settings
 * @namespace
 */ Hammer.defaults = {
        /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */ domEvents: false,
        /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */ touchAction: TOUCH_ACTION_COMPUTE,
        /**
     * @type {Boolean}
     * @default true
     */ enable: true,
        /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */ inputTarget: null,
        /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */ inputClass: null,
        /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */ preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [
                RotateRecognizer,
                {
                    enable: false
                }
            ],
            [
                PinchRecognizer,
                {
                    enable: false
                },
                [
                    "rotate"
                ]
            ],
            [
                SwipeRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                }
            ],
            [
                PanRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                },
                [
                    "swipe"
                ]
            ],
            [
                TapRecognizer
            ],
            [
                TapRecognizer,
                {
                    event: "doubletap",
                    taps: 2
                },
                [
                    "tap"
                ]
            ],
            [
                PressRecognizer
            ]
        ],
        /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */ cssProps: {
            /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userSelect: "none",
            /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */ touchSelect: "none",
            /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */ touchCallout: "none",
            /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */ contentZooming: "none",
            /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userDrag: "none",
            /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */ tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */ set: function(options) {
            assign(this.options, options);
            // Options that need a little more setup
            if (options.touchAction) this.touchAction.update();
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */ stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */ recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) return;
            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) curRecognizer = session.curRecognizer = null;
            var i = 0;
            while(i < recognizers.length){
                recognizer = recognizers[i];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || // 2
                recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
                else recognizer.reset();
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) curRecognizer = session.curRecognizer = recognizer;
                i++;
            }
        },
        /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */ get: function(recognizer) {
            if (recognizer instanceof Recognizer) return recognizer;
            var recognizers = this.recognizers;
            for(var i = 0; i < recognizers.length; i++){
                if (recognizers[i].options.event == recognizer) return recognizers[i];
            }
            return null;
        },
        /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */ add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) return this;
            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) this.remove(existing);
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */ remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) return this;
            recognizer = this.get(recognizer);
            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);
                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }
            return this;
        },
        /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */ on: function(events, handler) {
            if (events === undefined) return;
            if (handler === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */ off: function(events, handler) {
            if (events === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) delete handlers[event];
                else handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            });
            return this;
        },
        /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */ emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) triggerDomEvent(event, data);
            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) return;
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while(i < handlers.length){
                handlers[i](data);
                i++;
            }
        },
        /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */ destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */ function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) return;
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else element.style[prop] = manager.oldCssProps[prop] || "";
        });
        if (!add) manager.oldCssProps = {};
    }
    /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */ function triggerDomEvent(event, data) {
        var gestureEvent = document1.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = typeof window1 !== "undefined" ? window1 : typeof self !== "undefined" ? self : {}; // jshint ignore:line
    freeGlobal.Hammer = Hammer;
    if (typeof define === "function" && define.amd) define(function() {
        return Hammer;
    });
    else if (module.exports) module.exports = Hammer;
    else window1[exportName] = Hammer;
})(window, document, "Hammer");

},{}],"kdVmJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelList", ()=>JuelList);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _listLess = require("bundle-text:./List.less");
var _listLessDefault = parcelHelpers.interopDefault(_listLess);
var _when = require("lit/directives/when");
var _listBase = require("../_Base/ListBase");
var _listItemsTemplate = require("../_Templates/ListItemsTemplate");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelList = class JuelList extends (0, _listBase.ListBase) {
    constructor(){
        super();
    }
    render() {
        return (0, _lit.html)`<div id="list">
            ${(0, _when.when)(this.input, ()=>(0, _lit.html)`<input type="text" @input="${(e)=>this.onInput(e)}">`, ()=>(0, _lit.nothing))}
            ${(0, _listItemsTemplate.ListItemsTemplate)(this)}
        </div>`;
    }
};
JuelList.styles = (0, _lit.unsafeCSS)((0, _listLessDefault.default));
JuelList = __decorate([
    (0, _decorators.customElement)("juel-list")
], JuelList);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./List.less":"925Ip","lit/directives/when":"dbNPy","../_Base/ListBase":"3lBG7","../_Templates/ListItemsTemplate":"avDG7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"925Ip":[function(require,module,exports) {
module.exports = "input {\n  width: 100%;\n}\n\n#items {\n  background-color: var(--light);\n  z-index: 101;\n  border-radius: .25rem;\n  flex-direction: column;\n  margin-bottom: 0;\n  padding-left: 0;\n  display: flex;\n}\n\nli {\n  color: #212529;\n  background-color: #fff;\n  border: 1px solid #00000020;\n  padding: .5rem 1rem;\n  text-decoration: none;\n  display: block;\n  position: relative;\n}\n\nli.selected {\n  background-color: var(--primary);\n  color: #fff;\n}\n\n";

},{}],"LBqTL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelMenu", ()=>JuelMenu);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _core = require("@popperjs/core");
var _childrenMap = require("../_Utils/ChildrenMap");
var _menuLess = require("bundle-text:./Menu.less");
var _menuLessDefault = parcelHelpers.interopDefault(_menuLess);
var _isMobile = require("../_Utils/IsMobile");
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelMenu = class JuelMenu extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.push = (0, _isMobile.IsMobile)();
        this.trigger = "over";
        this.menuShown = false;
        this.triggered = false;
    }
    load() {
        let items = this.shadowRoot.getElementById("items");
        let trigger = $(this.shadowRoot.getElementById("trigger"));
        if (!this.trigger || this.trigger == "over") this.trigger = "mouseover touchstart";
        trigger.off(this.trigger).on(this.trigger, (e)=>{
            if (this.menuShown == false) {
                this.triggered = true;
                trigger.toggleClass("open");
                items.style.display = "inline-block";
                if (this.push == false) this.menu = (0, _core.createPopper)(trigger[0], items, {
                    placement: $(this).parent("juel-menu").length > 0 ? "right-end" : "bottom"
                });
                this.menuShown = true;
            }
        });
        $([
            items,
            trigger[0]
        ]).off("mousemove").on("mousemove", ()=>{
            if (this.triggered == true) this.menuShown = true;
        }).off("mouseleave").on("mouseleave", (e)=>{
            this.menuShown = false;
            setTimeout(()=>{
                if (this.menuShown == false) {
                    items.style.display = "none";
                    this.menu = null;
                    this.triggered = false;
                }
            }, 1000);
        });
    }
    render() {
        return (0, _lit.html)`<div id="container">
            <div id="trigger">
                <slot name="trigger">
                    <button>${this.title}</button>
                </slot>
                <div id="down-arrow"></div>
            </div>
            <div id="items">
            ${(0, _childrenMap.ChildrenMap)(this, (el, index)=>{
            let id = el.id ? el.id : `item-${index}`;
            el.setAttribute("slot", id);
            return (0, _lit.html)`
                        <div class="item" data-index="${index}">
                        <slot name="${id}"></slot>
                        </div>`;
        }, '[slot="trigger"]')}
            </div>
        </div>`;
    }
};
JuelMenu.styles = (0, _lit.unsafeCSS)((0, _menuLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelMenu.prototype, "push", void 0);
__decorate([
    (0, _decorators.property)()
], JuelMenu.prototype, "trigger", void 0);
JuelMenu = __decorate([
    (0, _decorators.customElement)("juel-menu")
], JuelMenu);

},{"lit":"l2dGb","lit/decorators":"04xNl","@popperjs/core":"a0hlq","../_Utils/ChildrenMap":"hG10d","bundle-text:./Menu.less":"hxvQm","../_Utils/IsMobile":"5Z54X","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hxvQm":[function(require,module,exports) {
module.exports = ":host {\n  display: inline-block;\n  position: relative;\n}\n\n#items {\n  z-index: 100;\n  color: #212529;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  padding: .5rem 0;\n  font-size: 1rem;\n  display: none;\n}\n\n#trigger button {\n  display: flex;\n}\n\n#trigger button:before {\n  width: 1.25em;\n  content: var(--icon-indicator);\n  transform-origin: .5em;\n  line-height: 0;\n  transition: transform .35s;\n}\n\n#trigger.open button:before {\n  transform: rotate(90deg);\n}\n\n";

},{}],"inF6U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelModal", ()=>JuelModal);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _juelComponent = require("../_Base/JuelComponent");
var _modalLess = require("bundle-text:./Modal.less");
var _modalLessDefault = parcelHelpers.interopDefault(_modalLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelModal = class JuelModal extends (0, _juelComponent.JuelComponent) {
    load() {
        if (this.trigger) $(this.trigger).on("click", ()=>{
            this.open();
        });
    }
    open() {
        $(this.shadowRoot.querySelector(".modal")).addClass("open");
    }
    close() {
        $(this.shadowRoot.querySelector(".modal")).removeClass("open");
    }
    render() {
        return (0, _lit.html)`<div class="modal">
            <div class="container">
            <div class="header"><slot name="title"></slot><span class="close" @click="${this.close}"></span></div>
            <div class="content">
            <slot></slot>
            </div>
            </div>
        </div>`;
    }
};
JuelModal.styles = (0, _lit.unsafeCSS)((0, _modalLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelModal.prototype, "trigger", void 0);
JuelModal = __decorate([
    (0, _decorators.customElement)("juel-modal")
], JuelModal);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Base/JuelComponent":"bVHZk","bundle-text:./Modal.less":"cMjwy","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cMjwy":[function(require,module,exports) {
module.exports = "@keyframes move-down {\n  from {\n    transform: translateY(-50px);\n  }\n\n  to {\n    transform: translateY(0);\n  }\n}\n\n.modal {\n  width: 100vw;\n  height: 100vh;\n  background: #00000080;\n  justify-content: center;\n  align-items: center;\n  display: none;\n  position: fixed;\n  top: 0;\n  left: 0;\n}\n\n.modal.open {\n  display: flex;\n}\n\n.modal.open .container {\n  animation: .6s ease-out move-down;\n}\n\n.container {\n  width: 90%;\n  max-width: 450px;\n  background-color: #fff;\n  border: 1px solid #0003;\n  border-radius: .3rem;\n  position: relative;\n}\n\n.header {\n  border-bottom: 1px solid #dee2e6;\n  flex-shrink: 0;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n  display: flex;\n}\n\n.content {\n  pointer-events: auto;\n  background-color: #fff;\n  background-clip: padding-box;\n  outline: 0;\n  flex-direction: column;\n  padding: 1rem;\n  display: flex;\n  position: relative;\n}\n\n.close {\n  cursor: pointer;\n  background-image: var(--icon-close);\n  opacity: .5;\n  width: 26px;\n  height: 26px;\n  background-position: center;\n  background-repeat: no-repeat;\n  margin-top: 3%;\n}\n\n.close:hover {\n  opacity: 1;\n}\n\n::slotted(h1), ::slotted(h2), ::slotted(h3), ::slotted(h4), ::slotted(h5), ::slotted(h6) {\n  margin: 0;\n}\n\n";

},{}],"8Dnb4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelToggle", ()=>JuelToggle);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _toggleLess = require("bundle-text:./Toggle.less");
var _toggleLessDefault = parcelHelpers.interopDefault(_toggleLess);
var _dispatchFunction = require("../_Core/DispatchFunction");
var _juelComponent = require("../_Base/JuelComponent");
var _toggleEvents = require("./ToggleEvents");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelToggle = class JuelToggle extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super(...arguments);
        this.defaultWidth = 60;
        this.defaultHeight = 34;
        this.rounded = false;
        this.singular = false;
        this.contained = false;
        this.container = ".container";
        this.type = null;
        this.content = null;
        this.custom = false;
        this.width = null;
        this.height = null;
        this.checked = false;
    }
    firstUpdated() {
        let trigger = this.shadowRoot.getElementById("trigger");
        if (!this.width) this.style.width = `${this.width}px`;
        else if (trigger) this.style.width = trigger.style.width;
        else this.style.width = `${this.defaultWidth}px`;
        if (!this.height) this.style.height = `${this.height}px`;
        else if (trigger) this.style.height = trigger.style.height;
        else this.style.height = `${this.defaultHeight}px`;
        if (this.checked) {
            this.classList.remove("unchecked");
            this.classList.add("checked");
        } else {
            this.classList.remove("checked");
            this.classList.add("unchecked");
        }
        if (trigger) $(trigger).on("click", ()=>{
            this.toggle();
            if (this.singular == true) this.singularCheck();
        });
    }
    toggle() {
        this.checked = !this.checked;
        let checkbox = this.shadowRoot.getElementById("checkbox");
        checkbox.checked = this.checked;
        if (this.checked) {
            this.classList.remove("unchecked");
            this.classList.add("checked");
        } else {
            this.classList.remove("checked");
            this.classList.add("unchecked");
        }
        let args = {
            value: this.checked
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _toggleEvents.ToggleEvents).Toggled, args);
    }
    reset() {
        this.checked = false;
        this.shadowRoot.getElementById("checkbox").checked = false;
    }
    check(index, ele) {
        if (ele.checked) {
            if ((ele.type != null || this.type != null) && ele.type != this.type) return;
            else ele.toggle();
        }
    }
    singularCheck() {
        if (this.contained == false) {
            let siblings = $(this).siblings("juel-toggle");
            siblings.each(this.check.bind(this));
        } else $(this).parentsUntil(this.container).parent().find("juel-toggle").not(this).each(this.check.bind(this));
    }
    checkChange(e) {
        let check = e.target;
        this.checked = check.checked;
        if (this.checked) {
            this.classList.remove("unchecked");
            this.classList.add("checked");
        } else {
            this.classList.remove("checked");
            this.classList.add("unchecked");
        }
        let args = {
            value: this.checked
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _toggleEvents.ToggleEvents).Toggled, args);
        this.requestUpdate();
    }
    toggleClicked(e) {
        if (this.singular == true) this.singularCheck();
    }
    render() {
        let contentStrs = null;
        if (this.content && this.content.includes(",")) contentStrs = this.content.split(",");
        return (0, _lit.html)`<label class="${this.custom ? "custom" : "switch"}" @click="${this.toggleClicked}">
        <input type="checkbox" id="checkbox" @change="${this.checkChange}">
        ${this.custom ? (0, _lit.html)`<slot name="${this.checked ? "checked" : "unchecked"}"></slot>` : this.content ? (0, _lit.html)`<button id="trigger">${contentStrs ? contentStrs[this.checked ? 1 : 0] : this.content}</button>` : (0, _lit.html)`<span class="${this.rounded == false ? "slider" : "slider rounded"}"></span>`}
      </label>`;
    }
};
JuelToggle.styles = (0, _lit.unsafeCSS)((0, _toggleLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelToggle.prototype, "rounded", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelToggle.prototype, "singular", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelToggle.prototype, "contained", void 0);
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelToggle.prototype, "container", void 0);
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelToggle.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelToggle.prototype, "content", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelToggle.prototype, "custom", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelToggle.prototype, "width", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelToggle.prototype, "height", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelToggle.prototype, "checked", void 0);
JuelToggle = __decorate([
    (0, _decorators.customElement)("juel-toggle")
], JuelToggle);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Toggle.less":"5GlBh","../_Core/DispatchFunction":"6kMCY","../_Base/JuelComponent":"bVHZk","./ToggleEvents":"fZgeR","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5GlBh":[function(require,module,exports) {
module.exports = ":host {\n  display: inline-block;\n}\n\n.switch {\n  width: 60px;\n  height: 34px;\n  display: block;\n  position: relative;\n}\n\n.custom {\n  display: flex;\n}\n\n.switch input, .custom input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n#trigger {\n  width: 100%;\n  height: 100%;\n  z-index: 101;\n  position: absolute;\n  top: 0;\n}\n\n.slider {\n  cursor: pointer;\n  background-color: #ccc;\n  transition: all .4s;\n  position: absolute;\n  inset: 0;\n}\n\n.slider:before {\n  content: \"\";\n  height: 26px;\n  width: 26px;\n  background-color: #fff;\n  transition: all .4s;\n  position: absolute;\n  bottom: 4px;\n  left: 4px;\n}\n\ninput:checked + .slider {\n  background-color: #2196f3;\n}\n\ninput:checked + #trigger {\n  background-color: #2196f3 !important;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #2196f3;\n}\n\ninput:checked + .slider:before {\n  transform: translateX(26px);\n}\n\n.slider.rounded {\n  border-radius: 34px;\n}\n\n.slider.rounded:before {\n  border-radius: 50%;\n}\n\n";

},{}],"fZgeR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ToggleEvents", ()=>ToggleEvents);
var ToggleEvents;
(function(ToggleEvents) {
    ToggleEvents["Toggled"] = "toggled";
})(ToggleEvents || (ToggleEvents = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"i46xy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelButton", ()=>JuelButton);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _buttonLess = require("bundle-text:./Button.less");
var _buttonLessDefault = parcelHelpers.interopDefault(_buttonLess);
var _rippleModule = require("../_Utils/RippleModule");
var _inputBase = require("../_Base/InputBase");
var _inputGroupTemplate = require("../_Templates/InputGroupTemplate");
var _inputTypes = require("../_Templates/InputTypes");
var _buttonEvents = require("./ButtonEvents");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelButton = class JuelButton extends (0, _inputBase.InputBase) {
    constructor(){
        super();
        this.submit = false;
    }
    updated() {
        setTimeout(()=>{
            this.isRipple = getComputedStyle(this).getPropertyValue("--ripple");
            console.log(this.isRipple);
            if (this.isRipple) {
                let btn = this.shadowRoot.firstElementChild;
                this.r = new (0, _rippleModule.RippleInitialiser)(btn);
            }
        });
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    onClick(e) {
        var event = new CustomEvent((0, _buttonEvents.ButtonEvents).ButtonClicked, {
            detail: e
        });
        this.dispatchEvent(event);
        if (this.submit == true) {
            let frm = this.closest("form");
            if (frm) {
                if ("requestSubmit" in frm) frm.requestSubmit();
                else frm.submit();
            }
        }
    }
    render() {
        return (0, _inputGroupTemplate.InputGroupTemplate)(this, (0, _inputTypes.InputTypes).Button);
    }
};
JuelButton.styles = (0, _lit.unsafeCSS)((0, _buttonLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelButton.prototype, "submit", void 0);
JuelButton = __decorate([
    (0, _decorators.customElement)("juel-button")
], JuelButton);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Button.less":"fcalq","../_Utils/RippleModule":"9O1q2","../_Base/InputBase":"gjQM1","../_Templates/InputGroupTemplate":"80pYq","../_Templates/InputTypes":"el4fw","./ButtonEvents":"IEB4b","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fcalq":[function(require,module,exports) {
module.exports = ".primary {\n  background-color: var(--primary);\n  color: #fff;\n  border: 1px solid var(--primary);\n}\n\n.primary:hover {\n  background-color: #3395ff;\n  border-color: #3395ff;\n}\n\n.primary:active {\n  box-shadow: 0 0 10px var(--primary);\n}\n\n.primary.outline {\n  background-color: initial;\n  color: var(--primary);\n  border-color: var(--primary);\n}\n\n.primary.outline:hover {\n  background-color: var(--primary);\n  color: #fff;\n}\n\n.primary.right-rounded {\n  border-right: 1px solid var(--primary);\n}\n\n.primary.left-rounded {\n  border-left: 1px solid var(--primary);\n}\n\n.secondary {\n  background-color: var(--secondary);\n  color: #fff;\n  border: 1px solid var(--secondary);\n}\n\n.secondary:hover {\n  background-color: #868e96;\n  border-color: #868e96;\n}\n\n.secondary:active {\n  box-shadow: 0 0 10px var(--secondary);\n}\n\n.secondary.outline {\n  background-color: initial;\n  color: var(--secondary);\n  border-color: var(--secondary);\n}\n\n.secondary.outline:hover {\n  background-color: var(--secondary);\n  color: #fff;\n}\n\n.secondary.right-rounded {\n  border-right: 1px solid var(--secondary);\n}\n\n.secondary.left-rounded {\n  border-left: 1px solid var(--secondary);\n}\n\n.tertiary {\n  background-color: var(--tertiary);\n  color: #fff;\n  border: 1px solid var(--tertiary);\n}\n\n.tertiary:hover {\n  background-color: #fcaca3;\n  border-color: #fcaca3;\n}\n\n.tertiary:active {\n  box-shadow: 0 0 10px var(--tertiary);\n}\n\n.tertiary.outline {\n  background-color: initial;\n  color: var(--tertiary);\n  border-color: var(--tertiary);\n}\n\n.tertiary.outline:hover {\n  background-color: var(--tertiary);\n  color: #fff;\n}\n\n.tertiary.right-rounded {\n  border-right: 1px solid var(--tertiary);\n}\n\n.tertiary.left-rounded {\n  border-left: 1px solid var(--tertiary);\n}\n\n.light {\n  background-color: var(--light);\n  color: #000;\n  border: 1px solid var(--light);\n}\n\n.light:hover {\n  background-color: #dae0e5;\n  border-color: #dae0e5;\n}\n\n.light:active {\n  box-shadow: 0 0 10px var(--light);\n}\n\n.light.outline {\n  background-color: initial;\n  color: var(--light);\n  border-color: var(--light);\n}\n\n.light.outline:hover {\n  background-color: var(--light);\n  color: #000;\n}\n\n.light.right-rounded {\n  border-right: 1px solid var(--light);\n}\n\n.light.left-rounded {\n  border-left: 1px solid var(--light);\n}\n\n.dark {\n  background-color: var(--dark);\n  color: #fff;\n  border: 1px solid var(--dark);\n}\n\n.dark:hover {\n  background-color: #4b535c;\n  border-color: #4b535c;\n}\n\n.dark:active {\n  box-shadow: 0 0 10px var(--dark);\n}\n\n.dark.outline {\n  background-color: initial;\n  color: var(--dark);\n  border-color: var(--dark);\n}\n\n.dark.outline:hover {\n  background-color: var(--dark);\n  color: #fff;\n}\n\n.dark.right-rounded {\n  border-right: 1px solid var(--dark);\n}\n\n.dark.left-rounded {\n  border-left: 1px solid var(--dark);\n}\n\n.success {\n  background-color: var(--success);\n  color: #fff;\n  border: 1px solid var(--success);\n}\n\n.success:hover {\n  background-color: #34ce57;\n  border-color: #34ce57;\n}\n\n.success:active {\n  box-shadow: 0 0 10px var(--success);\n}\n\n.success.outline {\n  background-color: initial;\n  color: var(--success);\n  border-color: var(--success);\n}\n\n.success.outline:hover {\n  background-color: var(--success);\n  color: #fff;\n}\n\n.success.right-rounded {\n  border-right: 1px solid var(--success);\n}\n\n.success.left-rounded {\n  border-left: 1px solid var(--success);\n}\n\n.info {\n  background-color: var(--info);\n  color: #fff;\n  border: 1px solid var(--info);\n}\n\n.info:hover {\n  background-color: #1fc8e3;\n  border-color: #1fc8e3;\n}\n\n.info:active {\n  box-shadow: 0 0 10px var(--info);\n}\n\n.info.outline {\n  background-color: initial;\n  color: var(--info);\n  border-color: var(--info);\n}\n\n.info.outline:hover {\n  background-color: var(--info);\n  color: #fff;\n}\n\n.info.right-rounded {\n  border-right: 1px solid var(--info);\n}\n\n.info.left-rounded {\n  border-left: 1px solid var(--info);\n}\n\n.warning {\n  background-color: var(--warning);\n  color: #000;\n  border: 1px solid var(--warning);\n}\n\n.warning:hover {\n  background-color: #d39e00;\n  border-color: #d39e00;\n}\n\n.warning:active {\n  box-shadow: 0 0 10px var(--warning);\n}\n\n.warning.outline {\n  background-color: initial;\n  color: var(--warning);\n  border-color: var(--warning);\n}\n\n.warning.outline:hover {\n  background-color: var(--warning);\n  color: #000;\n}\n\n.warning.right-rounded {\n  border-right: 1px solid var(--warning);\n}\n\n.warning.left-rounded {\n  border-left: 1px solid var(--warning);\n}\n\n.danger {\n  background-color: var(--danger);\n  color: #fff;\n  border: 1px solid var(--danger);\n}\n\n.danger:hover {\n  background-color: #e4606d;\n  border-color: #e4606d;\n}\n\n.danger:active {\n  box-shadow: 0 0 10px var(--danger);\n}\n\n.danger.outline {\n  background-color: initial;\n  color: var(--danger);\n  border-color: var(--danger);\n}\n\n.danger.outline:hover {\n  background-color: var(--danger);\n  color: #fff;\n}\n\n.danger.right-rounded {\n  border-right: 1px solid var(--danger);\n}\n\n.danger.left-rounded {\n  border-left: 1px solid var(--danger);\n}\n\n#dropdown-toggle {\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  border: 1px solid #0000;\n  padding: .375rem .75rem;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  display: inline-block;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n:host {\n  display: inline-block;\n  position: relative;\n}\n\ninput.text {\n  width: 100%;\n}\n\n.input-group {\n  flex-direction: var(--direction, row);\n  background-color: #e9ecef;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  padding: .375rem;\n  display: inline-flex;\n}\n\n.rounded {\n  border-radius: .25rem;\n}\n\n.right-rounded {\n  border-top-right-radius: .25rem;\n  border-bottom-right-radius: .25rem;\n}\n\n.left-rounded {\n  border-top-left-radius: .25rem;\n  border-bottom-left-radius: .25rem;\n}\n\n.no-rounded {\n  border-radius: 0;\n}\n\n#dropdown-items {\n  z-index: 1000;\n  width: 100%;\n  color: #212529;\n  text-align: left;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  font-size: 1rem;\n  display: none;\n  position: absolute;\n}\n\n::slotted(ul) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 1rem;\n  list-style: none;\n  display: flex;\n}\n\n::slotted(ol) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 0;\n  list-style: none;\n  display: flex;\n}\n\n.btn {\n  position: relative;\n  overflow: hidden;\n}\n\n.btn-group {\n  vertical-align: middle;\n  display: inline-flex;\n  position: relative;\n}\n\n.btn-group > .btn-group:not(:last-child) > button, .btn-group > button:not(:last-child):not(.dropdown) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.btn-group > .btn-group:not(:first-child) > button, .btn-group > button:nth-child(n+3), .btn-group > :not(.btn-check) + button {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\nbutton {\n  color: #212529;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  user-select: none;\n  color: #fff;\n  background-color: #0000;\n  border: 1px solid #0000;\n  padding: .375rem .75rem;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  text-decoration: none;\n  transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out;\n  display: inline-block;\n}\n\n";

},{}],"9O1q2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RippleInitialiser", ()=>RippleInitialiser);
var _rippleAnimationLess = require("bundle-text:../_CommonStyles/RippleAnimation.less");
var _rippleAnimationLessDefault = parcelHelpers.interopDefault(_rippleAnimationLess);
class RippleInitialiser {
    constructor(element){
        this.element = element;
        this.removeRipples = (el)=>{
            el.removeEventListener("click", this.createRipple.bind(this));
        };
        element.addEventListener("click", this.createRipple.bind(this));
        let root = element.getRootNode();
        const style = document.createElement("style");
        style.textContent = (0, _rippleAnimationLessDefault.default);
        root.prepend(style);
    }
    createRipple(event) {
        const button = this.element;
        const circle = document.createElement("span");
        const diameter = Math.max(button.clientWidth, button.clientHeight);
        const radius = diameter / 2;
        circle.setAttribute("part", "ripple");
        circle.style.width = circle.style.height = `${diameter}px`;
        circle.style.left = `${event.clientX - button.offsetLeft - radius}px`;
        circle.style.top = `${event.clientY - button.offsetTop - radius}px`;
        circle.classList.add("ripple");
        const ripple = button.getElementsByClassName("ripple")[0];
        if (ripple) ripple.remove();
        button.appendChild(circle);
    }
}

},{"bundle-text:../_CommonStyles/RippleAnimation.less":"710lp","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"710lp":[function(require,module,exports) {
module.exports = "@keyframes ripple {\n  to {\n    opacity: 0;\n    transform: scale(4);\n  }\n}\n\n";

},{}],"gjQM1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InputBase", ()=>InputBase);
var _jqueryTabbable = require("../jquery-tabbable");
var _core = require("@popperjs/core");
var _decorators = require("lit/decorators");
var _juelComponent = require("./JuelComponent");
var _ref = require("lit/directives/ref");
var _bindDecorator = require("bind-decorator");
var _bindDecoratorDefault = parcelHelpers.interopDefault(_bindDecorator);
var _renderStyles = require("../_Core/RenderStyles");
var _alertTypes = require("../_Core/AlertTypes");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class InputBase extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.input = (0, _ref.createRef)();
        this.dropdownShown = false;
        this.type = (0, _alertTypes.AlertTypes).Primary;
        this.renderStyle = (0, _renderStyles.RenderStyles).Default;
    }
    firstUpdated() {
        super.firstUpdated();
        this.$this = $(this);
        this.addEventListener("keyup", (e)=>{
            console.log("Up");
            console.log(e);
            if (e.key == "Enter") this.nextOrSubmit();
        });
        if (this.input.value) this.input.value.focus();
    }
    nextOrSubmit() {
        let next = this.$this.nextAll(InputBase.InputElementNames);
        if (next.length == 0) {
            let steps = this.closest("juel-steps");
            if (steps) {
                steps.next();
                $.tabNext();
            } else {
                let frm = this.closest("form");
                if (frm && "requestSubmit" in frm) frm.requestSubmit();
                else if (frm) frm.submit();
            }
        } else $.tabNext();
    }
    focus(options) {
        if (this.input.value) this.input.value.focus();
        else super.focus(options);
    }
    onClick(e) {}
    toggleDropdown() {
        var items = this.shadowRoot.querySelector("#dropdown-items");
        if (this.dropdownShown == false) {
            this.dropdown = (0, _core.createPopper)(this.shadowRoot.querySelector("#dropdown-toggle"), items, {
                placement: "bottom-end"
            });
            items.style.display = "initial";
            this.dropdownShown = true;
        } else {
            this.dropdown.destroy();
            items.style.display = "none";
            this.dropdownShown = false;
        }
    }
}
InputBase.InputElementNames = "juel-text, juel-memo, juel-range, juel-tickbox, juel-radio";
__decorate([
    (0, _decorators.property)()
], InputBase.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "render-style"
    })
], InputBase.prototype, "renderStyle", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], InputBase.prototype, "addonActive", void 0);
__decorate([
    (0, _decorators.property)()
], InputBase.prototype, "label", void 0);
__decorate([
    (0, _decorators.property)()
], InputBase.prototype, "name", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], InputBase.prototype, "active", void 0);
__decorate([
    (0, _bindDecoratorDefault.default)
], InputBase.prototype, "nextOrSubmit", null);

},{"../jquery-tabbable":"3j9wp","@popperjs/core":"a0hlq","lit/decorators":"04xNl","./JuelComponent":"bVHZk","lit/directives/ref":"8K7tz","bind-decorator":"fKOgr","../_Core/RenderStyles":"9FZDh","../_Core/AlertTypes":"jxn0P","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3j9wp":[function(require,module,exports) {
/*!
 * jQuery.tabbable 1.0 - Simple utility for selecting the next / previous ':tabbable' element.
 * https://github.com/marklagendijk/jQuery.tabbable
 *
 * Includes ':tabbable' and ':focusable' selectors from jQuery UI Core
 *
 * Copyright 2013, Mark Lagendijk
 * Released under the MIT license
 *
 */ (function($) {
    "use strict";
    /**
	 * Focusses the next :focusable element. Elements with tabindex=-1 are focusable, but not tabable.
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.focusNext = function() {
        selectNextTabbableOrFocusable(":focusable");
    };
    /**
	 * Focusses the previous :focusable element. Elements with tabindex=-1 are focusable, but not tabable.
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.focusPrev = function() {
        selectPrevTabbableOrFocusable(":focusable");
    };
    /**
	 * Focusses the next :tabable element.
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.tabNext = function() {
        selectNextTabbableOrFocusable(":tabbable");
    };
    /**
	 * Focusses the previous :tabbable element
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.tabPrev = function() {
        selectPrevTabbableOrFocusable(":tabbable");
    };
    function selectNextTabbableOrFocusable(selector) {
        var selectables = $(selector);
        var current = $(":focus");
        var nextIndex = 0;
        if (current.length === 1) {
            var currentIndex = selectables.index(current);
            if (currentIndex + 1 < selectables.length) nextIndex = currentIndex + 1;
        }
        selectables.eq(nextIndex).focus();
    }
    function selectPrevTabbableOrFocusable(selector) {
        var selectables = $(selector);
        var current = $(":focus");
        var prevIndex = selectables.length - 1;
        if (current.length === 1) {
            var currentIndex = selectables.index(current);
            if (currentIndex > 0) prevIndex = currentIndex - 1;
        }
        selectables.eq(prevIndex).focus();
    }
    /**
	 * :focusable and :tabbable, both taken from jQuery UI Core
	 */ $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : // support: jQuery <1.8
        function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });
    /**
	 * focussable function, taken from jQuery UI Core
	 * @param element
	 * @returns {*}
	 */ function focusable(element) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase(), isTabIndexNotNaN = !isNaN($.attr(element, "tabindex"));
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") return false;
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        // Luke: Added extra strings for juel-?
        return (/input|text|memo|radio|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && // the element and all of its ancestors must be visible
        visible(element);
        function visible(element) {
            return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
                return $.css(this, "visibility") === "hidden";
            }).length;
        }
    }
})(jQuery);

},{}],"8K7tz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _refJs = require("lit-html/directives/ref.js");
parcelHelpers.exportAll(_refJs, exports);

},{"lit-html/directives/ref.js":"3THkE","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3THkE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createRef", ()=>e);
parcelHelpers.export(exports, "ref", ()=>n);
var _litHtmlJs = require("../lit-html.js");
var _asyncDirectiveJs = require("../async-directive.js");
var _directiveJs = require("../directive.js");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const e = ()=>new o;
class o {
}
const h = new WeakMap, n = (0, _directiveJs.directive)(class extends (0, _asyncDirectiveJs.AsyncDirective) {
    render(t) {
        return 0, _litHtmlJs.nothing;
    }
    update(t, [s]) {
        var e;
        const o = s !== this.Y;
        return o && void 0 !== this.Y && this.rt(void 0), (o || this.lt !== this.ct) && (this.Y = s, this.dt = null === (e = t.options) || void 0 === e ? void 0 : e.host, this.rt(this.ct = t.element)), _litHtmlJs.nothing;
    }
    rt(i) {
        var t;
        if ("function" == typeof this.Y) {
            const s = null !== (t = this.dt) && void 0 !== t ? t : globalThis;
            let e = h.get(s);
            void 0 === e && (e = new WeakMap, h.set(s, e)), void 0 !== e.get(this.Y) && this.Y.call(this.dt, void 0), e.set(this.Y, i), void 0 !== i && this.Y.call(this.dt, i);
        } else this.Y.value = i;
    }
    get lt() {
        var i, t, s;
        return "function" == typeof this.Y ? null === (t = h.get(null !== (i = this.dt) && void 0 !== i ? i : globalThis)) || void 0 === t ? void 0 : t.get(this.Y) : null === (s = this.Y) || void 0 === s ? void 0 : s.value;
    }
    disconnected() {
        this.lt === this.ct && this.rt(void 0);
    }
    reconnected() {
        this.rt(this.ct);
    }
});

},{"../lit-html.js":"ckCvK","../async-directive.js":"f8tJb","../directive.js":"c1vKO","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"f8tJb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Directive", ()=>(0, _directiveJs.Directive));
parcelHelpers.export(exports, "PartType", ()=>(0, _directiveJs.PartType));
parcelHelpers.export(exports, "directive", ()=>(0, _directiveJs.directive));
parcelHelpers.export(exports, "AsyncDirective", ()=>c);
var _directiveHelpersJs = require("./directive-helpers.js");
var _directiveJs = require("./directive.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const s = (i, t)=>{
    var e, o;
    const r = i._$AN;
    if (void 0 === r) return !1;
    for (const i1 of r)null === (o = (e = i1)._$AO) || void 0 === o || o.call(e, t, !1), s(i1, t);
    return !0;
}, o = (i)=>{
    let t, e;
    do {
        if (void 0 === (t = i._$AM)) break;
        e = t._$AN, e.delete(i), i = t;
    }while (0 === (null == e ? void 0 : e.size));
}, r = (i)=>{
    for(let t; t = i._$AM; i = t){
        let e = t._$AN;
        if (void 0 === e) t._$AN = e = new Set;
        else if (e.has(i)) break;
        e.add(i), l(t);
    }
};
function n(i) {
    void 0 !== this._$AN ? (o(this), this._$AM = i, r(this)) : this._$AM = i;
}
function h(i, t = !1, e = 0) {
    const r = this._$AH, n = this._$AN;
    if (void 0 !== n && 0 !== n.size) {
        if (t) {
            if (Array.isArray(r)) for(let i1 = e; i1 < r.length; i1++)s(r[i1], !1), o(r[i1]);
            else null != r && (s(r, !1), o(r));
        } else s(this, i);
    }
}
const l = (i)=>{
    var t, s, o, r;
    i.type == (0, _directiveJs.PartType).CHILD && (null !== (t = (o = i)._$AP) && void 0 !== t || (o._$AP = h), null !== (s = (r = i)._$AQ) && void 0 !== s || (r._$AQ = n));
};
class c extends (0, _directiveJs.Directive) {
    constructor(){
        super(...arguments), this._$AN = void 0;
    }
    _$AT(i, t, e) {
        super._$AT(i, t, e), r(this), this.isConnected = i._$AU;
    }
    _$AO(i, t = !0) {
        var e, r;
        i !== this.isConnected && (this.isConnected = i, i ? null === (e = this.reconnected) || void 0 === e || e.call(this) : null === (r = this.disconnected) || void 0 === r || r.call(this)), t && (s(this, i), o(this));
    }
    setValue(t) {
        if ((0, _directiveHelpersJs.isSingleExpression)(this._$Ct)) this._$Ct._$AI(t, this);
        else {
            const i = [
                ...this._$Ct._$AH
            ];
            i[this._$Ci] = t, this._$Ct._$AI(i, this, 0);
        }
    }
    disconnected() {}
    reconnected() {}
}

},{"./directive-helpers.js":"39Xjn","./directive.js":"c1vKO","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"39Xjn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TemplateResultType", ()=>i);
parcelHelpers.export(exports, "clearPart", ()=>a);
parcelHelpers.export(exports, "getCommittedValue", ()=>m);
parcelHelpers.export(exports, "getDirectiveClass", ()=>v);
parcelHelpers.export(exports, "insertPart", ()=>r);
parcelHelpers.export(exports, "isDirectiveResult", ()=>d);
parcelHelpers.export(exports, "isPrimitive", ()=>t);
parcelHelpers.export(exports, "isSingleExpression", ()=>e);
parcelHelpers.export(exports, "isTemplateResult", ()=>n);
parcelHelpers.export(exports, "removePart", ()=>p);
parcelHelpers.export(exports, "setChildPartValue", ()=>u);
parcelHelpers.export(exports, "setCommittedValue", ()=>s);
var _litHtmlJs = require("./lit-html.js");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const { I: l  } = (0, _litHtmlJs._$LH), t = (o)=>null === o || "object" != typeof o && "function" != typeof o, i = {
    HTML: 1,
    SVG: 2
}, n = (o, l)=>void 0 === l ? void 0 !== (null == o ? void 0 : o._$litType$) : (null == o ? void 0 : o._$litType$) === l, d = (o)=>void 0 !== (null == o ? void 0 : o._$litDirective$), v = (o)=>null == o ? void 0 : o._$litDirective$, e = (o)=>void 0 === o.strings, c = ()=>document.createComment(""), r = (o, t, i)=>{
    var n;
    const d = o._$AA.parentNode, v = void 0 === t ? o._$AB : t._$AA;
    if (void 0 === i) {
        const t1 = d.insertBefore(c(), v), n1 = d.insertBefore(c(), v);
        i = new l(t1, n1, o, o.options);
    } else {
        const l1 = i._$AB.nextSibling, t2 = i._$AM, e = t2 !== o;
        if (e) {
            let l2;
            null === (n = i._$AQ) || void 0 === n || n.call(i, o), i._$AM = o, void 0 !== i._$AP && (l2 = o._$AU) !== t2._$AU && i._$AP(l2);
        }
        if (l1 !== v || e) {
            let o1 = i._$AA;
            for(; o1 !== l1;){
                const l3 = o1.nextSibling;
                d.insertBefore(o1, v), o1 = l3;
            }
        }
    }
    return i;
}, u = (o, l, t = o)=>(o._$AI(l, t), o), f = {}, s = (o, l = f)=>o._$AH = l, m = (o)=>o._$AH, p = (o)=>{
    var l;
    null === (l = o._$AP) || void 0 === l || l.call(o, !1, !0);
    let t = o._$AA;
    const i = o._$AB.nextSibling;
    for(; t !== i;){
        const o1 = t.nextSibling;
        t.remove(), t = o1;
    }
}, a = (o)=>{
    o._$AR();
};

},{"./lit-html.js":"ckCvK","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fKOgr":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var constants;
(function(constants) {
    constants.typeOfFunction = "function";
    constants.boolTrue = true;
})(constants || (constants = {}));
function bind(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
    return {
        configurable: constants.boolTrue,
        get: function() {
            var bound = descriptor.value.bind(this);
            // Credits to https://github.com/andreypopp/autobind-decorator for memoizing the result of bind against a symbol on the instance.
            Object.defineProperty(this, propertyKey, {
                value: bound,
                configurable: constants.boolTrue,
                writable: constants.boolTrue
            });
            return bound;
        }
    };
}
exports.bind = bind;
exports.default = bind;

},{}],"80pYq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InputGroupTemplate", ()=>InputGroupTemplate);
var _lit = require("lit");
var _when = require("lit/directives/when");
var _renderStyles = require("../_Core/RenderStyles");
var _buttonTemplate = require("./ButtonTemplate");
var _inputTypes = require("./InputTypes");
var _memoTemplate = require("./MemoTemplate");
var _rangeTemplate = require("./RangeTemplate");
var _textTemplate = require("./TextTemplate");
var _tickboxTemplate = require("./TickboxTemplate");
function InputGroupTemplate(el, type) {
    let hasAppend = false;
    let appendClass = "append right-rounded";
    let hasAppendActive = false;
    let hasPrepend;
    let prependClass = "prepend left-rounded";
    let isBeforeBtn;
    let hasDropdown = false;
    let klass = el.type;
    if (el.renderStyle != (0, _renderStyles.RenderStyles).Default) klass += ` ${el.renderStyle}`;
    let addons = el.querySelectorAll('[slot="append"]');
    if (addons.length > 0) hasAppend = true;
    else if (!el.hasAttribute("slot")) klass += " right-rounded";
    if (el.querySelector('[slot="append-active"]')) hasAppendActive = true;
    let dropdown = el.querySelector('[slot="dropdown"]');
    if (dropdown) {
        hasAppend = true;
        hasDropdown = true;
        klass = klass.replace("right-rounded", "");
    }
    addons = el.querySelectorAll('[slot="prepend"]');
    if (addons.length > 0) hasPrepend = true;
    else if (!el.hasAttribute("slot")) klass += " left-rounded";
    let inputTemplate;
    switch(type){
        case (0, _inputTypes.InputTypes).Button:
            inputTemplate = (0, _buttonTemplate.ButtonTemplate);
            break;
        case (0, _inputTypes.InputTypes).Text:
            inputTemplate = (0, _textTemplate.TextTemplate);
            break;
        case (0, _inputTypes.InputTypes).Range:
            inputTemplate = (0, _rangeTemplate.RangeTemplate);
            break;
        case (0, _inputTypes.InputTypes).Tickbox:
            inputTemplate = (0, _tickboxTemplate.TickboxTemplate);
            break;
        case (0, _inputTypes.InputTypes).Memo:
            inputTemplate = (0, _memoTemplate.MemoTemplate);
        default:
            break;
    }
    return (0, _lit.html)`${(0, _when.when)(hasAppend, ()=>(0, _lit.html)`<div part="input-group" class="input-group">
                    ${hasPrepend ? (0, _lit.html)`<div class="${prependClass}"><slot name="prepend"></slot></div>` : ``}
                    ${inputTemplate(el, klass)}
                    ${hasDropdown ? (0, _lit.html)`<button id="dropdown-toggle" class="${appendClass}" @click="${el.toggleDropdown}"></button>` : (0, _lit.html)`<div class="${appendClass}"><slot name="append"></slot></div>`}
                    ${el.active == true && hasAppendActive ? (0, _lit.html)`<div class="${appendClass}"><slot name="append-active"></slot></div>` : (0, _lit.nothing)}
                </div>`, ()=>inputTemplate(el, klass))}
                ${hasDropdown ? (0, _lit.html)`<div id="dropdown-items" style="display:none"><slot name="dropdown"></slot></div>` : (0, _lit.nothing)}`;
}

},{"lit":"l2dGb","lit/directives/when":"dbNPy","../_Core/RenderStyles":"9FZDh","./ButtonTemplate":"8imRY","./InputTypes":"el4fw","./MemoTemplate":"3rJwt","./RangeTemplate":"5byCG","./TextTemplate":"ftja5","./TickboxTemplate":"VYjr9","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8imRY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ButtonTemplate", ()=>ButtonTemplate);
var _lit = require("lit");
var _ifDefined = require("lit/directives/if-defined");
var _ref = require("lit/directives/ref");
function ButtonTemplate(el, klass) {
    return (0, _lit.html)`<button name="${(0, _ifDefined.ifDefined)(el.name)}" ${(0, _ref.ref)(el.input)}
        type="${el.submit ? "submit" : "button"}" part="button" class="${klass}"
        part="button" @click="${el.onClick}"><slot name="content">${el.label}</slot></button>`;
}

},{"lit":"l2dGb","lit/directives/if-defined":"9nrkg","lit/directives/ref":"8K7tz","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9nrkg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ifDefinedJs = require("lit-html/directives/if-defined.js");
parcelHelpers.exportAll(_ifDefinedJs, exports);

},{"lit-html/directives/if-defined.js":"1Zyzg","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1Zyzg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ifDefined", ()=>l);
var _litHtmlJs = require("../lit-html.js");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const l = (l)=>null != l ? l : (0, _litHtmlJs.nothing);

},{"../lit-html.js":"ckCvK","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"el4fw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InputTypes", ()=>InputTypes);
var InputTypes;
(function(InputTypes) {
    InputTypes[InputTypes["Button"] = 0] = "Button";
    InputTypes[InputTypes["Text"] = 1] = "Text";
    InputTypes[InputTypes["Memo"] = 2] = "Memo";
    InputTypes[InputTypes["Number"] = 3] = "Number";
    InputTypes[InputTypes["Range"] = 4] = "Range";
    InputTypes[InputTypes["Tickbox"] = 5] = "Tickbox";
    InputTypes[InputTypes["Radio"] = 6] = "Radio";
})(InputTypes || (InputTypes = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3rJwt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MemoTemplate", ()=>MemoTemplate);
var _lit = require("lit");
var _ifDefined = require("lit/directives/if-defined");
var _ref = require("lit/directives/ref");
function MemoTemplate(el) {
    return (0, _lit.html)`<label name="${(0, _ifDefined.ifDefined)(el.name)}" part="label" for="text"><slot name="content">${el.label}</slot></label><textarea ${(0, _ref.ref)(el.input)} .value=${(0, _ifDefined.ifDefined)(el.value)}></textarea>`;
}

},{"lit":"l2dGb","lit/directives/if-defined":"9nrkg","lit/directives/ref":"8K7tz","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5byCG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RangeTemplate", ()=>RangeTemplate);
var _lit = require("lit");
var _ifDefined = require("lit/directives/if-defined");
var _ref = require("lit/directives/ref");
function RangeTemplate(el) {
    return (0, _lit.html)`<label name="${(0, _ifDefined.ifDefined)(el.name)}" for="input"><slot name="content">${el.label}</slot></label><input ${(0, _ref.ref)(el.input)} id="input" type="range" .value=${(0, _ifDefined.ifDefined)(el.value)} min="${(0, _ifDefined.ifDefined)(el.min)}" max="${(0, _ifDefined.ifDefined)(el.max)}" step="${(0, _ifDefined.ifDefined)(el.step)}" @change="${el.onChange}">`;
}

},{"lit":"l2dGb","lit/directives/if-defined":"9nrkg","lit/directives/ref":"8K7tz","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ftja5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextTemplate", ()=>TextTemplate);
var _lit = require("lit");
var _ifDefined = require("lit/directives/if-defined");
var _ref = require("lit/directives/ref");
function TextTemplate(el, klass) {
    return (0, _lit.html)`<label name="${(0, _ifDefined.ifDefined)(el.name)}" part="label" for="text"><slot name="content">${el.label}</slot></label>
        <input ${(0, _ref.ref)(el.input)} part="input" .value="${(0, _ifDefined.ifDefined)(el.value)}" .placeholder="${(0, _ifDefined.ifDefined)(el.placeholder)}" class="text" @change="${el.onChange}">`;
}

},{"lit":"l2dGb","lit/directives/if-defined":"9nrkg","lit/directives/ref":"8K7tz","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"VYjr9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TickboxTemplate", ()=>TickboxTemplate);
var _lit = require("lit");
var _ifDefined = require("lit/directives/if-defined");
var _ref = require("lit/directives/ref");
function TickboxTemplate(el) {
    return (0, _lit.html)`<label name="${(0, _ifDefined.ifDefined)(el.name)}" for="input"><slot name="content">${el.label}</slot></label><input ${(0, _ref.ref)(el.input)} type="checkbox" .checked="${el.value}" id="input" @change="${el.onChange}">`;
}

},{"lit":"l2dGb","lit/directives/if-defined":"9nrkg","lit/directives/ref":"8K7tz","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"IEB4b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ButtonEvents", ()=>ButtonEvents);
var ButtonEvents;
(function(ButtonEvents) {
    ButtonEvents["ButtonClicked"] = "button-clicked";
})(ButtonEvents || (ButtonEvents = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"4Gmhr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelText", ()=>JuelText);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _textLess = require("bundle-text:./text.less");
var _textLessDefault = parcelHelpers.interopDefault(_textLess);
var _inputBase = require("../_Base/InputBase");
var _inputGroupTemplate = require("../_Templates/InputGroupTemplate");
var _inputTypes = require("../_Templates/InputTypes");
var _dispatchFunction = require("../_Core/DispatchFunction");
var _eventNames = require("../_Core/Events/EventNames");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelText = class JuelText extends (0, _inputBase.InputBase) {
    constructor(){
        super();
        this.dropdownShown = false;
        this.value = "";
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    onChange(e) {
        let el = e.target;
        this.value = el.value;
        let args = {
            value: this.value
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).Changed, args);
    }
    render() {
        return (0, _inputGroupTemplate.InputGroupTemplate)(this, (0, _inputTypes.InputTypes).Text);
    }
};
JuelText.styles = (0, _lit.unsafeCSS)((0, _textLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelText.prototype, "value", void 0);
__decorate([
    (0, _decorators.property)()
], JuelText.prototype, "placeholder", void 0);
JuelText = __decorate([
    (0, _decorators.customElement)("juel-text")
], JuelText);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./text.less":"2axCs","../_Base/InputBase":"gjQM1","../_Templates/InputGroupTemplate":"80pYq","../_Templates/InputTypes":"el4fw","../_Core/DispatchFunction":"6kMCY","../_Core/Events/EventNames":"eFaYm","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2axCs":[function(require,module,exports) {
module.exports = ".primary {\n  background-color: var(--primary);\n  color: #fff;\n  border: 1px solid var(--primary);\n}\n\n.primary:hover {\n  background-color: #3395ff;\n  border-color: #3395ff;\n}\n\n.primary:active {\n  box-shadow: 0 0 10px var(--primary);\n}\n\n.primary.outline {\n  background-color: initial;\n  color: var(--primary);\n  border-color: var(--primary);\n}\n\n.primary.outline:hover {\n  background-color: var(--primary);\n  color: #fff;\n}\n\n.primary.right-rounded {\n  border-right: 1px solid var(--primary);\n}\n\n.primary.left-rounded {\n  border-left: 1px solid var(--primary);\n}\n\n.secondary {\n  background-color: var(--secondary);\n  color: #fff;\n  border: 1px solid var(--secondary);\n}\n\n.secondary:hover {\n  background-color: #868e96;\n  border-color: #868e96;\n}\n\n.secondary:active {\n  box-shadow: 0 0 10px var(--secondary);\n}\n\n.secondary.outline {\n  background-color: initial;\n  color: var(--secondary);\n  border-color: var(--secondary);\n}\n\n.secondary.outline:hover {\n  background-color: var(--secondary);\n  color: #fff;\n}\n\n.secondary.right-rounded {\n  border-right: 1px solid var(--secondary);\n}\n\n.secondary.left-rounded {\n  border-left: 1px solid var(--secondary);\n}\n\n.tertiary {\n  background-color: var(--tertiary);\n  color: #fff;\n  border: 1px solid var(--tertiary);\n}\n\n.tertiary:hover {\n  background-color: #fcaca3;\n  border-color: #fcaca3;\n}\n\n.tertiary:active {\n  box-shadow: 0 0 10px var(--tertiary);\n}\n\n.tertiary.outline {\n  background-color: initial;\n  color: var(--tertiary);\n  border-color: var(--tertiary);\n}\n\n.tertiary.outline:hover {\n  background-color: var(--tertiary);\n  color: #fff;\n}\n\n.tertiary.right-rounded {\n  border-right: 1px solid var(--tertiary);\n}\n\n.tertiary.left-rounded {\n  border-left: 1px solid var(--tertiary);\n}\n\n.light {\n  background-color: var(--light);\n  color: #000;\n  border: 1px solid var(--light);\n}\n\n.light:hover {\n  background-color: #dae0e5;\n  border-color: #dae0e5;\n}\n\n.light:active {\n  box-shadow: 0 0 10px var(--light);\n}\n\n.light.outline {\n  background-color: initial;\n  color: var(--light);\n  border-color: var(--light);\n}\n\n.light.outline:hover {\n  background-color: var(--light);\n  color: #000;\n}\n\n.light.right-rounded {\n  border-right: 1px solid var(--light);\n}\n\n.light.left-rounded {\n  border-left: 1px solid var(--light);\n}\n\n.dark {\n  background-color: var(--dark);\n  color: #fff;\n  border: 1px solid var(--dark);\n}\n\n.dark:hover {\n  background-color: #4b535c;\n  border-color: #4b535c;\n}\n\n.dark:active {\n  box-shadow: 0 0 10px var(--dark);\n}\n\n.dark.outline {\n  background-color: initial;\n  color: var(--dark);\n  border-color: var(--dark);\n}\n\n.dark.outline:hover {\n  background-color: var(--dark);\n  color: #fff;\n}\n\n.dark.right-rounded {\n  border-right: 1px solid var(--dark);\n}\n\n.dark.left-rounded {\n  border-left: 1px solid var(--dark);\n}\n\n.success {\n  background-color: var(--success);\n  color: #fff;\n  border: 1px solid var(--success);\n}\n\n.success:hover {\n  background-color: #34ce57;\n  border-color: #34ce57;\n}\n\n.success:active {\n  box-shadow: 0 0 10px var(--success);\n}\n\n.success.outline {\n  background-color: initial;\n  color: var(--success);\n  border-color: var(--success);\n}\n\n.success.outline:hover {\n  background-color: var(--success);\n  color: #fff;\n}\n\n.success.right-rounded {\n  border-right: 1px solid var(--success);\n}\n\n.success.left-rounded {\n  border-left: 1px solid var(--success);\n}\n\n.info {\n  background-color: var(--info);\n  color: #fff;\n  border: 1px solid var(--info);\n}\n\n.info:hover {\n  background-color: #1fc8e3;\n  border-color: #1fc8e3;\n}\n\n.info:active {\n  box-shadow: 0 0 10px var(--info);\n}\n\n.info.outline {\n  background-color: initial;\n  color: var(--info);\n  border-color: var(--info);\n}\n\n.info.outline:hover {\n  background-color: var(--info);\n  color: #fff;\n}\n\n.info.right-rounded {\n  border-right: 1px solid var(--info);\n}\n\n.info.left-rounded {\n  border-left: 1px solid var(--info);\n}\n\n.warning {\n  background-color: var(--warning);\n  color: #000;\n  border: 1px solid var(--warning);\n}\n\n.warning:hover {\n  background-color: #d39e00;\n  border-color: #d39e00;\n}\n\n.warning:active {\n  box-shadow: 0 0 10px var(--warning);\n}\n\n.warning.outline {\n  background-color: initial;\n  color: var(--warning);\n  border-color: var(--warning);\n}\n\n.warning.outline:hover {\n  background-color: var(--warning);\n  color: #000;\n}\n\n.warning.right-rounded {\n  border-right: 1px solid var(--warning);\n}\n\n.warning.left-rounded {\n  border-left: 1px solid var(--warning);\n}\n\n.danger {\n  background-color: var(--danger);\n  color: #fff;\n  border: 1px solid var(--danger);\n}\n\n.danger:hover {\n  background-color: #e4606d;\n  border-color: #e4606d;\n}\n\n.danger:active {\n  box-shadow: 0 0 10px var(--danger);\n}\n\n.danger.outline {\n  background-color: initial;\n  color: var(--danger);\n  border-color: var(--danger);\n}\n\n.danger.outline:hover {\n  background-color: var(--danger);\n  color: #fff;\n}\n\n.danger.right-rounded {\n  border-right: 1px solid var(--danger);\n}\n\n.danger.left-rounded {\n  border-left: 1px solid var(--danger);\n}\n\n#dropdown-toggle {\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  border: 1px solid #0000;\n  padding: .375rem .75rem;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  display: inline-block;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n:host {\n  display: inline-block;\n  position: relative;\n}\n\ninput.text {\n  width: 100%;\n}\n\n.input-group {\n  flex-direction: var(--direction, row);\n  background-color: #e9ecef;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  padding: .375rem;\n  display: inline-flex;\n}\n\n.rounded {\n  border-radius: .25rem;\n}\n\n.right-rounded {\n  border-top-right-radius: .25rem;\n  border-bottom-right-radius: .25rem;\n}\n\n.left-rounded {\n  border-top-left-radius: .25rem;\n  border-bottom-left-radius: .25rem;\n}\n\n.no-rounded {\n  border-radius: 0;\n}\n\n#dropdown-items {\n  z-index: 1000;\n  width: 100%;\n  color: #212529;\n  text-align: left;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  font-size: 1rem;\n  display: none;\n  position: absolute;\n}\n\n::slotted(ul) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 1rem;\n  list-style: none;\n  display: flex;\n}\n\n::slotted(ol) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 0;\n  list-style: none;\n  display: flex;\n}\n\n";

},{}],"1yiyr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelMemo", ()=>JuelMemo);
var _decorators = require("lit/decorators");
var _inputBase = require("../_Base/InputBase");
var _dispatchFunction = require("../_Core/DispatchFunction");
var _eventNames = require("../_Core/Events/EventNames");
var _inputGroupTemplate = require("../_Templates/InputGroupTemplate");
var _inputTypes = require("../_Templates/InputTypes");
var _memoLess = require("bundle-text:./Memo.less");
var _memoLessDefault = parcelHelpers.interopDefault(_memoLess);
var _lit = require("lit");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelMemo = class JuelMemo extends (0, _inputBase.InputBase) {
    onChange(e) {
        let el = e.target;
        this.value = el.value;
        let args = {
            value: this.value
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).Changed, args);
    }
    render() {
        return (0, _inputGroupTemplate.InputGroupTemplate)(this, (0, _inputTypes.InputTypes).Memo);
    }
};
JuelMemo.styles = (0, _lit.unsafeCSS)((0, _memoLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelMemo.prototype, "value", void 0);
JuelMemo = __decorate([
    (0, _decorators.customElement)("juel-memo")
], JuelMemo);

},{"lit/decorators":"04xNl","../_Base/InputBase":"gjQM1","../_Core/DispatchFunction":"6kMCY","../_Core/Events/EventNames":"eFaYm","../_Templates/InputGroupTemplate":"80pYq","../_Templates/InputTypes":"el4fw","bundle-text:./Memo.less":"8bXZH","lit":"l2dGb","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8bXZH":[function(require,module,exports) {
module.exports = "\n\n";

},{}],"ex6fn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelRange", ()=>JuelRange);
var _decorators = require("lit/decorators");
var _inputBase = require("../_Base/InputBase");
var _inputGroupTemplate = require("../_Templates/InputGroupTemplate");
var _inputTypes = require("../_Templates/InputTypes");
var _rangeLess = require("bundle-text:./Range.less");
var _rangeLessDefault = parcelHelpers.interopDefault(_rangeLess);
var _lit = require("lit");
var _rippleModule = require("../_Utils/RippleModule");
var _eventNames = require("../_Core/Events/EventNames");
var _dispatchFunction = require("../_Core/DispatchFunction");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelRange = class JuelRange extends (0, _inputBase.InputBase) {
    updated() {
        setTimeout(()=>{
            this.isRipple = getComputedStyle(this).getPropertyValue("--ripple");
            console.log(this.isRipple);
            if (this.isRipple) {
                let btn = this.shadowRoot.firstElementChild;
                this.r = new (0, _rippleModule.RippleInitialiser)(btn);
            }
        });
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    onChange(e) {
        let el = e.target;
        this.value = parseFloat(el.value);
        let args = {
            value: this.value
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).Changed, args);
    }
    render() {
        return (0, _inputGroupTemplate.InputGroupTemplate)(this, (0, _inputTypes.InputTypes).Range);
    }
};
JuelRange.styles = (0, _lit.unsafeCSS)((0, _rangeLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelRange.prototype, "value", void 0);
__decorate([
    (0, _decorators.property)()
], JuelRange.prototype, "min", void 0);
__decorate([
    (0, _decorators.property)()
], JuelRange.prototype, "max", void 0);
__decorate([
    (0, _decorators.property)()
], JuelRange.prototype, "step", void 0);
JuelRange = __decorate([
    (0, _decorators.customElement)("juel-range")
], JuelRange);

},{"lit/decorators":"04xNl","../_Base/InputBase":"gjQM1","../_Templates/InputGroupTemplate":"80pYq","../_Templates/InputTypes":"el4fw","bundle-text:./Range.less":"coFtA","lit":"l2dGb","../_Utils/RippleModule":"9O1q2","../_Core/Events/EventNames":"eFaYm","../_Core/DispatchFunction":"6kMCY","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"coFtA":[function(require,module,exports) {
module.exports = "input[type=\"range\"] {\n  -webkit-appearance: none;\n  width: 100%;\n  background: none;\n}\n\ninput[type=\"range\"]:focus {\n  outline: none;\n}\n\ninput[type=\"range\"]:focus::-webkit-slider-runnable-track {\n  background: var(--secondary);\n}\n\ninput[type=\"range\"]:focus::-ms-fill-upper {\n  background: var(--secondary);\n}\n\ninput[type=\"range\"]:focus::-ms-fill-lower {\n  background: var(--secondary);\n}\n\ninput[type=\"range\"]::-ms-track {\n  width: 100%;\n  cursor: pointer;\n  color: #0000;\n  background: none;\n  border-color: #0000;\n}\n\ninput[type=\"range\"]::-webkit-slider-runnable-track {\n  width: 100%;\n  height: 6px;\n  cursor: pointer;\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 1.3px;\n}\n\ninput[type=\"range\"]::-moz-range-track {\n  width: 100%;\n  height: 6px;\n  cursor: pointer;\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 1.3px;\n}\n\ninput[type=\"range\"]::-ms-track {\n  width: 100%;\n  height: 6px;\n  cursor: pointer;\n  color: #0000;\n  background: none;\n  border-width: 16px 0;\n  border-color: #0000;\n}\n\ninput[type=\"range\"]::-ms-fill-lower {\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 2.6px;\n}\n\ninput[type=\"range\"]::-ms-fill-upper {\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 2.6px;\n}\n\ninput[type=\"range\"]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  height: 24px;\n  width: 24px;\n  background: var(--primary);\n  cursor: pointer;\n  border-radius: 50px;\n  margin-top: -11px;\n}\n\ninput[type=\"range\"]::-moz-range-thumb {\n  height: 24px;\n  width: 24px;\n  background: var(--primary);\n  cursor: pointer;\n  border-radius: 50px;\n}\n\ninput[type=\"range\"]::-ms-thumb {\n  height: 24px;\n  width: 24px;\n  background: var(--primary);\n  cursor: pointer;\n  border-radius: 50px;\n}\n\n";

},{}],"80nuG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelTickbox", ()=>JuelTickbox);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _inputBase = require("../_Base/InputBase");
var _inputGroupTemplate = require("../_Templates/InputGroupTemplate");
var _inputTypes = require("../_Templates/InputTypes");
var _tickboxLess = require("bundle-text:./Tickbox.less");
var _tickboxLessDefault = parcelHelpers.interopDefault(_tickboxLess);
var _dispatchFunction = require("../_Core/DispatchFunction");
var _eventNames = require("../_Core/Events/EventNames");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelTickbox = class JuelTickbox extends (0, _inputBase.InputBase) {
    constructor(){
        super();
        this.value = false;
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    setValue(value) {
        this.value = value;
    }
    onChange(e) {
        let el = e.target;
        this.value = el.checked;
        let args = {
            value: this.value
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).Changed, args);
    }
    render() {
        return (0, _inputGroupTemplate.InputGroupTemplate)(this, (0, _inputTypes.InputTypes).Tickbox);
    }
};
JuelTickbox.styles = (0, _lit.unsafeCSS)((0, _tickboxLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelTickbox.prototype, "value", void 0);
JuelTickbox = __decorate([
    (0, _decorators.customElement)("juel-tickbox")
], JuelTickbox);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Base/InputBase":"gjQM1","../_Templates/InputGroupTemplate":"80pYq","../_Templates/InputTypes":"el4fw","bundle-text:./Tickbox.less":"l9EXZ","../_Core/DispatchFunction":"6kMCY","../_Core/Events/EventNames":"eFaYm","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"l9EXZ":[function(require,module,exports) {
module.exports = ".primary {\n  background-color: var(--primary);\n  color: #fff;\n  border: 1px solid var(--primary);\n}\n\n.primary:hover {\n  background-color: #3395ff;\n  border-color: #3395ff;\n}\n\n.primary:active {\n  box-shadow: 0 0 10px var(--primary);\n}\n\n.primary.outline {\n  background-color: initial;\n  color: var(--primary);\n  border-color: var(--primary);\n}\n\n.primary.outline:hover {\n  background-color: var(--primary);\n  color: #fff;\n}\n\n.primary.right-rounded {\n  border-right: 1px solid var(--primary);\n}\n\n.primary.left-rounded {\n  border-left: 1px solid var(--primary);\n}\n\n.secondary {\n  background-color: var(--secondary);\n  color: #fff;\n  border: 1px solid var(--secondary);\n}\n\n.secondary:hover {\n  background-color: #868e96;\n  border-color: #868e96;\n}\n\n.secondary:active {\n  box-shadow: 0 0 10px var(--secondary);\n}\n\n.secondary.outline {\n  background-color: initial;\n  color: var(--secondary);\n  border-color: var(--secondary);\n}\n\n.secondary.outline:hover {\n  background-color: var(--secondary);\n  color: #fff;\n}\n\n.secondary.right-rounded {\n  border-right: 1px solid var(--secondary);\n}\n\n.secondary.left-rounded {\n  border-left: 1px solid var(--secondary);\n}\n\n.tertiary {\n  background-color: var(--tertiary);\n  color: #fff;\n  border: 1px solid var(--tertiary);\n}\n\n.tertiary:hover {\n  background-color: #fcaca3;\n  border-color: #fcaca3;\n}\n\n.tertiary:active {\n  box-shadow: 0 0 10px var(--tertiary);\n}\n\n.tertiary.outline {\n  background-color: initial;\n  color: var(--tertiary);\n  border-color: var(--tertiary);\n}\n\n.tertiary.outline:hover {\n  background-color: var(--tertiary);\n  color: #fff;\n}\n\n.tertiary.right-rounded {\n  border-right: 1px solid var(--tertiary);\n}\n\n.tertiary.left-rounded {\n  border-left: 1px solid var(--tertiary);\n}\n\n.light {\n  background-color: var(--light);\n  color: #000;\n  border: 1px solid var(--light);\n}\n\n.light:hover {\n  background-color: #dae0e5;\n  border-color: #dae0e5;\n}\n\n.light:active {\n  box-shadow: 0 0 10px var(--light);\n}\n\n.light.outline {\n  background-color: initial;\n  color: var(--light);\n  border-color: var(--light);\n}\n\n.light.outline:hover {\n  background-color: var(--light);\n  color: #000;\n}\n\n.light.right-rounded {\n  border-right: 1px solid var(--light);\n}\n\n.light.left-rounded {\n  border-left: 1px solid var(--light);\n}\n\n.dark {\n  background-color: var(--dark);\n  color: #fff;\n  border: 1px solid var(--dark);\n}\n\n.dark:hover {\n  background-color: #4b535c;\n  border-color: #4b535c;\n}\n\n.dark:active {\n  box-shadow: 0 0 10px var(--dark);\n}\n\n.dark.outline {\n  background-color: initial;\n  color: var(--dark);\n  border-color: var(--dark);\n}\n\n.dark.outline:hover {\n  background-color: var(--dark);\n  color: #fff;\n}\n\n.dark.right-rounded {\n  border-right: 1px solid var(--dark);\n}\n\n.dark.left-rounded {\n  border-left: 1px solid var(--dark);\n}\n\n.success {\n  background-color: var(--success);\n  color: #fff;\n  border: 1px solid var(--success);\n}\n\n.success:hover {\n  background-color: #34ce57;\n  border-color: #34ce57;\n}\n\n.success:active {\n  box-shadow: 0 0 10px var(--success);\n}\n\n.success.outline {\n  background-color: initial;\n  color: var(--success);\n  border-color: var(--success);\n}\n\n.success.outline:hover {\n  background-color: var(--success);\n  color: #fff;\n}\n\n.success.right-rounded {\n  border-right: 1px solid var(--success);\n}\n\n.success.left-rounded {\n  border-left: 1px solid var(--success);\n}\n\n.info {\n  background-color: var(--info);\n  color: #fff;\n  border: 1px solid var(--info);\n}\n\n.info:hover {\n  background-color: #1fc8e3;\n  border-color: #1fc8e3;\n}\n\n.info:active {\n  box-shadow: 0 0 10px var(--info);\n}\n\n.info.outline {\n  background-color: initial;\n  color: var(--info);\n  border-color: var(--info);\n}\n\n.info.outline:hover {\n  background-color: var(--info);\n  color: #fff;\n}\n\n.info.right-rounded {\n  border-right: 1px solid var(--info);\n}\n\n.info.left-rounded {\n  border-left: 1px solid var(--info);\n}\n\n.warning {\n  background-color: var(--warning);\n  color: #000;\n  border: 1px solid var(--warning);\n}\n\n.warning:hover {\n  background-color: #d39e00;\n  border-color: #d39e00;\n}\n\n.warning:active {\n  box-shadow: 0 0 10px var(--warning);\n}\n\n.warning.outline {\n  background-color: initial;\n  color: var(--warning);\n  border-color: var(--warning);\n}\n\n.warning.outline:hover {\n  background-color: var(--warning);\n  color: #000;\n}\n\n.warning.right-rounded {\n  border-right: 1px solid var(--warning);\n}\n\n.warning.left-rounded {\n  border-left: 1px solid var(--warning);\n}\n\n.danger {\n  background-color: var(--danger);\n  color: #fff;\n  border: 1px solid var(--danger);\n}\n\n.danger:hover {\n  background-color: #e4606d;\n  border-color: #e4606d;\n}\n\n.danger:active {\n  box-shadow: 0 0 10px var(--danger);\n}\n\n.danger.outline {\n  background-color: initial;\n  color: var(--danger);\n  border-color: var(--danger);\n}\n\n.danger.outline:hover {\n  background-color: var(--danger);\n  color: #fff;\n}\n\n.danger.right-rounded {\n  border-right: 1px solid var(--danger);\n}\n\n.danger.left-rounded {\n  border-left: 1px solid var(--danger);\n}\n\n#dropdown-toggle {\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  border: 1px solid #0000;\n  padding: .375rem .75rem;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  display: inline-block;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n:host {\n  display: inline-block;\n  position: relative;\n}\n\ninput.text {\n  width: 100%;\n}\n\n.input-group {\n  flex-direction: var(--direction, row);\n  background-color: #e9ecef;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  padding: .375rem;\n  display: inline-flex;\n}\n\n.rounded {\n  border-radius: .25rem;\n}\n\n.right-rounded {\n  border-top-right-radius: .25rem;\n  border-bottom-right-radius: .25rem;\n}\n\n.left-rounded {\n  border-top-left-radius: .25rem;\n  border-bottom-left-radius: .25rem;\n}\n\n.no-rounded {\n  border-radius: 0;\n}\n\n#dropdown-items {\n  z-index: 1000;\n  width: 100%;\n  color: #212529;\n  text-align: left;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  font-size: 1rem;\n  display: none;\n  position: absolute;\n}\n\n::slotted(ul) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 1rem;\n  list-style: none;\n  display: flex;\n}\n\n::slotted(ol) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 0;\n  list-style: none;\n  display: flex;\n}\n\n:host {\n  align-items: center;\n  display: flex;\n}\n\ninput {\n  appearance: none;\n  width: 1em;\n  height: 1em;\n  vertical-align: top;\n  -webkit-print-color-adjust: exact;\n  background-color: #fff;\n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: contain;\n  border: 1px solid #00000040;\n  border-radius: .25em;\n  margin-top: .25em;\n}\n\ninput:checked {\n  background-image: var(--icon-tick);\n  background-color: #0d6efd;\n  border-color: #0d6efd;\n}\n\ninput:focus {\n  border-color: var(--primary);\n  outline: 0;\n  box-shadow: 0 0 12px #add8e6;\n}\n\n";

},{}],"dSYyA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelProgress", ()=>JuelProgress);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _progressLess = require("bundle-text:./Progress.less");
var _progressLessDefault = parcelHelpers.interopDefault(_progressLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelProgress = class JuelProgress extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.type = "line";
        this.value = 0;
    }
    updated(_changedProperties) {
        const circle = this.shadowRoot.querySelector(".progress-ring__circle");
        const radius = circle.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        circle.style.strokeDasharray = `${circumference} ${circumference}`;
        circle.style.strokeDashoffset = circumference.toString();
        const offset = circumference - this.value / 100 * circumference;
        circle.style.strokeDashoffset = offset.toString();
    }
    render() {
        return (0, _lit.html)`${this.type == "ring" ? (0, _lit.html)`
            <svg class="progress-ring" height="120" width="120">
                <circle class="progress-ring__circle" stroke-width="1" fill="transparent" r="58" cx="60" cy="60"/>
            </svg>` : ``}`;
    }
};
JuelProgress.styles = (0, _lit.unsafeCSS)((0, _progressLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelProgress.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelProgress.prototype, "value", void 0);
JuelProgress = __decorate([
    (0, _decorators.customElement)("juel-progress")
], JuelProgress);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Progress.less":"5CHwd","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5CHwd":[function(require,module,exports) {
module.exports = ".progress-ring__circle {\n  stroke-dasharray: 10 20;\n  stroke: var(--stroke, white);\n  transform-origin: 50%;\n  transition: stroke-dashoffset;\n  transform: rotate(-90deg);\n}\n\n";

},{}],"AJydg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelEmbed", ()=>JuelEmbed);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _embedLess = require("bundle-text:./Embed.less");
var _embedLessDefault = parcelHelpers.interopDefault(_embedLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var JuelEmbed_1;
let JuelEmbed = JuelEmbed_1 = class JuelEmbed extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.selector = "body";
    }
    firstUpdated(_changedProperties) {
        if (this.url) fetch(this.url).then((response)=>{
            var contentType = response.headers.get("content-type");
            if (this.type == "markdown" || /markdown/.test(contentType)) response.text().then((data)=>{
                this.processMarkdown(data);
            }).catch((err)=>{
                console.log(err);
            });
            else response.text().then((data)=>{
                let match = data.match(/(?<=<body>)[\s\S]+(?=<\/body>)/);
                if (match && match.length == 1) {
                    let $data = $(match[0]);
                    $(this).append($data);
                    this.requestUpdate();
                }
            });
        });
        else if (this.innerHTML) {
            let data = this.innerHTML;
            this.requestUpdate();
            setTimeout(()=>this.processMarkdown(data), 400);
        }
    }
    processMarkdown(content) {
        let script;
        script = document.head.querySelector("#markdown");
        if (!script) {
            script = document.createElement("script");
            script.id = "markdown";
            script.src = JuelEmbed_1.UrlMarkdown;
            document.head.append(script);
            script.onload = ()=>JuelEmbed_1.markdownFunc(this, content);
        } else setTimeout(()=>JuelEmbed_1.markdownFunc(this, content), 400);
    }
    createRenderRoot() {
        return this;
    }
};
JuelEmbed.styles = (0, _lit.unsafeCSS)((0, _embedLessDefault.default));
JuelEmbed.UrlMarkdown = "https://cdn.jsdelivr.net/npm/marked/marked.min.js";
JuelEmbed.HlJs = "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js";
JuelEmbed.HlJsStyles = "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/default.min.css";
JuelEmbed.HlJsStylesRoot = "https://cdn.jsdelivr.net/npm/highlight.js/styles/";
JuelEmbed.markdownFunc = (em, content)=>{
    if ("marked" in window) {
        em.innerHTML = marked.parse(content);
        em.requestUpdate();
        if ("hljs" in window) setTimeout(()=>hljs.highlightAll(), 400);
        else {
            let styles = document.createElement("link");
            styles.setAttribute("rel", "stylesheet");
            styles.setAttribute("href", JuelEmbed_1.HlJsStyles);
            document.head.append(styles);
            let script = document.createElement("script");
            script.src = JuelEmbed_1.HlJs;
            document.head.append(script);
            setTimeout(()=>{
                hljs.highlightAll();
            }, 400);
        }
        if (em.theme) {
            let id = `hljs-theme-${em.theme}`;
            let style = document.head.querySelector(`#${id}`);
            if (!style) {
                style = document.createElement("link");
                style.id = id;
                style.setAttribute("rel", "stylesheet");
                style.setAttribute("href", `${JuelEmbed_1.HlJsStylesRoot}${em.theme}.css`);
                document.head.append(style);
            }
        }
    }
};
__decorate([
    (0, _decorators.property)()
], JuelEmbed.prototype, "url", void 0);
__decorate([
    (0, _decorators.property)()
], JuelEmbed.prototype, "selector", void 0);
__decorate([
    (0, _decorators.property)()
], JuelEmbed.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)()
], JuelEmbed.prototype, "theme", void 0);
JuelEmbed = JuelEmbed_1 = __decorate([
    (0, _decorators.customElement)("juel-embed")
], JuelEmbed);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Embed.less":"aSn4E","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aSn4E":[function(require,module,exports) {
module.exports = ":host {\n  width: 100%;\n  height: 100%;\n}\n\n";

},{}],"bJejc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelRandom", ()=>JuelRandom);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _choose = require("lit/directives/choose");
var _ref = require("lit/directives/ref");
var _randomLess = require("bundle-text:./Random.less");
var _randomLessDefault = parcelHelpers.interopDefault(_randomLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelRandom = class JuelRandom extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.elementRef = (0, _ref.createRef)();
        this.type = "img";
        this.trigger = "load";
    }
    firstUpdated() {
        if (this.values) switch(this.trigger){
            case "load":
                this.setValue();
                break;
            default:
                let interval;
                if (this.trigger.endsWith("s")) interval = parseFloat(this.trigger.replace("s", "")) * 1000;
                if (interval) setInterval(()=>{
                    this.setValue();
                }, interval);
                break;
        }
    }
    setValue() {
        let splitty = this.values.split(" ");
        this.value = splitty[Math.floor(Math.random() * splitty.length)];
    }
    updated() {
        if (this.elementRef.value) {
            let el = this.elementRef.value;
            el.load();
            if (el.hasAttribute("autoplay")) el.play();
        }
    }
    render() {
        return (0, _lit.html)`${(0, _choose.choose)(this.type, [
            [
                "img",
                ()=>(0, _lit.html)`<img src="${this.value}" />`
            ],
            [
                "video",
                ()=>(0, _lit.html)`<video ${(0, _ref.ref)(this.elementRef)} autoplay loop muted><source src="${this.value}"></video>`
            ]
        ])}`;
    }
};
JuelRandom.styles = (0, _lit.unsafeCSS)((0, _randomLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelRandom.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)()
], JuelRandom.prototype, "values", void 0);
__decorate([
    (0, _decorators.property)()
], JuelRandom.prototype, "trigger", void 0);
__decorate([
    (0, _decorators.property)()
], JuelRandom.prototype, "value", void 0);
JuelRandom = __decorate([
    (0, _decorators.customElement)("juel-random")
], JuelRandom);

},{"lit":"l2dGb","lit/decorators":"04xNl","lit/directives/choose":"2OXsE","lit/directives/ref":"8K7tz","bundle-text:./Random.less":"g39qp","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2OXsE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _chooseJs = require("lit-html/directives/choose.js");
parcelHelpers.exportAll(_chooseJs, exports);

},{"lit-html/directives/choose.js":"2dldF","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2dldF":[function(require,module,exports) {
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "choose", ()=>o);
const o = (o, r, n)=>{
    for (const n1 of r)if (n1[0] === o) return (0, n1[1])();
    return null == n ? void 0 : n();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"g39qp":[function(require,module,exports) {
module.exports = ":host {\n  display: inline-block;\n}\n\nvideo {\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n}\n\n";

},{}],"9ZBpR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelNav", ()=>JuelNav);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _childrenMap = require("../_Utils/ChildrenMap");
var _navLess = require("bundle-text:./Nav.less");
var _navLessDefault = parcelHelpers.interopDefault(_navLess);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelNav = class JuelNav extends (0, _lit.LitElement) {
    constructor(){
        super(...arguments);
        this.toggle = false;
        this.sticky = false;
    }
    firstUpdated() {
        setTimeout(()=>{
            this.requestUpdate();
            setTimeout(()=>{
                if (this.sticky == true && !window.isMobile) {
                    let nav = this.shadowRoot.querySelector("nav");
                    let title = nav.querySelector(".title");
                    var navOffset = nav.offsetTop;
                    window.addEventListener("scroll", ()=>{
                        if (window.pageYOffset >= navOffset + 10) {
                            nav.classList.add("sticky");
                            title.setAttribute("part", "title-sticky");
                        } else {
                            nav.classList.remove("sticky");
                            title.setAttribute("part", "title");
                        }
                    });
                }
            });
        });
    }
    toggleClick(e) {
        e.stopImmediatePropagation();
        let el = this.shadowRoot.getElementById("nav");
        el.classList.toggle("open");
        if (el.classList.contains("open")) {
            if (this.push) {
                let css = {};
                css["transition"] = "margin 2s";
                $(this.push).css(css);
            }
        } else if (this.push) {
            let css1 = {};
            $(this.push).css(css1);
        }
    }
    render() {
        return (0, _lit.html)`
            <nav id="nav">
            <div part="title" class="title">
                <slot name="title">
                    <h1>${this.title}</h1>
                </slot>
                <div id="toggle" class="${this.toggle == true ? "shown" : ""}" @click="${this.toggleClick}">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div id="items" part="items" class="${this.side ? `side ${this.side}` : ""}">
            ${(0, _childrenMap.ChildrenMap)(this, (el, index)=>{
            if (el.getAttribute("slot") != "title") {
                let id = el.id ? el.id : `item-${index}`;
                el.setAttribute("slot", id);
                let klass = "item";
                if (this.selected && this.selected == index) klass += " selected";
                return (0, _lit.html)`
                    <div class="${klass}" data-index="${index}">
                    <slot name="${id}"></slot>
                    </div>`;
            } else return (0, _lit.html)``;
        }, '[slot="title"],[slot="addon"]')}
            </div>
            <div class="addon">
            <slot name="addon"></slot>
            </div>
            </nav>
        `;
    }
};
JuelNav.styles = (0, _lit.unsafeCSS)((0, _navLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelNav.prototype, "toggle", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelNav.prototype, "sticky", void 0);
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelNav.prototype, "side", void 0);
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelNav.prototype, "push", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelNav.prototype, "selected", void 0);
JuelNav = __decorate([
    (0, _decorators.customElement)("juel-nav")
], JuelNav);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Utils/ChildrenMap":"hG10d","bundle-text:./Nav.less":"3Rh4Y","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3Rh4Y":[function(require,module,exports) {
module.exports = ":host {\n  width: 100%;\n  height: 100px;\n  background-color: var(--background-colour);\n  margin-bottom: 10px;\n  display: block;\n}\n\nnav {\n  align-items: baseline;\n  justify-content: var(--justify, flex-start);\n  padding-left: var(--padding-left);\n  padding-right: var(--padding-right);\n  background-color: var(--background-colour);\n  flex-flow: wrap;\n  display: flex;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n\n@media screen and (max-width: 500px) {\n  nav {\n    padding-left: initial;\n    padding-right: initial;\n    background-color: #0000;\n    flex-direction: column;\n    justify-content: flex-start;\n    bottom: 0;\n  }\n\n  nav div {\n    flex-grow: .1;\n  }\n}\n\nnav.open #items {\n  flex: 1;\n}\n\nnav.open span:nth-child(1) {\n  transform: translateY(5px)rotate(45deg);\n}\n\nnav.open span:nth-child(2) {\n  opacity: 0;\n}\n\nnav.open span:nth-child(3) {\n  transform: translateY(-5px)rotate(-45deg);\n}\n\nnav.open #items.side.left, nav.open #items.side.right {\n  flex: 1;\n}\n\n@media screen and (max-width: 500px) {\n  nav.open #items.side {\n    max-height: calc(100 * var(--vh));\n  }\n}\n\nnav .title {\n  white-space: nowrap;\n  margin-right: 1rem;\n  padding-top: .3125rem;\n  padding-bottom: .3125rem;\n  font-size: 1.25rem;\n  text-decoration: none;\n}\n\nnav .title * {\n  display: inline-block;\n}\n\n@media screen and (max-width: 500px) {\n  nav .title {\n    margin-right: initial;\n    flex-direction: column;\n  }\n}\n\nnav #items {\n  align-items: baseline;\n  display: flex;\n  overflow: visible;\n}\n\nnav #items.side.left {\n  order: -1;\n}\n\nnav #items.side.right {\n  order: 1;\n}\n\n@media screen and (max-width: 500px) {\n  nav #items {\n    width: 100%;\n    flex-direction: column;\n    flex: 0;\n    transition: flex 1.5s;\n    overflow-y: auto;\n    order: 1 !important;\n  }\n}\n\nnav .item {\n  flex-shrink: 1;\n  flex-basis: 0;\n  padding-left: .75rem;\n  padding-right: .75rem;\n  display: block;\n}\n\nnav .addon ::slotted(*) {\n  display: flex;\n}\n\n#toggle {\n  width: 32px;\n  height: 64px;\n  cursor: pointer;\n  color: #0000008c;\n  background-color: #0000;\n  border: 1px solid #0000;\n  border-radius: .25rem;\n  padding: .25rem .75rem;\n  font-size: 1.25rem;\n  line-height: 1;\n  transition: box-shadow .15s ease-in-out;\n  display: none;\n  position: relative;\n}\n\n@media screen and (max-width: 500px) {\n  #toggle {\n    display: inline-block;\n  }\n\n  #toggle + #items.side {\n    position: relative;\n  }\n\n  #toggle + #items.side.open + #items.side {\n    max-height: calc(100 * var(--vh));\n  }\n\n  #toggle {\n    display: inline-block;\n  }\n}\n\n#toggle span {\n  height: 1px;\n  transform-origin: center;\n  width: 16px;\n  background-color: currentColor;\n  transition-property: background-color, opacity, transform;\n  transition-duration: 86ms;\n  transition-timing-function: ease-out;\n  display: block;\n  position: absolute;\n  left: calc(50% - 8px);\n}\n\n#toggle span:nth-child(1) {\n  top: calc(50% - 6px);\n}\n\n#toggle span:nth-child(2) {\n  top: calc(50% - 1px);\n}\n\n#toggle span:nth-child(3) {\n  top: calc(50% + 4px);\n}\n\n";

},{}],"liS0w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelChart", ()=>JuelChart);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _juelComponent = require("../_Base/JuelComponent");
var _arrayConverter = require("../_Converters/ArrayConverter");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var JuelChart_1;
let JuelChart = JuelChart_1 = class JuelChart extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.width = 400;
        this.height = 400;
        this.type = "bar";
        this.data = {};
        this.options = {};
    }
    updated(_changedProperties) {
        this.data.labels = this.labels;
        let plugins = {};
        if (this.legend) {
            if (this.legend == "false") plugins.legend = {
                display: false
            };
            else plugins.legend = {
                position: this.legend
            };
        }
        if (this.title) plugins.title = {
            display: true,
            text: this.title
        };
        this.options.responsive = this.responsive;
        if (this.indexAxis) this.options.indexAxis = this.indexAxis;
        if (plugins) this.options.plugins = plugins;
        this.g = this.shadowRoot.getElementById("canvas").getContext("2d");
        this.scriptElement();
    }
    scriptElement() {
        let script = document.querySelector(`#${JuelChart_1.ChartScriptId}`);
        if ("Chart" in window || script) this.chartScriptLoaded = new Promise((resolve)=>{
            script.addEventListener("load", ()=>{
                resolve(1);
            });
        });
        else {
            script = document.createElement("script");
            script.id = JuelChart_1.ChartScriptId;
            this.chartScriptLoaded = new Promise((resolve)=>{
                script.addEventListener("load", ()=>{
                    resolve(1);
                });
            });
            script.src = JuelChart_1.ChartScriptUrl;
            document.head.append(script);
        }
    }
    renderChart() {
        this.chartScriptLoaded.then(()=>{
            let ChartFunc = window["Chart"];
            let config = {
                type: this.type,
                data: this.data,
                options: this.options
            };
            if (!this.chart) this.chart = new ChartFunc(this.g, config);
            else {
                this.chart.data = this.data;
                this.chart.update();
            }
        });
    }
    render() {
        return (0, _lit.html)`<canvas id="canvas" width="${this.width}" height="${this.height}""></canvas>`;
    }
};
JuelChart.ChartScriptId = "juel-chart-js";
JuelChart.ChartScriptUrl = "https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js";
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelChart.prototype, "width", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelChart.prototype, "height", void 0);
__decorate([
    (0, _decorators.property)()
], JuelChart.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        converter: (0, _arrayConverter.ArrayConverter)(",")
    })
], JuelChart.prototype, "labels", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelChart.prototype, "responsive", void 0);
__decorate([
    (0, _decorators.property)()
], JuelChart.prototype, "legend", void 0);
__decorate([
    (0, _decorators.property)()
], JuelChart.prototype, "indexAxis", void 0);
__decorate([
    (0, _decorators.property)({
        type: Object
    })
], JuelChart.prototype, "data", void 0);
__decorate([
    (0, _decorators.property)({
        type: Object
    })
], JuelChart.prototype, "options", void 0);
JuelChart = JuelChart_1 = __decorate([
    (0, _decorators.customElement)("juel-chart")
], JuelChart);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Base/JuelComponent":"bVHZk","../_Converters/ArrayConverter":"kTirk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"kTirk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ArrayConverter", ()=>ArrayConverter);
function GetValue(val) {
    let num = parseFloat(val);
    if (!isNaN(num)) return num;
    else if (val == "true") return true;
    else if (val == "false") return false;
    else if (val.includes(";")) {
        let kv = val.split(";");
        let obj = {};
        for (let str of kv){
            let spit = str.split(":");
            obj[spit[0]] = spit[1];
        }
        return obj;
    } else return val.trim();
}
function ArrayConverter(separator = " ") {
    return (value)=>{
        if (value.includes(separator)) {
            let splitty = value.split(separator);
            return splitty.map((val)=>{
                return GetValue(val);
            });
        } else return [
            GetValue(value)
        ];
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"k8p14":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelChartDataSet", ()=>JuelChartDataSet);
var _decorators = require("lit/decorators");
var _commandBase = require("../_Base/CommandBase");
var _arrayConverter = require("../_Converters/ArrayConverter");
var _booleanConverter = require("../_Converters/BooleanConverter");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelChartDataSet = class JuelChartDataSet extends (0, _commandBase.CommandBase) {
    updated() {
        if (this.parentElement.nodeName == "JUEL-CHART") {
            let dataset = {};
            dataset["label"] = this.label;
            dataset["data"] = this.data;
            dataset["type"] = this.type;
            dataset["backgroundColor"] = this.backgroundColour;
            dataset["backgroundColorHover"] = this.backgroundColourHover;
            dataset["borderColor"] = this.borderColour;
            dataset["borderWidth"] = this.borderWidth;
            dataset["fill"] = this.fill;
            dataset["pointBorderColor"] = this.pointBorderColour;
            dataset["pointBackgroundColor"] = this.pointBackgroundColour;
            let chart = this.parentElement;
            if (chart.data) {
                if (!chart.data.datasets || chart.data.datasets.length == 0) chart.data.datasets = [];
                chart.data.datasets.push(dataset);
                chart.renderChart();
            }
        }
    }
};
__decorate([
    (0, _decorators.property)()
], JuelChartDataSet.prototype, "label", void 0);
__decorate([
    (0, _decorators.property)({
        converter: (0, _arrayConverter.ArrayConverter)()
    })
], JuelChartDataSet.prototype, "data", void 0);
__decorate([
    (0, _decorators.property)()
], JuelChartDataSet.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        converter: (0, _arrayConverter.ArrayConverter)(),
        attribute: "background-colour"
    })
], JuelChartDataSet.prototype, "backgroundColour", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "background-colour-hover"
    })
], JuelChartDataSet.prototype, "backgroundColourHover", void 0);
__decorate([
    (0, _decorators.property)({
        converter: (0, _arrayConverter.ArrayConverter)(),
        attribute: "border-colour"
    })
], JuelChartDataSet.prototype, "borderColour", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelChartDataSet.prototype, "borderWidth", void 0);
__decorate([
    (0, _decorators.property)({
        converter: (0, _booleanConverter.BooleanConverter)
    })
], JuelChartDataSet.prototype, "fill", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "point-border-colour"
    })
], JuelChartDataSet.prototype, "pointBorderColour", void 0);
__decorate([
    (0, _decorators.property)({
        attribute: "point-background-colour"
    })
], JuelChartDataSet.prototype, "pointBackgroundColour", void 0);
JuelChartDataSet = __decorate([
    (0, _decorators.customElement)("juel-chart-dataset")
], JuelChartDataSet);

},{"lit/decorators":"04xNl","../_Base/CommandBase":"fIGUY","../_Converters/ArrayConverter":"kTirk","../_Converters/BooleanConverter":"imtJZ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fIGUY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommandBase", ()=>CommandBase);
var _lit = require("lit");
class CommandBase extends (0, _lit.LitElement) {
    getParentComponent() {
        if (this.parentElement) {
            if ("getParentComponent" in this.parentElement) return this.parentElement["getParentComponent"]();
            else return this.parentElement;
        }
    }
    createRenderRoot() {
        return this;
    }
}

},{"lit":"l2dGb","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"imtJZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BooleanConverter", ()=>BooleanConverter);
function BooleanConverter(value) {
    if (value == "true") return true;
    else return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"4OQeM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DraggableContainer", ()=>DraggableContainer);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _dragMoveListener = require("../_Utils/DragMoveListener");
var _emojiRegex = require("../_Utils/EmojiRegex");
var _interactjs = require("@interactjs/interactjs");
var _interactjsDefault = parcelHelpers.interopDefault(_interactjs);
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DraggableContainer = class DraggableContainer extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        if (!("interact" in window)) window["interact"] = (0, _interactjsDefault.default);
    }
    firstLoad() {
        let html = this.innerHTML;
        html = html.replaceAll((0, _emojiRegex.emojiRegex), "<div>$1</div>");
        this.innerHTML = html;
        (0, _interactjsDefault.default)("juel-draggable *").draggable({
            listeners: {
                move: (0, _dragMoveListener.DragMoveListener)
            }
        });
    }
    render() {
        return (0, _lit.html)`<div>
            <slot></slot>
        <div>`;
    }
};
DraggableContainer = __decorate([
    (0, _decorators.customElement)("juel-draggable")
], DraggableContainer);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Utils/DragMoveListener":"8liSL","../_Utils/EmojiRegex":"aQZX7","@interactjs/interactjs":"2Enrh","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8liSL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DragMoveListener", ()=>DragMoveListener);
function DragMoveListener(event) {
    var target = $(event.target);
    var x = (parseFloat(target.data("x")) || 0) + event.dx;
    var y = (parseFloat(target.data("y")) || 0) + event.dy;
    target.css("transform", `translate(${x}px, ${y}px)`);
    target.data("x", x);
    target.data("y", y);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aQZX7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "emojiRegex", ()=>emojiRegex);
var emojiRegex = /(\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/g;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2Enrh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pluginJs = require("../actions/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _pluginJs1 = require("../auto-scroll/plugin.js");
var _pluginJsDefault1 = parcelHelpers.interopDefault(_pluginJs1);
var _pluginJs2 = require("../auto-start/plugin.js");
var _pluginJsDefault2 = parcelHelpers.interopDefault(_pluginJs2);
var _interactablePreventDefaultJs = require("../core/interactablePreventDefault.js");
var _interactablePreventDefaultJsDefault = parcelHelpers.interopDefault(_interactablePreventDefaultJs);
var _pluginJs3 = require("../dev-tools/plugin.js");
var _pluginJsDefault3 = parcelHelpers.interopDefault(_pluginJs3);
var _pluginJs4 = require("../inertia/plugin.js");
var _pluginJsDefault4 = parcelHelpers.interopDefault(_pluginJs4);
var _indexJs = require("../interact/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _pluginJs5 = require("../modifiers/plugin.js");
var _pluginJsDefault5 = parcelHelpers.interopDefault(_pluginJs5);
var _pluginJs6 = require("../offset/plugin.js");
var _pluginJsDefault6 = parcelHelpers.interopDefault(_pluginJs6);
var _pluginJs7 = require("../pointer-events/plugin.js");
var _pluginJsDefault7 = parcelHelpers.interopDefault(_pluginJs7);
var _pluginJs8 = require("../reflow/plugin.js");
var _pluginJsDefault8 = parcelHelpers.interopDefault(_pluginJs8);
(0, _indexJsDefault.default).use((0, _interactablePreventDefaultJsDefault.default));
(0, _indexJsDefault.default).use((0, _pluginJsDefault6.default)); // pointerEvents
(0, _indexJsDefault.default).use((0, _pluginJsDefault7.default)); // inertia
(0, _indexJsDefault.default).use((0, _pluginJsDefault4.default)); // snap, resize, etc.
(0, _indexJsDefault.default).use((0, _pluginJsDefault5.default)); // autoStart, hold
(0, _indexJsDefault.default).use((0, _pluginJsDefault2.default)); // drag and drop, resize, gesture
(0, _indexJsDefault.default).use((0, _pluginJsDefault.default)); // autoScroll
(0, _indexJsDefault.default).use((0, _pluginJsDefault1.default)); // reflow
(0, _indexJsDefault.default).use((0, _pluginJsDefault8.default)); // eslint-disable-next-line no-undef
(0, _indexJsDefault.default).use((0, _pluginJsDefault3.default));
exports.default = (0, _indexJsDefault.default);
if (!!module) try {
    module.exports = (0, _indexJsDefault.default);
} catch (_unused) {}
(0, _indexJsDefault.default).default = (0, _indexJsDefault.default);

},{"../actions/plugin.js":"t7D0h","../auto-scroll/plugin.js":"aqXqX","../auto-start/plugin.js":"54BtV","../core/interactablePreventDefault.js":"bzEAu","../dev-tools/plugin.js":"cnVWp","../inertia/plugin.js":"e5sCX","../interact/index.js":"dQbVM","../modifiers/plugin.js":"jtg1V","../offset/plugin.js":"9Nc0j","../pointer-events/plugin.js":"1Qpuq","../reflow/plugin.js":"iia1Q","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"t7D0h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pluginJs = require("./drag/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _pluginJs1 = require("./drop/plugin.js");
var _pluginJsDefault1 = parcelHelpers.interopDefault(_pluginJs1);
var _pluginJs2 = require("./gesture/plugin.js");
var _pluginJsDefault2 = parcelHelpers.interopDefault(_pluginJs2);
var _pluginJs3 = require("./resize/plugin.js");
var _pluginJsDefault3 = parcelHelpers.interopDefault(_pluginJs3);
exports.default = {
    id: "actions",
    install (scope) {
        scope.usePlugin((0, _pluginJsDefault2.default));
        scope.usePlugin((0, _pluginJsDefault3.default));
        scope.usePlugin((0, _pluginJsDefault.default));
        scope.usePlugin((0, _pluginJsDefault1.default));
    }
};

},{"./drag/plugin.js":"gQF8D","./drop/plugin.js":"1dxLP","./gesture/plugin.js":"bjxX6","./resize/plugin.js":"llJs7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"gQF8D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
function install(scope) {
    const { actions , Interactable , defaults  } = scope;
    Interactable.prototype.draggable = drag.draggable;
    actions.map.drag = drag;
    actions.methodDict.drag = "draggable";
    defaults.actions.drag = drag.defaults;
}
function beforeMove({ interaction  }) {
    if (interaction.prepared.name !== "drag") return;
    const axis = interaction.prepared.axis;
    if (axis === "x") {
        interaction.coords.cur.page.y = interaction.coords.start.page.y;
        interaction.coords.cur.client.y = interaction.coords.start.client.y;
        interaction.coords.velocity.client.y = 0;
        interaction.coords.velocity.page.y = 0;
    } else if (axis === "y") {
        interaction.coords.cur.page.x = interaction.coords.start.page.x;
        interaction.coords.cur.client.x = interaction.coords.start.client.x;
        interaction.coords.velocity.client.x = 0;
        interaction.coords.velocity.page.x = 0;
    }
}
function move({ iEvent , interaction  }) {
    if (interaction.prepared.name !== "drag") return;
    const axis = interaction.prepared.axis;
    if (axis === "x" || axis === "y") {
        const opposite = axis === "x" ? "y" : "x";
        iEvent.page[opposite] = interaction.coords.start.page[opposite];
        iEvent.client[opposite] = interaction.coords.start.client[opposite];
        iEvent.delta[opposite] = 0;
    }
}
/**
 * ```js
 * interact(element).draggable({
 *     onstart: function (event) {},
 *     onmove : function (event) {},
 *     onend  : function (event) {},
 *
 *     // the axis in which the first movement must be
 *     // for the drag sequence to start
 *     // 'xy' by default - any direction
 *     startAxis: 'x' || 'y' || 'xy',
 *
 *     // 'xy' by default - don't restrict to one axis (move in any direction)
 *     // 'x' or 'y' to restrict movement to either axis
 *     // 'start' to restrict movement to the axis the drag started in
 *     lockAxis: 'x' || 'y' || 'xy' || 'start',
 *
 *     // max number of drags that can happen concurrently
 *     // with elements of this Interactable. Infinity by default
 *     max: Infinity,
 *
 *     // max number of drags that can target the same element+Interactable
 *     // 1 by default
 *     maxPerElement: 2
 * })
 *
 * var isDraggable = interact('element').draggable(); // true
 * ```
 *
 * Get or set whether drag actions can be performed on the target
 *
 * @alias Interactable.prototype.draggable
 *
 * @param {boolean | object} [options] true/false or An object with event
 * listeners to be fired on drag events (object makes the Interactable
 * draggable)
 * @return {boolean | Interactable} boolean indicating if this can be the
 * target of drag events, or this Interctable
 */ const draggable = function draggable(options) {
    if ((0, _isJsDefault.default).object(options)) {
        this.options.drag.enabled = options.enabled !== false;
        this.setPerAction("drag", options);
        this.setOnEvents("drag", options);
        if (/^(xy|x|y|start)$/.test(options.lockAxis)) this.options.drag.lockAxis = options.lockAxis;
        if (/^(xy|x|y)$/.test(options.startAxis)) this.options.drag.startAxis = options.startAxis;
        return this;
    }
    if ((0, _isJsDefault.default).bool(options)) {
        this.options.drag.enabled = options;
        return this;
    }
    return this.options.drag;
};
const drag = {
    id: "actions/drag",
    install,
    listeners: {
        "interactions:before-action-move": beforeMove,
        "interactions:action-resume": beforeMove,
        // dragmove
        "interactions:action-move": move,
        "auto-start:check": (arg)=>{
            const { interaction , interactable , buttons  } = arg;
            const dragOptions = interactable.options.drag;
            if (!(dragOptions && dragOptions.enabled) || // check mouseButton setting if the pointer is down
            interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options.drag.mouseButtons) === 0) return undefined;
            arg.action = {
                name: "drag",
                axis: dragOptions.lockAxis === "start" ? dragOptions.startAxis : dragOptions.lockAxis
            };
            return false;
        }
    },
    draggable,
    beforeMove,
    move,
    defaults: {
        startAxis: "xy",
        lockAxis: "xy"
    },
    getCursor () {
        return "move";
    }
};
exports.default = drag;

},{"../../utils/is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iRtxa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isWindowJs = require("./isWindow.js");
var _isWindowJsDefault = parcelHelpers.interopDefault(_isWindowJs);
var _windowJs = require("./window.js");
const window = (thing)=>thing === _windowJs.window || (0, _isWindowJsDefault.default)(thing);
const docFrag = (thing)=>object(thing) && thing.nodeType === 11;
const object = (thing)=>!!thing && typeof thing === "object";
const func = (thing)=>typeof thing === "function";
const number = (thing)=>typeof thing === "number";
const bool = (thing)=>typeof thing === "boolean";
const string = (thing)=>typeof thing === "string";
const element = (thing)=>{
    if (!thing || typeof thing !== "object") return false;
    const _window = _windowJs.getWindow(thing) || _windowJs.window;
    return /object|function/.test(typeof Element) ? thing instanceof Element || thing instanceof _window.Element : thing.nodeType === 1 && typeof thing.nodeName === "string";
};
const plainObject = (thing)=>object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());
const array = (thing)=>object(thing) && typeof thing.length !== "undefined" && func(thing.splice);
exports.default = {
    window,
    docFrag,
    object,
    func,
    number,
    bool,
    string,
    element,
    plainObject,
    array
};

},{"./isWindow.js":"3i1s5","./window.js":"lQsRi","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3i1s5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = (thing)=>!!(thing && thing.Window) && thing instanceof thing.Window;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lQsRi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "realWindow", ()=>realWindow);
parcelHelpers.export(exports, "window", ()=>win);
parcelHelpers.export(exports, "init", ()=>init);
parcelHelpers.export(exports, "getWindow", ()=>getWindow);
var _isWindowJs = require("./isWindow.js");
var _isWindowJsDefault = parcelHelpers.interopDefault(_isWindowJs);
let realWindow = undefined;
let win = undefined;
function init(window1) {
    // get wrapped window if using Shadow DOM polyfill
    realWindow = window1; // create a TextNode
    const el = window1.document.createTextNode(""); // check if it's wrapped by a polyfill
    if (el.ownerDocument !== window1.document && typeof window1.wrap === "function" && window1.wrap(el) === el) // use wrapped window
    window1 = window1.wrap(window1);
    win = window1;
}
if (typeof window !== "undefined" && !!window) init(window);
function getWindow(node) {
    if ((0, _isWindowJsDefault.default)(node)) return node;
    const rootNode = node.ownerDocument || node;
    return rootNode.defaultView || win.window;
}

},{"./isWindow.js":"3i1s5","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1dxLP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domUtilsJs = require("../../utils/domUtils.js");
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _getOriginXYJs = require("../../utils/getOriginXY.js");
var _getOriginXYJsDefault = parcelHelpers.interopDefault(_getOriginXYJs);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _normalizeListenersJs = require("../../utils/normalizeListeners.js");
var _normalizeListenersJsDefault = parcelHelpers.interopDefault(_normalizeListenersJs);
var _pointerUtilsJs = require("../../utils/pointerUtils.js");
var _pluginJs = require("../drag/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _dropEventJs = require("./DropEvent.js");
function install(scope) {
    const { actions , /** @lends module:interact */ interactStatic: interact , /** @lends Interactable */ Interactable , defaults  } = scope;
    scope.usePlugin((0, _pluginJsDefault.default));
    /**
   *
   * ```js
   * interact('.drop').dropzone({
   *   accept: '.can-drop' || document.getElementById('single-drop'),
   *   overlap: 'pointer' || 'center' || zeroToOne
   * }
   * ```
   *
   * Returns or sets whether draggables can be dropped onto this target to
   * trigger drop events
   *
   * Dropzones can receive the following events:
   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends
   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone
   *  - `dragmove` when a draggable that has entered the dropzone is moved
   *  - `drop` when a draggable is dropped into this dropzone
   *
   * Use the `accept` option to allow only elements that match the given CSS
   * selector or element. The value can be:
   *
   *  - **an Element** - only that element can be dropped into this dropzone.
   *  - **a string**, - the element being dragged must match it as a CSS selector.
   *  - **`null`** - accept options is cleared - it accepts any element.
   *
   * Use the `overlap` option to set how drops are checked for. The allowed
   * values are:
   *
   *   - `'pointer'`, the pointer must be over the dropzone (default)
   *   - `'center'`, the draggable element's center must be over the dropzone
   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.
   *   e.g. `0.5` for drop to happen when half of the area of the draggable is
   *   over the dropzone
   *
   * Use the `checker` option to specify a function to check if a dragged element
   * is over this Interactable.
   *
   * @param {boolean | object | null} [options] The new options to be set.
   * @return {object | Interactable} The current setting or this Interactable
   */ Interactable.prototype.dropzone = function(options) {
        return dropzoneMethod(this, options);
    };
    /**
   * ```js
   * interact(target)
   * .dropChecker(function(dragEvent,         // related dragmove or dragend event
   *                       event,             // TouchEvent/PointerEvent/MouseEvent
   *                       dropped,           // bool result of the default checker
   *                       dropzone,          // dropzone Interactable
   *                       dropElement,       // dropzone elemnt
   *                       draggable,         // draggable Interactable
   *                       draggableElement) {// draggable element
   *
   *   return dropped && event.target.hasAttribute('allow-drop')
   * }
   * ```
   */ Interactable.prototype.dropCheck = function(dragEvent, event, draggable, draggableElement, dropElement, rect) {
        return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect);
    };
    /**
   * Returns or sets whether the dimensions of dropzone elements are calculated
   * on every dragmove or only on dragstart for the default dropChecker
   *
   * @param {boolean} [newValue] True to check on each move. False to check only
   * before start
   * @return {boolean | interact} The current setting or interact
   */ interact.dynamicDrop = function(newValue) {
        if ((0, _isJsDefault.default).bool(newValue)) {
            // if (dragging && scope.dynamicDrop !== newValue && !newValue) {
            //  calcRects(dropzones)
            // }
            scope.dynamicDrop = newValue;
            return interact;
        }
        return scope.dynamicDrop;
    };
    (0, _extendJsDefault.default)(actions.phaselessTypes, {
        dragenter: true,
        dragleave: true,
        dropactivate: true,
        dropdeactivate: true,
        dropmove: true,
        drop: true
    });
    actions.methodDict.drop = "dropzone";
    scope.dynamicDrop = false;
    defaults.actions.drop = drop.defaults;
}
function collectDrops({ interactables  }, draggableElement) {
    const drops = []; // collect all dropzones and their elements which qualify for a drop
    for (const dropzone of interactables.list){
        if (!dropzone.options.drop.enabled) continue;
        const accept = dropzone.options.drop.accept; // test the draggable draggableElement against the dropzone's accept setting
        if ((0, _isJsDefault.default).element(accept) && accept !== draggableElement || (0, _isJsDefault.default).string(accept) && !_domUtilsJs.matchesSelector(draggableElement, accept) || (0, _isJsDefault.default).func(accept) && !accept({
            dropzone,
            draggableElement
        })) continue;
         // query for new elements if necessary
        const dropElements = (0, _isJsDefault.default).string(dropzone.target) ? dropzone._context.querySelectorAll(dropzone.target) : (0, _isJsDefault.default).array(dropzone.target) ? dropzone.target : [
            dropzone.target
        ];
        for (const dropzoneElement of dropElements)if (dropzoneElement !== draggableElement) drops.push({
            dropzone,
            element: dropzoneElement,
            rect: dropzone.getRect(dropzoneElement)
        });
    }
    return drops;
}
function fireActivationEvents(activeDrops, event) {
    // loop through all active dropzones and trigger event
    for (const { dropzone , element  } of activeDrops.slice()){
        event.dropzone = dropzone; // set current element as event target
        event.target = element;
        dropzone.fire(event);
        event.propagationStopped = event.immediatePropagationStopped = false;
    }
} // return a new array of possible drops. getActiveDrops should always be
// called when a drag has just started or a drag event happens while
// dynamicDrop is true
function getActiveDrops(scope, dragElement) {
    // get dropzones and their elements that could receive the draggable
    const activeDrops = collectDrops(scope, dragElement);
    for (const activeDrop of activeDrops)activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element);
    return activeDrops;
}
function getDrop({ dropState , interactable: draggable , element: dragElement  }, dragEvent, pointerEvent) {
    const validDrops = []; // collect all dropzones and their elements which qualify for a drop
    for (const { dropzone , element: dropzoneElement , rect  } of dropState.activeDrops)validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect) ? dropzoneElement : null);
     // get the most appropriate dropzone based on DOM depth and order
    const dropIndex = _domUtilsJs.indexOfDeepestElement(validDrops);
    return dropState.activeDrops[dropIndex] || null;
}
function getDropEvents(interaction, _pointerEvent, dragEvent) {
    const { dropState  } = interaction;
    const dropEvents = {
        enter: null,
        leave: null,
        activate: null,
        deactivate: null,
        move: null,
        drop: null
    };
    if (dragEvent.type === "dragstart") {
        dropEvents.activate = new (0, _dropEventJs.DropEvent)(dropState, dragEvent, "dropactivate");
        dropEvents.activate.target = null;
        dropEvents.activate.dropzone = null;
    }
    if (dragEvent.type === "dragend") {
        dropEvents.deactivate = new (0, _dropEventJs.DropEvent)(dropState, dragEvent, "dropdeactivate");
        dropEvents.deactivate.target = null;
        dropEvents.deactivate.dropzone = null;
    }
    if (dropState.rejected) return dropEvents;
    if (dropState.cur.element !== dropState.prev.element) {
        // if there was a previous dropzone, create a dragleave event
        if (dropState.prev.dropzone) {
            dropEvents.leave = new (0, _dropEventJs.DropEvent)(dropState, dragEvent, "dragleave");
            dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element;
            dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone;
        } // if dropzone is not null, create a dragenter event
        if (dropState.cur.dropzone) {
            dropEvents.enter = new (0, _dropEventJs.DropEvent)(dropState, dragEvent, "dragenter");
            dragEvent.dragEnter = dropState.cur.element;
            dragEvent.dropzone = dropState.cur.dropzone;
        }
    }
    if (dragEvent.type === "dragend" && dropState.cur.dropzone) {
        dropEvents.drop = new (0, _dropEventJs.DropEvent)(dropState, dragEvent, "drop");
        dragEvent.dropzone = dropState.cur.dropzone;
        dragEvent.relatedTarget = dropState.cur.element;
    }
    if (dragEvent.type === "dragmove" && dropState.cur.dropzone) {
        dropEvents.move = new (0, _dropEventJs.DropEvent)(dropState, dragEvent, "dropmove");
        dropEvents.move.dragmove = dragEvent;
        dragEvent.dropzone = dropState.cur.dropzone;
    }
    return dropEvents;
}
function fireDropEvents(interaction, events) {
    const { dropState  } = interaction;
    const { activeDrops , cur , prev  } = dropState;
    if (events.leave) prev.dropzone.fire(events.leave);
    if (events.enter) cur.dropzone.fire(events.enter);
    if (events.move) cur.dropzone.fire(events.move);
    if (events.drop) cur.dropzone.fire(events.drop);
    if (events.deactivate) fireActivationEvents(activeDrops, events.deactivate);
    dropState.prev.dropzone = cur.dropzone;
    dropState.prev.element = cur.element;
}
function onEventCreated({ interaction , iEvent , event  }, scope) {
    if (iEvent.type !== "dragmove" && iEvent.type !== "dragend") return;
    const { dropState  } = interaction;
    if (scope.dynamicDrop) dropState.activeDrops = getActiveDrops(scope, interaction.element);
    const dragEvent = iEvent;
    const dropResult = getDrop(interaction, dragEvent, event); // update rejected status
    dropState.rejected = dropState.rejected && !!dropResult && dropResult.dropzone === dropState.cur.dropzone && dropResult.element === dropState.cur.element;
    dropState.cur.dropzone = dropResult && dropResult.dropzone;
    dropState.cur.element = dropResult && dropResult.element;
    dropState.events = getDropEvents(interaction, event, dragEvent);
}
function dropzoneMethod(interactable, options) {
    if ((0, _isJsDefault.default).object(options)) {
        interactable.options.drop.enabled = options.enabled !== false;
        if (options.listeners) {
            const normalized = (0, _normalizeListenersJsDefault.default)(options.listeners); // rename 'drop' to '' as it will be prefixed with 'drop'
            const corrected = Object.keys(normalized).reduce((acc, type)=>{
                const correctedType = /^(enter|leave)/.test(type) ? `drag${type}` : /^(activate|deactivate|move)/.test(type) ? `drop${type}` : type;
                acc[correctedType] = normalized[type];
                return acc;
            }, {});
            interactable.off(interactable.options.drop.listeners);
            interactable.on(corrected);
            interactable.options.drop.listeners = corrected;
        }
        if ((0, _isJsDefault.default).func(options.ondrop)) interactable.on("drop", options.ondrop);
        if ((0, _isJsDefault.default).func(options.ondropactivate)) interactable.on("dropactivate", options.ondropactivate);
        if ((0, _isJsDefault.default).func(options.ondropdeactivate)) interactable.on("dropdeactivate", options.ondropdeactivate);
        if ((0, _isJsDefault.default).func(options.ondragenter)) interactable.on("dragenter", options.ondragenter);
        if ((0, _isJsDefault.default).func(options.ondragleave)) interactable.on("dragleave", options.ondragleave);
        if ((0, _isJsDefault.default).func(options.ondropmove)) interactable.on("dropmove", options.ondropmove);
        if (/^(pointer|center)$/.test(options.overlap)) interactable.options.drop.overlap = options.overlap;
        else if ((0, _isJsDefault.default).number(options.overlap)) interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);
        if ("accept" in options) interactable.options.drop.accept = options.accept;
        if ("checker" in options) interactable.options.drop.checker = options.checker;
        return interactable;
    }
    if ((0, _isJsDefault.default).bool(options)) {
        interactable.options.drop.enabled = options;
        return interactable;
    }
    return interactable.options.drop;
}
function dropCheckMethod(interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {
    let dropped = false; // if the dropzone has no rect (eg. display: none)
    // call the custom dropChecker or just return false
    if (!(rect = rect || interactable.getRect(dropElement))) return interactable.options.drop.checker ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement) : false;
    const dropOverlap = interactable.options.drop.overlap;
    if (dropOverlap === "pointer") {
        const origin = (0, _getOriginXYJsDefault.default)(draggable, draggableElement, "drag");
        const page = _pointerUtilsJs.getPageXY(dragEvent);
        page.x += origin.x;
        page.y += origin.y;
        const horizontal = page.x > rect.left && page.x < rect.right;
        const vertical = page.y > rect.top && page.y < rect.bottom;
        dropped = horizontal && vertical;
    }
    const dragRect = draggable.getRect(draggableElement);
    if (dragRect && dropOverlap === "center") {
        const cx = dragRect.left + dragRect.width / 2;
        const cy = dragRect.top + dragRect.height / 2;
        dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;
    }
    if (dragRect && (0, _isJsDefault.default).number(dropOverlap)) {
        const overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));
        const overlapRatio = overlapArea / (dragRect.width * dragRect.height);
        dropped = overlapRatio >= dropOverlap;
    }
    if (interactable.options.drop.checker) dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement);
    return dropped;
}
const drop = {
    id: "actions/drop",
    install,
    listeners: {
        "interactions:before-action-start": ({ interaction  })=>{
            if (interaction.prepared.name !== "drag") return;
            interaction.dropState = {
                cur: {
                    dropzone: null,
                    element: null
                },
                prev: {
                    dropzone: null,
                    element: null
                },
                rejected: null,
                events: null,
                activeDrops: []
            };
        },
        "interactions:after-action-start": ({ interaction , event , iEvent: dragEvent  }, scope)=>{
            if (interaction.prepared.name !== "drag") return;
            const { dropState  } = interaction; // reset active dropzones
            dropState.activeDrops = null;
            dropState.events = null;
            dropState.activeDrops = getActiveDrops(scope, interaction.element);
            dropState.events = getDropEvents(interaction, event, dragEvent);
            if (dropState.events.activate) {
                fireActivationEvents(dropState.activeDrops, dropState.events.activate);
                scope.fire("actions/drop:start", {
                    interaction,
                    dragEvent
                });
            }
        },
        "interactions:action-move": onEventCreated,
        "interactions:after-action-move": ({ interaction , iEvent: dragEvent  }, scope)=>{
            if (interaction.prepared.name !== "drag") return;
            fireDropEvents(interaction, interaction.dropState.events);
            scope.fire("actions/drop:move", {
                interaction,
                dragEvent
            });
            interaction.dropState.events = {};
        },
        "interactions:action-end": (arg, scope)=>{
            if (arg.interaction.prepared.name !== "drag") return;
            const { interaction , iEvent: dragEvent  } = arg;
            onEventCreated(arg, scope);
            fireDropEvents(interaction, interaction.dropState.events);
            scope.fire("actions/drop:end", {
                interaction,
                dragEvent
            });
        },
        "interactions:stop": ({ interaction  })=>{
            if (interaction.prepared.name !== "drag") return;
            const { dropState  } = interaction;
            if (dropState) {
                dropState.activeDrops = null;
                dropState.events = null;
                dropState.cur.dropzone = null;
                dropState.cur.element = null;
                dropState.prev.dropzone = null;
                dropState.prev.element = null;
                dropState.rejected = false;
            }
        }
    },
    getActiveDrops,
    getDrop,
    getDropEvents,
    fireDropEvents,
    defaults: {
        enabled: false,
        accept: null,
        overlap: "pointer"
    }
};
exports.default = drop;

},{"../../utils/domUtils.js":"813v2","../../utils/extend.js":"cmcmr","../../utils/getOriginXY.js":"eEJaA","../../utils/is.js":"iRtxa","../../utils/normalizeListeners.js":"9pcNh","../../utils/pointerUtils.js":"g0cI1","../drag/plugin.js":"gQF8D","./DropEvent.js":"414mD","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"813v2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nodeContains", ()=>nodeContains);
parcelHelpers.export(exports, "closest", ()=>closest);
parcelHelpers.export(exports, "parentNode", ()=>parentNode);
parcelHelpers.export(exports, "matchesSelector", ()=>matchesSelector);
parcelHelpers.export(exports, "indexOfDeepestElement", ()=>indexOfDeepestElement);
parcelHelpers.export(exports, "matchesUpTo", ()=>matchesUpTo);
parcelHelpers.export(exports, "getActualElement", ()=>getActualElement);
parcelHelpers.export(exports, "getScrollXY", ()=>getScrollXY);
parcelHelpers.export(exports, "getElementClientRect", ()=>getElementClientRect);
parcelHelpers.export(exports, "getElementRect", ()=>getElementRect);
parcelHelpers.export(exports, "getPath", ()=>getPath);
parcelHelpers.export(exports, "trySelector", ()=>trySelector);
var _browserJs = require("./browser.js");
var _browserJsDefault = parcelHelpers.interopDefault(_browserJs);
var _domObjectsJs = require("./domObjects.js");
var _domObjectsJsDefault = parcelHelpers.interopDefault(_domObjectsJs);
var _isJs = require("./is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _windowJs = require("./window.js");
function nodeContains(parent, child) {
    if (parent.contains) return parent.contains(child);
    while(child){
        if (child === parent) return true;
        child = child.parentNode;
    }
    return false;
}
function closest(element, selector) {
    while((0, _isJsDefault.default).element(element)){
        if (matchesSelector(element, selector)) return element;
        element = parentNode(element);
    }
    return null;
}
function parentNode(node) {
    let parent = node.parentNode;
    if ((0, _isJsDefault.default).docFrag(parent)) {
        // skip past #shado-root fragments
        // tslint:disable-next-line
        while((parent = parent.host) && (0, _isJsDefault.default).docFrag(parent))continue;
        return parent;
    }
    return parent;
}
function matchesSelector(element, selector) {
    // remove /deep/ from selectors if shadowDOM polyfill is used
    if (_windowJs.window !== _windowJs.realWindow) selector = selector.replace(/\/deep\//g, " ");
    return element[(0, _browserJsDefault.default).prefixedMatchesSelector](selector);
}
const getParent = (el)=>el.parentNode || el.host; // Test for the element that's "above" all other qualifiers
function indexOfDeepestElement(elements) {
    let deepestNodeParents = [];
    let deepestNodeIndex;
    for(let i = 0; i < elements.length; i++){
        const currentNode = elements[i];
        const deepestNode = elements[deepestNodeIndex]; // node may appear in elements array multiple times
        if (!currentNode || i === deepestNodeIndex) continue;
        if (!deepestNode) {
            deepestNodeIndex = i;
            continue;
        }
        const currentNodeParent = getParent(currentNode);
        const deepestNodeParent = getParent(deepestNode); // check if the deepest or current are document.documentElement/rootElement
        // - if the current node is, do nothing and continue
        if (currentNodeParent === currentNode.ownerDocument) continue;
        else if (deepestNodeParent === currentNode.ownerDocument) {
            deepestNodeIndex = i;
            continue;
        } // compare zIndex of siblings
        if (currentNodeParent === deepestNodeParent) {
            if (zIndexIsHigherThan(currentNode, deepestNode)) deepestNodeIndex = i;
            continue;
        } // populate the ancestry array for the latest deepest node
        deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode);
        let ancestryStart; // if the deepest node is an HTMLElement and the current node is a non root svg element
        if (deepestNode instanceof (0, _domObjectsJsDefault.default).HTMLElement && currentNode instanceof (0, _domObjectsJsDefault.default).SVGElement && !(currentNode instanceof (0, _domObjectsJsDefault.default).SVGSVGElement)) {
            // TODO: is this check necessary? Was this for HTML elements embedded in SVG?
            if (currentNode === deepestNodeParent) continue;
            ancestryStart = currentNode.ownerSVGElement;
        } else ancestryStart = currentNode;
        const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument);
        let commonIndex = 0; // get (position of closest common ancestor) + 1
        while(currentNodeParents[commonIndex] && currentNodeParents[commonIndex] === deepestNodeParents[commonIndex])commonIndex++;
        const parents = [
            currentNodeParents[commonIndex - 1],
            currentNodeParents[commonIndex],
            deepestNodeParents[commonIndex]
        ];
        if (parents[0]) {
            let child = parents[0].lastChild;
            while(child){
                if (child === parents[1]) {
                    deepestNodeIndex = i;
                    deepestNodeParents = currentNodeParents;
                    break;
                } else if (child === parents[2]) break;
                child = child.previousSibling;
            }
        }
    }
    return deepestNodeIndex;
}
function getNodeParents(node, limit) {
    const parents = [];
    let parent = node;
    let parentParent;
    while((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument){
        parents.unshift(parent);
        parent = parentParent;
    }
    return parents;
}
function zIndexIsHigherThan(higherNode, lowerNode) {
    const higherIndex = parseInt(_windowJs.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0;
    const lowerIndex = parseInt(_windowJs.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0;
    return higherIndex >= lowerIndex;
}
function matchesUpTo(element, selector, limit) {
    while((0, _isJsDefault.default).element(element)){
        if (matchesSelector(element, selector)) return true;
        element = parentNode(element);
        if (element === limit) return matchesSelector(element, selector);
    }
    return false;
}
function getActualElement(element) {
    return element.correspondingUseElement || element;
}
function getScrollXY(relevantWindow) {
    relevantWindow = relevantWindow || _windowJs.window;
    return {
        x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
        y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
    };
}
function getElementClientRect(element) {
    const clientRect = element instanceof (0, _domObjectsJsDefault.default).SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];
    return clientRect && {
        left: clientRect.left,
        right: clientRect.right,
        top: clientRect.top,
        bottom: clientRect.bottom,
        width: clientRect.width || clientRect.right - clientRect.left,
        height: clientRect.height || clientRect.bottom - clientRect.top
    };
}
function getElementRect(element) {
    const clientRect = getElementClientRect(element);
    if (!(0, _browserJsDefault.default).isIOS7 && clientRect) {
        const scroll = getScrollXY(_windowJs.getWindow(element));
        clientRect.left += scroll.x;
        clientRect.right += scroll.x;
        clientRect.top += scroll.y;
        clientRect.bottom += scroll.y;
    }
    return clientRect;
}
function getPath(node) {
    const path = [];
    while(node){
        path.push(node);
        node = parentNode(node);
    }
    return path;
}
function trySelector(value) {
    if (!(0, _isJsDefault.default).string(value)) return false;
     // an exception will be raised if it is invalid
    (0, _domObjectsJsDefault.default).document.querySelector(value);
    return true;
}

},{"./browser.js":"3o3BE","./domObjects.js":"c7ipJ","./is.js":"iRtxa","./window.js":"lQsRi","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3o3BE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domObjectsJs = require("./domObjects.js");
var _domObjectsJsDefault = parcelHelpers.interopDefault(_domObjectsJs);
var _isJs = require("./is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
const browser = {
    init,
    supportsTouch: null,
    supportsPointerEvent: null,
    isIOS7: null,
    isIOS: null,
    isIe9: null,
    isOperaMobile: null,
    prefixedMatchesSelector: null,
    pEventTypes: null,
    wheelEvent: null
};
function init(window) {
    const Element = (0, _domObjectsJsDefault.default).Element;
    const navigator = window.navigator || {}; // Does the browser support touch input?
    browser.supportsTouch = "ontouchstart" in window || (0, _isJsDefault.default).func(window.DocumentTouch) && (0, _domObjectsJsDefault.default).document instanceof window.DocumentTouch; // Does the browser support PointerEvents
    // https://github.com/taye/interact.js/issues/703#issuecomment-471570492
    browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!(0, _domObjectsJsDefault.default).PointerEvent;
    browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform); // scrolling doesn't change the result of getClientRects on iOS 7
    browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\d]/.test(navigator.appVersion);
    browser.isIe9 = /MSIE 9/.test(navigator.userAgent); // Opera Mobile must be handled differently
    browser.isOperaMobile = navigator.appName === "Opera" && browser.supportsTouch && /Presto/.test(navigator.userAgent); // prefix matchesSelector
    browser.prefixedMatchesSelector = "matches" in Element.prototype ? "matches" : "webkitMatchesSelector" in Element.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in Element.prototype ? "mozMatchesSelector" : "oMatchesSelector" in Element.prototype ? "oMatchesSelector" : "msMatchesSelector";
    browser.pEventTypes = browser.supportsPointerEvent ? (0, _domObjectsJsDefault.default).PointerEvent === window.MSPointerEvent ? {
        up: "MSPointerUp",
        down: "MSPointerDown",
        over: "mouseover",
        out: "mouseout",
        move: "MSPointerMove",
        cancel: "MSPointerCancel"
    } : {
        up: "pointerup",
        down: "pointerdown",
        over: "pointerover",
        out: "pointerout",
        move: "pointermove",
        cancel: "pointercancel"
    } : null; // because Webkit and Opera still use 'mousewheel' event type
    browser.wheelEvent = (0, _domObjectsJsDefault.default).document && "onmousewheel" in (0, _domObjectsJsDefault.default).document ? "mousewheel" : "wheel";
}
exports.default = browser;

},{"./domObjects.js":"c7ipJ","./is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"c7ipJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const domObjects = {
    init,
    document: null,
    DocumentFragment: null,
    SVGElement: null,
    SVGSVGElement: null,
    SVGElementInstance: null,
    Element: null,
    HTMLElement: null,
    Event: null,
    Touch: null,
    PointerEvent: null
};
function blank() {}
exports.default = domObjects;
function init(window) {
    const win = window;
    domObjects.document = win.document;
    domObjects.DocumentFragment = win.DocumentFragment || blank;
    domObjects.SVGElement = win.SVGElement || blank;
    domObjects.SVGSVGElement = win.SVGSVGElement || blank;
    domObjects.SVGElementInstance = win.SVGElementInstance || blank;
    domObjects.Element = win.Element || blank;
    domObjects.HTMLElement = win.HTMLElement || domObjects.Element;
    domObjects.Event = win.Event;
    domObjects.Touch = win.Touch || blank;
    domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cmcmr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function extend(dest, source) {
    for(const prop in source)dest[prop] = source[prop];
    const ret = dest;
    return ret;
}
exports.default = extend;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"eEJaA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rectJs = require("./rect.js");
exports.default = function(target, element, actionName) {
    const actionOptions = target.options[actionName];
    const actionOrigin = actionOptions && actionOptions.origin;
    const origin = actionOrigin || target.options.origin;
    const originRect = (0, _rectJs.resolveRectLike)(origin, target, element, [
        target && element
    ]);
    return (0, _rectJs.rectToXY)(originRect) || {
        x: 0,
        y: 0
    };
};

},{"./rect.js":"6qd7M","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6qd7M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getStringOptionResult", ()=>getStringOptionResult);
parcelHelpers.export(exports, "resolveRectLike", ()=>resolveRectLike);
parcelHelpers.export(exports, "rectToXY", ()=>rectToXY);
parcelHelpers.export(exports, "xywhToTlbr", ()=>xywhToTlbr);
parcelHelpers.export(exports, "tlbrToXywh", ()=>tlbrToXywh);
parcelHelpers.export(exports, "addEdges", ()=>addEdges);
var _domUtilsJs = require("./domUtils.js");
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("./is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
function getStringOptionResult(value, target, element) {
    if (value === "parent") return (0, _domUtilsJs.parentNode)(element);
    if (value === "self") return target.getRect(element);
    return (0, _domUtilsJs.closest)(element, value);
}
function resolveRectLike(value, target, element, functionArgs) {
    let returnValue = value;
    if ((0, _isJsDefault.default).string(returnValue)) returnValue = getStringOptionResult(returnValue, target, element);
    else if ((0, _isJsDefault.default).func(returnValue)) returnValue = returnValue(...functionArgs);
    if ((0, _isJsDefault.default).element(returnValue)) returnValue = (0, _domUtilsJs.getElementRect)(returnValue);
    return returnValue;
}
function rectToXY(rect) {
    return rect && {
        x: "x" in rect ? rect.x : rect.left,
        y: "y" in rect ? rect.y : rect.top
    };
}
function xywhToTlbr(rect) {
    if (rect && !("left" in rect && "top" in rect)) {
        rect = (0, _extendJsDefault.default)({}, rect);
        rect.left = rect.x || 0;
        rect.top = rect.y || 0;
        rect.right = rect.right || rect.left + rect.width;
        rect.bottom = rect.bottom || rect.top + rect.height;
    }
    return rect;
}
function tlbrToXywh(rect) {
    if (rect && !("x" in rect && "y" in rect)) {
        rect = (0, _extendJsDefault.default)({}, rect);
        rect.x = rect.left || 0;
        rect.y = rect.top || 0;
        rect.width = rect.width || (rect.right || 0) - rect.x;
        rect.height = rect.height || (rect.bottom || 0) - rect.y;
    }
    return rect;
}
function addEdges(edges, rect, delta) {
    if (edges.left) rect.left += delta.x;
    if (edges.right) rect.right += delta.x;
    if (edges.top) rect.top += delta.y;
    if (edges.bottom) rect.bottom += delta.y;
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
}

},{"./domUtils.js":"813v2","./extend.js":"cmcmr","./is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9pcNh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("./is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
function normalize(type, listeners, result) {
    result = result || {};
    if ((0, _isJsDefault.default).string(type) && type.search(" ") !== -1) type = split(type);
    if ((0, _isJsDefault.default).array(type)) return type.reduce((acc, t)=>(0, _extendJsDefault.default)(acc, normalize(t, listeners, result)), result);
     // ({ type: fn }) -> ('', { type: fn })
    if ((0, _isJsDefault.default).object(type)) {
        listeners = type;
        type = "";
    }
    if ((0, _isJsDefault.default).func(listeners)) {
        result[type] = result[type] || [];
        result[type].push(listeners);
    } else if ((0, _isJsDefault.default).array(listeners)) for (const l of listeners)normalize(type, l, result);
    else if ((0, _isJsDefault.default).object(listeners)) for(const prefix in listeners){
        const combinedTypes = split(prefix).map((p)=>`${type}${p}`);
        normalize(combinedTypes, listeners[prefix], result);
    }
    return result;
}
exports.default = normalize;
function split(type) {
    return type.trim().split(/ +/);
}

},{"./extend.js":"cmcmr","./is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"g0cI1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyCoords", ()=>copyCoords);
parcelHelpers.export(exports, "setCoordDeltas", ()=>setCoordDeltas);
parcelHelpers.export(exports, "setCoordVelocity", ()=>setCoordVelocity);
parcelHelpers.export(exports, "setZeroCoords", ()=>setZeroCoords);
parcelHelpers.export(exports, "isNativePointer", ()=>isNativePointer) // Get specified X/Y coords for mouse or event.touches[0]
;
parcelHelpers.export(exports, "getXY", ()=>getXY);
parcelHelpers.export(exports, "getPageXY", ()=>getPageXY);
parcelHelpers.export(exports, "getClientXY", ()=>getClientXY);
parcelHelpers.export(exports, "getPointerId", ()=>getPointerId);
parcelHelpers.export(exports, "setCoords", ()=>setCoords);
parcelHelpers.export(exports, "getTouchPair", ()=>getTouchPair);
parcelHelpers.export(exports, "pointerAverage", ()=>pointerAverage);
parcelHelpers.export(exports, "touchBBox", ()=>touchBBox);
parcelHelpers.export(exports, "touchDistance", ()=>touchDistance);
parcelHelpers.export(exports, "touchAngle", ()=>touchAngle);
parcelHelpers.export(exports, "getPointerType", ()=>getPointerType) // [ event.target, event.currentTarget ]
;
parcelHelpers.export(exports, "getEventTargets", ()=>getEventTargets);
parcelHelpers.export(exports, "newCoords", ()=>newCoords);
parcelHelpers.export(exports, "coordsToEvent", ()=>coordsToEvent);
parcelHelpers.export(exports, "pointerExtend", ()=>(0, _pointerExtendJsDefault.default));
var _browserJs = require("./browser.js");
var _browserJsDefault = parcelHelpers.interopDefault(_browserJs);
var _domObjectsJs = require("./domObjects.js");
var _domObjectsJsDefault = parcelHelpers.interopDefault(_domObjectsJs);
var _domUtilsJs = require("./domUtils.js");
var _hypotJs = require("./hypot.js");
var _hypotJsDefault = parcelHelpers.interopDefault(_hypotJs);
var _isJs = require("./is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _pointerExtendJs = require("./pointerExtend.js");
var _pointerExtendJsDefault = parcelHelpers.interopDefault(_pointerExtendJs);
function copyCoords(dest, src) {
    dest.page = dest.page || {};
    dest.page.x = src.page.x;
    dest.page.y = src.page.y;
    dest.client = dest.client || {};
    dest.client.x = src.client.x;
    dest.client.y = src.client.y;
    dest.timeStamp = src.timeStamp;
}
function setCoordDeltas(targetObj, prev, cur) {
    targetObj.page.x = cur.page.x - prev.page.x;
    targetObj.page.y = cur.page.y - prev.page.y;
    targetObj.client.x = cur.client.x - prev.client.x;
    targetObj.client.y = cur.client.y - prev.client.y;
    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
}
function setCoordVelocity(targetObj, delta) {
    const dt = Math.max(delta.timeStamp / 1000, 0.001);
    targetObj.page.x = delta.page.x / dt;
    targetObj.page.y = delta.page.y / dt;
    targetObj.client.x = delta.client.x / dt;
    targetObj.client.y = delta.client.y / dt;
    targetObj.timeStamp = dt;
}
function setZeroCoords(targetObj) {
    targetObj.page.x = 0;
    targetObj.page.y = 0;
    targetObj.client.x = 0;
    targetObj.client.y = 0;
}
function isNativePointer(pointer) {
    return pointer instanceof (0, _domObjectsJsDefault.default).Event || pointer instanceof (0, _domObjectsJsDefault.default).Touch;
}
function getXY(type, pointer, xy) {
    xy = xy || {};
    type = type || "page";
    xy.x = pointer[type + "X"];
    xy.y = pointer[type + "Y"];
    return xy;
}
function getPageXY(pointer, page) {
    page = page || {
        x: 0,
        y: 0
    }; // Opera Mobile handles the viewport and scrolling oddly
    if ((0, _browserJsDefault.default).isOperaMobile && isNativePointer(pointer)) {
        getXY("screen", pointer, page);
        page.x += window.scrollX;
        page.y += window.scrollY;
    } else getXY("page", pointer, page);
    return page;
}
function getClientXY(pointer, client) {
    client = client || {};
    if ((0, _browserJsDefault.default).isOperaMobile && isNativePointer(pointer)) // Opera Mobile handles the viewport and scrolling oddly
    getXY("screen", pointer, client);
    else getXY("client", pointer, client);
    return client;
}
function getPointerId(pointer) {
    return (0, _isJsDefault.default).number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
}
function setCoords(dest, pointers, timeStamp) {
    const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];
    getPageXY(pointer, dest.page);
    getClientXY(pointer, dest.client);
    dest.timeStamp = timeStamp;
}
function getTouchPair(event) {
    const touches = []; // array of touches is supplied
    if ((0, _isJsDefault.default).array(event)) {
        touches[0] = event[0];
        touches[1] = event[1];
    } else if (event.type === "touchend") {
        if (event.touches.length === 1) {
            touches[0] = event.touches[0];
            touches[1] = event.changedTouches[0];
        } else if (event.touches.length === 0) {
            touches[0] = event.changedTouches[0];
            touches[1] = event.changedTouches[1];
        }
    } else {
        touches[0] = event.touches[0];
        touches[1] = event.touches[1];
    }
    return touches;
}
function pointerAverage(pointers) {
    const average = {
        pageX: 0,
        pageY: 0,
        clientX: 0,
        clientY: 0,
        screenX: 0,
        screenY: 0
    };
    for (const pointer of pointers)for(const prop in average)average[prop] += pointer[prop];
    for(const prop1 in average)average[prop1] /= pointers.length;
    return average;
}
function touchBBox(event) {
    if (!event.length) return null;
    const touches = getTouchPair(event);
    const minX = Math.min(touches[0].pageX, touches[1].pageX);
    const minY = Math.min(touches[0].pageY, touches[1].pageY);
    const maxX = Math.max(touches[0].pageX, touches[1].pageX);
    const maxY = Math.max(touches[0].pageY, touches[1].pageY);
    return {
        x: minX,
        y: minY,
        left: minX,
        top: minY,
        right: maxX,
        bottom: maxY,
        width: maxX - minX,
        height: maxY - minY
    };
}
function touchDistance(event, deltaSource) {
    const sourceX = deltaSource + "X";
    const sourceY = deltaSource + "Y";
    const touches = getTouchPair(event);
    const dx = touches[0][sourceX] - touches[1][sourceX];
    const dy = touches[0][sourceY] - touches[1][sourceY];
    return (0, _hypotJsDefault.default)(dx, dy);
}
function touchAngle(event, deltaSource) {
    const sourceX = deltaSource + "X";
    const sourceY = deltaSource + "Y";
    const touches = getTouchPair(event);
    const dx = touches[1][sourceX] - touches[0][sourceX];
    const dy = touches[1][sourceY] - touches[0][sourceY];
    const angle = 180 * Math.atan2(dy, dx) / Math.PI;
    return angle;
}
function getPointerType(pointer) {
    return (0, _isJsDefault.default).string(pointer.pointerType) ? pointer.pointerType : (0, _isJsDefault.default).number(pointer.pointerType) ? [
        undefined,
        undefined,
        "touch",
        "pen",
        "mouse"
    ][pointer.pointerType] : // be either a MouseEvent, TouchEvent, or Touch object
    /touch/.test(pointer.type || "") || pointer instanceof (0, _domObjectsJsDefault.default).Touch ? "touch" : "mouse";
}
function getEventTargets(event) {
    const path = (0, _isJsDefault.default).func(event.composedPath) ? event.composedPath() : event.path;
    return [
        _domUtilsJs.getActualElement(path ? path[0] : event.target),
        _domUtilsJs.getActualElement(event.currentTarget)
    ];
}
function newCoords() {
    return {
        page: {
            x: 0,
            y: 0
        },
        client: {
            x: 0,
            y: 0
        },
        timeStamp: 0
    };
}
function coordsToEvent(coords) {
    const event = {
        coords,
        get page () {
            return this.coords.page;
        },
        get client () {
            return this.coords.client;
        },
        get timeStamp () {
            return this.coords.timeStamp;
        },
        get pageX () {
            return this.coords.page.x;
        },
        get pageY () {
            return this.coords.page.y;
        },
        get clientX () {
            return this.coords.client.x;
        },
        get clientY () {
            return this.coords.client.y;
        },
        get pointerId () {
            return this.coords.pointerId;
        },
        get target () {
            return this.coords.target;
        },
        get type () {
            return this.coords.type;
        },
        get pointerType () {
            return this.coords.pointerType;
        },
        get buttons () {
            return this.coords.buttons;
        },
        preventDefault () {}
    };
    return event;
}

},{"./browser.js":"3o3BE","./domObjects.js":"c7ipJ","./domUtils.js":"813v2","./hypot.js":"ekLIq","./is.js":"iRtxa","./pointerExtend.js":"9yeZb","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ekLIq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = (x, y)=>Math.sqrt(x * x + y * y);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9yeZb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function pointerExtend(dest, source) {
    dest.__set ||= {};
    for(const prop in source)if (typeof dest[prop] !== "function" && prop !== "__set") Object.defineProperty(dest, prop, {
        get () {
            if (prop in dest.__set) return dest.__set[prop];
            return dest.__set[prop] = source[prop];
        },
        set (value) {
            dest.__set[prop] = value;
        },
        configurable: true
    });
    return dest;
}
exports.default = pointerExtend;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"414mD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DropEvent", ()=>DropEvent);
var _baseEventJs = require("../../core/BaseEvent.js");
var _arrJs = require("../../utils/arr.js");
class DropEvent extends (0, _baseEventJs.BaseEvent) {
    dropzone;
    dragEvent;
    relatedTarget;
    draggable;
    propagationStopped = false;
    immediatePropagationStopped = false;
    /**
   * Class of events fired on dropzones during drags with acceptable targets.
   */ constructor(dropState, dragEvent, type){
        super(dragEvent._interaction);
        const { element , dropzone  } = type === "dragleave" ? dropState.prev : dropState.cur;
        this.type = type;
        this.target = element;
        this.currentTarget = element;
        this.dropzone = dropzone;
        this.dragEvent = dragEvent;
        this.relatedTarget = dragEvent.target;
        this.draggable = dragEvent.interactable;
        this.timeStamp = dragEvent.timeStamp;
    }
    /**
   * If this is a `dropactivate` event, the dropzone element will be
   * deactivated.
   *
   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the
   * dropzone element and more.
   */ reject() {
        const { dropState  } = this._interaction;
        if (this.type !== "dropactivate" && (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)) return;
        dropState.prev.dropzone = this.dropzone;
        dropState.prev.element = this.target;
        dropState.rejected = true;
        dropState.events.enter = null;
        this.stopImmediatePropagation();
        if (this.type === "dropactivate") {
            const activeDrops = dropState.activeDrops;
            const index = _arrJs.findIndex(activeDrops, ({ dropzone , element  })=>dropzone === this.dropzone && element === this.target);
            dropState.activeDrops.splice(index, 1);
            const deactivateEvent = new DropEvent(dropState, this.dragEvent, "dropdeactivate");
            deactivateEvent.dropzone = this.dropzone;
            deactivateEvent.target = this.target;
            this.dropzone.fire(deactivateEvent);
        } else this.dropzone.fire(new DropEvent(dropState, this.dragEvent, "dragleave"));
    }
    preventDefault() {}
    stopPropagation() {
        this.propagationStopped = true;
    }
    stopImmediatePropagation() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    }
}

},{"../../core/BaseEvent.js":"fd10N","../../utils/arr.js":"8BYbE","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fd10N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseEvent", ()=>BaseEvent) // defined outside of class definition to avoid assignment of undefined during
;
class BaseEvent {
    immediatePropagationStopped = false;
    propagationStopped = false;
    constructor(interaction){
        this._interaction = interaction;
    }
    preventDefault() {}
    /**
   * Don't call any other listeners (even on the current target)
   */ stopPropagation() {
        this.propagationStopped = true;
    }
    /**
   * Don't call listeners on the remaining targets
   */ stopImmediatePropagation() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    }
}
// construction
// getters and setters defined here to support typescript 3.6 and below which
// don't support getter and setters in .d.ts files
Object.defineProperty(BaseEvent.prototype, "interaction", {
    get () {
        return this._interaction._proxy;
    },
    set () {}
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8BYbE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "findIndex", ()=>findIndex);
parcelHelpers.export(exports, "find", ()=>find);
const contains = (array, target)=>array.indexOf(target) !== -1;
const remove = (array, target)=>array.splice(array.indexOf(target), 1);
const merge = (target, source)=>{
    for (const item of source)target.push(item);
    return target;
};
const from = (source)=>merge([], source);
const findIndex = (array, func)=>{
    for(let i = 0; i < array.length; i++){
        if (func(array[i], i, array)) return i;
    }
    return -1;
};
const find = (array, func)=>array[findIndex(array, func)];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bjxX6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _pointerUtilsJs = require("../../utils/pointerUtils.js");
function install(scope) {
    const { actions , Interactable , defaults  } = scope;
    /**
   * ```js
   * interact(element).gesturable({
   *     onstart: function (event) {},
   *     onmove : function (event) {},
   *     onend  : function (event) {},
   *
   *     // limit multiple gestures.
   *     // See the explanation in {@link Interactable.draggable} example
   *     max: Infinity,
   *     maxPerElement: 1,
   * })
   *
   * var isGestureable = interact(element).gesturable()
   * ```
   *
   * Gets or sets whether multitouch gestures can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on gesture events (makes the Interactable gesturable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of gesture events, or this Interactable
   */ Interactable.prototype.gesturable = function(options) {
        if ((0, _isJsDefault.default).object(options)) {
            this.options.gesture.enabled = options.enabled !== false;
            this.setPerAction("gesture", options);
            this.setOnEvents("gesture", options);
            return this;
        }
        if ((0, _isJsDefault.default).bool(options)) {
            this.options.gesture.enabled = options;
            return this;
        }
        return this.options.gesture;
    };
    actions.map.gesture = gesture;
    actions.methodDict.gesture = "gesturable";
    defaults.actions.gesture = gesture.defaults;
}
function updateGestureProps({ interaction , iEvent , phase  }) {
    if (interaction.prepared.name !== "gesture") return;
    const pointers = interaction.pointers.map((p)=>p.pointer);
    const starting = phase === "start";
    const ending = phase === "end";
    const deltaSource = interaction.interactable.options.deltaSource;
    iEvent.touches = [
        pointers[0],
        pointers[1]
    ];
    if (starting) {
        iEvent.distance = _pointerUtilsJs.touchDistance(pointers, deltaSource);
        iEvent.box = _pointerUtilsJs.touchBBox(pointers);
        iEvent.scale = 1;
        iEvent.ds = 0;
        iEvent.angle = _pointerUtilsJs.touchAngle(pointers, deltaSource);
        iEvent.da = 0;
        interaction.gesture.startDistance = iEvent.distance;
        interaction.gesture.startAngle = iEvent.angle;
    } else if (ending) {
        const prevEvent = interaction.prevEvent;
        iEvent.distance = prevEvent.distance;
        iEvent.box = prevEvent.box;
        iEvent.scale = prevEvent.scale;
        iEvent.ds = 0;
        iEvent.angle = prevEvent.angle;
        iEvent.da = 0;
    } else {
        iEvent.distance = _pointerUtilsJs.touchDistance(pointers, deltaSource);
        iEvent.box = _pointerUtilsJs.touchBBox(pointers);
        iEvent.scale = iEvent.distance / interaction.gesture.startDistance;
        iEvent.angle = _pointerUtilsJs.touchAngle(pointers, deltaSource);
        iEvent.ds = iEvent.scale - interaction.gesture.scale;
        iEvent.da = iEvent.angle - interaction.gesture.angle;
    }
    interaction.gesture.distance = iEvent.distance;
    interaction.gesture.angle = iEvent.angle;
    if ((0, _isJsDefault.default).number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) interaction.gesture.scale = iEvent.scale;
}
const gesture = {
    id: "actions/gesture",
    before: [
        "actions/drag",
        "actions/resize"
    ],
    install,
    listeners: {
        "interactions:action-start": updateGestureProps,
        "interactions:action-move": updateGestureProps,
        "interactions:action-end": updateGestureProps,
        "interactions:new": ({ interaction  })=>{
            interaction.gesture = {
                angle: 0,
                distance: 0,
                scale: 1,
                startAngle: 0,
                startDistance: 0
            };
        },
        "auto-start:check": (arg)=>{
            if (arg.interaction.pointers.length < 2) return undefined;
            const gestureOptions = arg.interactable.options.gesture;
            if (!(gestureOptions && gestureOptions.enabled)) return undefined;
            arg.action = {
                name: "gesture"
            };
            return false;
        }
    },
    defaults: {},
    getCursor () {
        return "";
    }
};
exports.default = gesture;

},{"../../utils/is.js":"iRtxa","../../utils/pointerUtils.js":"g0cI1","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"llJs7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domUtilsJs = require("../../utils/domUtils.js");
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
function install(scope) {
    const { actions , browser , /** @lends Interactable */ Interactable , // tslint:disable-line no-shadowed-variable
    defaults  } = scope; // Less Precision with touch input
    resize.cursors = initCursors(browser);
    resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;
    /**
   * ```js
   * interact(element).resizable({
   *   onstart: function (event) {},
   *   onmove : function (event) {},
   *   onend  : function (event) {},
   *
   *   edges: {
   *     top   : true,       // Use pointer coords to check for resize.
   *     left  : false,      // Disable resizing from left edge.
   *     bottom: '.resize-s',// Resize if pointer target matches selector
   *     right : handleEl    // Resize if pointer target is the given Element
   *   },
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height are adjusted at a 1:1 ratio.
   *     square: false,
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height maintain the aspect ratio they had when resizing started.
   *     preserveAspectRatio: false,
   *
   *   // a value of 'none' will limit the resize rect to a minimum of 0x0
   *   // 'negate' will allow the rect to have negative width/height
   *   // 'reposition' will keep the width/height positive by swapping
   *   // the top and bottom edges and/or swapping the left and right edges
   *   invert: 'none' || 'negate' || 'reposition'
   *
   *   // limit multiple resizes.
   *   // See the explanation in the {@link Interactable.draggable} example
   *   max: Infinity,
   *   maxPerElement: 1,
   * })
   *
   * var isResizeable = interact(element).resizable()
   * ```
   *
   * Gets or sets whether resize actions can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on resize events (object makes the Interactable
   * resizable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of resize elements, or this Interactable
   */ Interactable.prototype.resizable = function(options) {
        return resizable(this, options, scope);
    };
    actions.map.resize = resize;
    actions.methodDict.resize = "resizable";
    defaults.actions.resize = resize.defaults;
}
function resizeChecker(arg) {
    const { interaction , interactable , element , rect , buttons  } = arg;
    if (!rect) return undefined;
    const page = (0, _extendJsDefault.default)({}, interaction.coords.cur.page);
    const resizeOptions = interactable.options.resize;
    if (!(resizeOptions && resizeOptions.enabled) || // check mouseButton setting if the pointer is down
    interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & resizeOptions.mouseButtons) === 0) return undefined;
     // if using resize.edges
    if ((0, _isJsDefault.default).object(resizeOptions.edges)) {
        const resizeEdges = {
            left: false,
            right: false,
            top: false,
            bottom: false
        };
        for(const edge in resizeEdges)resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || resize.defaultMargin);
        resizeEdges.left = resizeEdges.left && !resizeEdges.right;
        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;
        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) arg.action = {
            name: "resize",
            edges: resizeEdges
        };
    } else {
        const right = resizeOptions.axis !== "y" && page.x > rect.right - resize.defaultMargin;
        const bottom = resizeOptions.axis !== "x" && page.y > rect.bottom - resize.defaultMargin;
        if (right || bottom) arg.action = {
            name: "resize",
            axes: (right ? "x" : "") + (bottom ? "y" : "")
        };
    }
    return arg.action ? false : undefined;
}
function resizable(interactable, options, scope) {
    if ((0, _isJsDefault.default).object(options)) {
        interactable.options.resize.enabled = options.enabled !== false;
        interactable.setPerAction("resize", options);
        interactable.setOnEvents("resize", options);
        if ((0, _isJsDefault.default).string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) interactable.options.resize.axis = options.axis;
        else if (options.axis === null) interactable.options.resize.axis = scope.defaults.actions.resize.axis;
        if ((0, _isJsDefault.default).bool(options.preserveAspectRatio)) interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
        else if ((0, _isJsDefault.default).bool(options.square)) interactable.options.resize.square = options.square;
        return interactable;
    }
    if ((0, _isJsDefault.default).bool(options)) {
        interactable.options.resize.enabled = options;
        return interactable;
    }
    return interactable.options.resize;
}
function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
    // false, '', undefined, null
    if (!value) return false;
     // true value, use pointer coords and element rect
    if (value === true) {
        // if dimensions are negative, "switch" edges
        const width = (0, _isJsDefault.default).number(rect.width) ? rect.width : rect.right - rect.left;
        const height = (0, _isJsDefault.default).number(rect.height) ? rect.height : rect.bottom - rect.top; // don't use margin greater than half the relevent dimension
        margin = Math.min(margin, Math.abs((name === "left" || name === "right" ? width : height) / 2));
        if (width < 0) {
            if (name === "left") name = "right";
            else if (name === "right") name = "left";
        }
        if (height < 0) {
            if (name === "top") name = "bottom";
            else if (name === "bottom") name = "top";
        }
        if (name === "left") {
            const edge = width >= 0 ? rect.left : rect.right;
            return page.x < edge + margin;
        }
        if (name === "top") {
            const edge1 = height >= 0 ? rect.top : rect.bottom;
            return page.y < edge1 + margin;
        }
        if (name === "right") return page.x > (width >= 0 ? rect.right : rect.left) - margin;
        if (name === "bottom") return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
    } // the remaining checks require an element
    if (!(0, _isJsDefault.default).element(element)) return false;
    return (0, _isJsDefault.default).element(value) ? value === element : _domUtilsJs.matchesUpTo(element, value, interactableElement);
}
/* eslint-disable multiline-ternary */ // eslint-disable-next-line @typescript-eslint/consistent-type-imports
function initCursors(browser) {
    return browser.isIe9 ? {
        x: "e-resize",
        y: "s-resize",
        xy: "se-resize",
        top: "n-resize",
        left: "w-resize",
        bottom: "s-resize",
        right: "e-resize",
        topleft: "se-resize",
        bottomright: "se-resize",
        topright: "ne-resize",
        bottomleft: "ne-resize"
    } : {
        x: "ew-resize",
        y: "ns-resize",
        xy: "nwse-resize",
        top: "ns-resize",
        left: "ew-resize",
        bottom: "ns-resize",
        right: "ew-resize",
        topleft: "nwse-resize",
        bottomright: "nwse-resize",
        topright: "nesw-resize",
        bottomleft: "nesw-resize"
    };
}
/* eslint-enable multiline-ternary */ function start({ iEvent , interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
    const resizeEvent = iEvent;
    const rect = interaction.rect;
    interaction._rects = {
        start: (0, _extendJsDefault.default)({}, rect),
        corrected: (0, _extendJsDefault.default)({}, rect),
        previous: (0, _extendJsDefault.default)({}, rect),
        delta: {
            left: 0,
            right: 0,
            width: 0,
            top: 0,
            bottom: 0,
            height: 0
        }
    };
    resizeEvent.edges = interaction.prepared.edges;
    resizeEvent.rect = interaction._rects.corrected;
    resizeEvent.deltaRect = interaction._rects.delta;
}
function move({ iEvent , interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
    const resizeEvent = iEvent;
    const resizeOptions = interaction.interactable.options.resize;
    const invert = resizeOptions.invert;
    const invertible = invert === "reposition" || invert === "negate";
    const current = interaction.rect;
    const { start: startRect , corrected , delta: deltaRect , previous  } = interaction._rects;
    (0, _extendJsDefault.default)(previous, corrected);
    if (invertible) {
        // if invertible, copy the current rect
        (0, _extendJsDefault.default)(corrected, current);
        if (invert === "reposition") {
            // swap edge values if necessary to keep width/height positive
            if (corrected.top > corrected.bottom) {
                const swap = corrected.top;
                corrected.top = corrected.bottom;
                corrected.bottom = swap;
            }
            if (corrected.left > corrected.right) {
                const swap1 = corrected.left;
                corrected.left = corrected.right;
                corrected.right = swap1;
            }
        }
    } else {
        // if not invertible, restrict to minimum of 0x0 rect
        corrected.top = Math.min(current.top, startRect.bottom);
        corrected.bottom = Math.max(current.bottom, startRect.top);
        corrected.left = Math.min(current.left, startRect.right);
        corrected.right = Math.max(current.right, startRect.left);
    }
    corrected.width = corrected.right - corrected.left;
    corrected.height = corrected.bottom - corrected.top;
    for(const edge in corrected)deltaRect[edge] = corrected[edge] - previous[edge];
    resizeEvent.edges = interaction.prepared.edges;
    resizeEvent.rect = corrected;
    resizeEvent.deltaRect = deltaRect;
}
function end({ iEvent , interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
    const resizeEvent = iEvent;
    resizeEvent.edges = interaction.prepared.edges;
    resizeEvent.rect = interaction._rects.corrected;
    resizeEvent.deltaRect = interaction._rects.delta;
}
function updateEventAxes({ iEvent , interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.resizeAxes) return;
    const options = interaction.interactable.options;
    const resizeEvent = iEvent;
    if (options.resize.square) {
        if (interaction.resizeAxes === "y") resizeEvent.delta.x = resizeEvent.delta.y;
        else resizeEvent.delta.y = resizeEvent.delta.x;
        resizeEvent.axes = "xy";
    } else {
        resizeEvent.axes = interaction.resizeAxes;
        if (interaction.resizeAxes === "x") resizeEvent.delta.y = 0;
        else if (interaction.resizeAxes === "y") resizeEvent.delta.x = 0;
    }
}
const resize = {
    id: "actions/resize",
    before: [
        "actions/drag"
    ],
    install,
    listeners: {
        "interactions:new": ({ interaction  })=>{
            interaction.resizeAxes = "xy";
        },
        "interactions:action-start": (arg)=>{
            start(arg);
            updateEventAxes(arg);
        },
        "interactions:action-move": (arg)=>{
            move(arg);
            updateEventAxes(arg);
        },
        "interactions:action-end": end,
        "auto-start:check": resizeChecker
    },
    defaults: {
        square: false,
        preserveAspectRatio: false,
        axis: "xy",
        // use default margin
        margin: NaN,
        // object with props left, right, top, bottom which are
        // true/false values to resize when the pointer is over that edge,
        // CSS selectors to match the handles for each direction
        // or the Elements for each handle
        edges: null,
        // a value of 'none' will limit the resize rect to a minimum of 0x0
        // 'negate' will alow the rect to have negative width/height
        // 'reposition' will keep the width/height positive by swapping
        // the top and bottom edges and/or swapping the left and right edges
        invert: "none"
    },
    cursors: null,
    getCursor ({ edges , axis , name  }) {
        const cursors = resize.cursors;
        let result = null;
        if (axis) result = cursors[name + axis];
        else if (edges) {
            let cursorKey = "";
            for (const edge of [
                "top",
                "bottom",
                "left",
                "right"
            ])if (edges[edge]) cursorKey += edge;
            result = cursors[cursorKey];
        }
        return result;
    },
    defaultMargin: null
};
exports.default = resize;

},{"../../utils/domUtils.js":"813v2","../../utils/extend.js":"cmcmr","../../utils/is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aqXqX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContainer", ()=>getContainer);
parcelHelpers.export(exports, "getScroll", ()=>getScroll);
parcelHelpers.export(exports, "getScrollSize", ()=>getScrollSize);
parcelHelpers.export(exports, "getScrollSizeDelta", ()=>getScrollSizeDelta);
var _domUtilsJs = require("../utils/domUtils.js");
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _rafJs = require("../utils/raf.js");
var _rafJsDefault = parcelHelpers.interopDefault(_rafJs);
var _rectJs = require("../utils/rect.js");
var _windowJs = require("../utils/window.js");
function install(scope) {
    const { defaults , actions  } = scope;
    scope.autoScroll = autoScroll;
    autoScroll.now = ()=>scope.now();
    actions.phaselessTypes.autoscroll = true;
    defaults.perAction.autoScroll = autoScroll.defaults;
}
const autoScroll = {
    defaults: {
        enabled: false,
        margin: 60,
        // the item that is scrolled (Window or HTMLElement)
        container: null,
        // the scroll speed in pixels per second
        speed: 300
    },
    now: Date.now,
    interaction: null,
    i: 0,
    // the handle returned by window.setInterval
    // Direction each pulse is to scroll in
    x: 0,
    y: 0,
    isScrolling: false,
    prevTime: 0,
    margin: 0,
    speed: 0,
    start (interaction) {
        autoScroll.isScrolling = true;
        (0, _rafJsDefault.default).cancel(autoScroll.i);
        interaction.autoScroll = autoScroll;
        autoScroll.interaction = interaction;
        autoScroll.prevTime = autoScroll.now();
        autoScroll.i = (0, _rafJsDefault.default).request(autoScroll.scroll);
    },
    stop () {
        autoScroll.isScrolling = false;
        if (autoScroll.interaction) autoScroll.interaction.autoScroll = null;
        (0, _rafJsDefault.default).cancel(autoScroll.i);
    },
    // scroll the window by the values in scroll.x/y
    scroll () {
        const { interaction  } = autoScroll;
        const { interactable , element  } = interaction;
        const actionName = interaction.prepared.name;
        const options = interactable.options[actionName].autoScroll;
        const container = getContainer(options.container, interactable, element);
        const now = autoScroll.now(); // change in time in seconds
        const dt = (now - autoScroll.prevTime) / 1000; // displacement
        const s = options.speed * dt;
        if (s >= 1) {
            const scrollBy = {
                x: autoScroll.x * s,
                y: autoScroll.y * s
            };
            if (scrollBy.x || scrollBy.y) {
                const prevScroll = getScroll(container);
                if ((0, _isJsDefault.default).window(container)) container.scrollBy(scrollBy.x, scrollBy.y);
                else if (container) {
                    container.scrollLeft += scrollBy.x;
                    container.scrollTop += scrollBy.y;
                }
                const curScroll = getScroll(container);
                const delta = {
                    x: curScroll.x - prevScroll.x,
                    y: curScroll.y - prevScroll.y
                };
                if (delta.x || delta.y) interactable.fire({
                    type: "autoscroll",
                    target: element,
                    interactable,
                    delta,
                    interaction,
                    container
                });
            }
            autoScroll.prevTime = now;
        }
        if (autoScroll.isScrolling) {
            (0, _rafJsDefault.default).cancel(autoScroll.i);
            autoScroll.i = (0, _rafJsDefault.default).request(autoScroll.scroll);
        }
    },
    check (interactable, actionName) {
        var _options$actionName$a;
        const options = interactable.options;
        return (_options$actionName$a = options[actionName].autoScroll) == null ? void 0 : _options$actionName$a.enabled;
    },
    onInteractionMove ({ interaction , pointer  }) {
        if (!(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))) return;
        if (interaction.simulation) {
            autoScroll.x = autoScroll.y = 0;
            return;
        }
        let top;
        let right;
        let bottom;
        let left;
        const { interactable , element  } = interaction;
        const actionName = interaction.prepared.name;
        const options = interactable.options[actionName].autoScroll;
        const container = getContainer(options.container, interactable, element);
        if ((0, _isJsDefault.default).window(container)) {
            left = pointer.clientX < autoScroll.margin;
            top = pointer.clientY < autoScroll.margin;
            right = pointer.clientX > container.innerWidth - autoScroll.margin;
            bottom = pointer.clientY > container.innerHeight - autoScroll.margin;
        } else {
            const rect = _domUtilsJs.getElementClientRect(container);
            left = pointer.clientX < rect.left + autoScroll.margin;
            top = pointer.clientY < rect.top + autoScroll.margin;
            right = pointer.clientX > rect.right - autoScroll.margin;
            bottom = pointer.clientY > rect.bottom - autoScroll.margin;
        }
        autoScroll.x = right ? 1 : left ? -1 : 0;
        autoScroll.y = bottom ? 1 : top ? -1 : 0;
        if (!autoScroll.isScrolling) {
            // set the autoScroll properties to those of the target
            autoScroll.margin = options.margin;
            autoScroll.speed = options.speed;
            autoScroll.start(interaction);
        }
    }
};
function getContainer(value, interactable, element) {
    return ((0, _isJsDefault.default).string(value) ? (0, _rectJs.getStringOptionResult)(value, interactable, element) : value) || (0, _windowJs.getWindow)(element);
}
function getScroll(container) {
    if ((0, _isJsDefault.default).window(container)) container = window.document.body;
    return {
        x: container.scrollLeft,
        y: container.scrollTop
    };
}
function getScrollSize(container) {
    if ((0, _isJsDefault.default).window(container)) container = window.document.body;
    return {
        x: container.scrollWidth,
        y: container.scrollHeight
    };
}
function getScrollSizeDelta({ interaction , element  }, func) {
    const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll;
    if (!scrollOptions || !scrollOptions.enabled) {
        func();
        return {
            x: 0,
            y: 0
        };
    }
    const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element);
    const prevSize = getScroll(scrollContainer);
    func();
    const curSize = getScroll(scrollContainer);
    return {
        x: curSize.x - prevSize.x,
        y: curSize.y - prevSize.y
    };
}
const autoScrollPlugin = {
    id: "auto-scroll",
    install,
    listeners: {
        "interactions:new": ({ interaction  })=>{
            interaction.autoScroll = null;
        },
        "interactions:destroy": ({ interaction  })=>{
            interaction.autoScroll = null;
            autoScroll.stop();
            if (autoScroll.interaction) autoScroll.interaction = null;
        },
        "interactions:stop": autoScroll.stop,
        "interactions:action-move": (arg)=>autoScroll.onInteractionMove(arg)
    }
};
exports.default = autoScrollPlugin;

},{"../utils/domUtils.js":"813v2","../utils/is.js":"iRtxa","../utils/raf.js":"54IvB","../utils/rect.js":"6qd7M","../utils/window.js":"lQsRi","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"54IvB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let lastTime = 0;
let request;
let cancel;
function init(global) {
    request = global.requestAnimationFrame;
    cancel = global.cancelAnimationFrame;
    if (!request) {
        const vendors = [
            "ms",
            "moz",
            "webkit",
            "o"
        ];
        for (const vendor of vendors){
            request = global[`${vendor}RequestAnimationFrame`];
            cancel = global[`${vendor}CancelAnimationFrame`] || global[`${vendor}CancelRequestAnimationFrame`];
        }
    }
    request = request && request.bind(global);
    cancel = cancel && cancel.bind(global);
    if (!request) {
        request = (callback)=>{
            const currTime = Date.now();
            const timeToCall = Math.max(0, 16 - (currTime - lastTime));
            const token = global.setTimeout(()=>{
                // eslint-disable-next-line n/no-callback-literal
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return token;
        };
        cancel = (token)=>clearTimeout(token);
    }
}
exports.default = {
    request: (callback)=>request(callback),
    cancel: (token)=>cancel(token),
    init
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"54BtV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseJs = require("./base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _dragAxisJs = require("./dragAxis.js");
var _dragAxisJsDefault = parcelHelpers.interopDefault(_dragAxisJs);
var _holdJs = require("./hold.js");
var _holdJsDefault = parcelHelpers.interopDefault(_holdJs);
exports.default = {
    id: "auto-start",
    install (scope) {
        scope.usePlugin((0, _baseJsDefault.default));
        scope.usePlugin((0, _holdJsDefault.default));
        scope.usePlugin((0, _dragAxisJsDefault.default));
    }
};

},{"./base.js":"a2Uam","./dragAxis.js":"fJeHb","./hold.js":"cOBti","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"a2Uam":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domUtilsJs = require("../utils/domUtils.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _miscJs = require("../utils/misc.js");
var _interactableMethodsJs = require("./InteractableMethods.js");
var _interactableMethodsJsDefault = parcelHelpers.interopDefault(_interactableMethodsJs);
function install(scope) {
    const { interactStatic: interact , defaults  } = scope;
    scope.usePlugin((0, _interactableMethodsJsDefault.default));
    defaults.base.actionChecker = null;
    defaults.base.styleCursor = true;
    (0, _extendJsDefault.default)(defaults.perAction, {
        manualStart: false,
        max: Infinity,
        maxPerElement: 1,
        allowFrom: null,
        ignoreFrom: null,
        // only allow left button by default
        // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value
        mouseButtons: 1
    });
    /**
   * Returns or sets the maximum number of concurrent interactions allowed.  By
   * default only 1 interaction is allowed at a time (for backwards
   * compatibility). To allow multiple interactions on the same Interactables and
   * elements, you need to enable it in the draggable, resizable and gesturable
   * `'max'` and `'maxPerElement'` options.
   *
   * @alias module:interact.maxInteractions
   *
   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.
   */ interact.maxInteractions = (newValue)=>maxInteractions(newValue, scope);
    scope.autoStart = {
        // Allow this many interactions to happen simultaneously
        maxInteractions: Infinity,
        withinInteractionLimit,
        cursorElement: null
    };
}
function prepareOnDown({ interaction , pointer , event , eventTarget  }, scope) {
    if (interaction.interacting()) return;
    const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
    prepare(interaction, actionInfo, scope);
}
function prepareOnMove({ interaction , pointer , event , eventTarget  }, scope) {
    if (interaction.pointerType !== "mouse" || interaction.pointerIsDown || interaction.interacting()) return;
    const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
    prepare(interaction, actionInfo, scope);
}
function startOnMove(arg, scope) {
    const { interaction  } = arg;
    if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) return;
    scope.fire("autoStart:before-start", arg);
    const { interactable  } = interaction;
    const actionName = interaction.prepared.name;
    if (actionName && interactable) {
        // check manualStart and interaction limit
        if (interactable.options[actionName].manualStart || !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) interaction.stop();
        else {
            interaction.start(interaction.prepared, interactable, interaction.element);
            setInteractionCursor(interaction, scope);
        }
    }
}
function clearCursorOnStop({ interaction  }, scope) {
    const { interactable  } = interaction;
    if (interactable && interactable.options.styleCursor) setCursor(interaction.element, "", scope);
} // Check if the current interactable supports the action.
// If so, return the validated action. Otherwise, return null
function validateAction(action, interactable, element, eventTarget, scope) {
    if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action, scope)) return action;
    return null;
}
function validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope) {
    for(let i = 0, len = matches.length; i < len; i++){
        const match = matches[i];
        const matchElement = matchElements[i];
        const matchAction = match.getAction(pointer, event, interaction, matchElement);
        if (!matchAction) continue;
        const action = validateAction(matchAction, match, matchElement, eventTarget, scope);
        if (action) return {
            action,
            interactable: match,
            element: matchElement
        };
    }
    return {
        action: null,
        interactable: null,
        element: null
    };
}
function getActionInfo(interaction, pointer, event, eventTarget, scope) {
    let matches = [];
    let matchElements = [];
    let element = eventTarget;
    function pushMatches(interactable) {
        matches.push(interactable);
        matchElements.push(element);
    }
    while((0, _isJsDefault.default).element(element)){
        matches = [];
        matchElements = [];
        scope.interactables.forEachMatch(element, pushMatches);
        const actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope);
        if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) return actionInfo;
        element = _domUtilsJs.parentNode(element);
    }
    return {
        action: null,
        interactable: null,
        element: null
    };
}
function prepare(interaction, { action , interactable , element  }, scope) {
    action = action || {
        name: null
    };
    interaction.interactable = interactable;
    interaction.element = element;
    (0, _miscJs.copyAction)(interaction.prepared, action);
    interaction.rect = interactable && action.name ? interactable.getRect(element) : null;
    setInteractionCursor(interaction, scope);
    scope.fire("autoStart:prepared", {
        interaction
    });
}
function withinInteractionLimit(interactable, element, action, scope) {
    const options = interactable.options;
    const maxActions = options[action.name].max;
    const maxPerElement = options[action.name].maxPerElement;
    const autoStartMax = scope.autoStart.maxInteractions;
    let activeInteractions = 0;
    let interactableCount = 0;
    let elementCount = 0; // no actions if any of these values == 0
    if (!(maxActions && maxPerElement && autoStartMax)) return false;
    for (const interaction of scope.interactions.list){
        const otherAction = interaction.prepared.name;
        if (!interaction.interacting()) continue;
        activeInteractions++;
        if (activeInteractions >= autoStartMax) return false;
        if (interaction.interactable !== interactable) continue;
        interactableCount += otherAction === action.name ? 1 : 0;
        if (interactableCount >= maxActions) return false;
        if (interaction.element === element) {
            elementCount++;
            if (otherAction === action.name && elementCount >= maxPerElement) return false;
        }
    }
    return autoStartMax > 0;
}
function maxInteractions(newValue, scope) {
    if ((0, _isJsDefault.default).number(newValue)) {
        scope.autoStart.maxInteractions = newValue;
        return this;
    }
    return scope.autoStart.maxInteractions;
}
function setCursor(element, cursor, scope) {
    const { cursorElement: prevCursorElement  } = scope.autoStart;
    if (prevCursorElement && prevCursorElement !== element) prevCursorElement.style.cursor = "";
    element.ownerDocument.documentElement.style.cursor = cursor;
    element.style.cursor = cursor;
    scope.autoStart.cursorElement = cursor ? element : null;
}
function setInteractionCursor(interaction, scope) {
    const { interactable , element , prepared  } = interaction;
    if (!(interaction.pointerType === "mouse" && interactable && interactable.options.styleCursor)) {
        // clear previous target element cursor
        if (scope.autoStart.cursorElement) setCursor(scope.autoStart.cursorElement, "", scope);
        return;
    }
    let cursor = "";
    if (prepared.name) {
        const cursorChecker = interactable.options[prepared.name].cursorChecker;
        if ((0, _isJsDefault.default).func(cursorChecker)) cursor = cursorChecker(prepared, interactable, element, interaction._interacting);
        else cursor = scope.actions.map[prepared.name].getCursor(prepared);
    }
    setCursor(interaction.element, cursor || "", scope);
}
const autoStart = {
    id: "auto-start/base",
    before: [
        "actions"
    ],
    install,
    listeners: {
        "interactions:down": prepareOnDown,
        "interactions:move": (arg, scope)=>{
            prepareOnMove(arg, scope);
            startOnMove(arg, scope);
        },
        "interactions:stop": clearCursorOnStop
    },
    maxInteractions,
    withinInteractionLimit,
    validateAction
};
exports.default = autoStart;

},{"../utils/domUtils.js":"813v2","../utils/extend.js":"cmcmr","../utils/is.js":"iRtxa","../utils/misc.js":"ckG7O","./InteractableMethods.js":"aurzh","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ckG7O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "warnOnce", ()=>warnOnce);
parcelHelpers.export(exports, "copyAction", ()=>copyAction);
parcelHelpers.export(exports, "sign", ()=>sign);
var _windowJs = require("./window.js");
function warnOnce(method, message) {
    let warned = false;
    return function() {
        if (!warned) {
            (0, _windowJs.window).console.warn(message);
            warned = true;
        }
        return method.apply(this, arguments);
    };
}
function copyAction(dest, src) {
    dest.name = src.name;
    dest.axis = src.axis;
    dest.edges = src.edges;
    return dest;
}
const sign = (n)=>n >= 0 ? 1 : -1;

},{"./window.js":"lQsRi","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"aurzh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _miscJs = require("../utils/misc.js");
function install(scope) {
    const { /** @lends Interactable */ Interactable // tslint:disable-line no-shadowed-variable
     } = scope;
    Interactable.prototype.getAction = function getAction(pointer, event, interaction, element) {
        const action = defaultActionChecker(this, event, interaction, element, scope);
        if (this.options.actionChecker) return this.options.actionChecker(pointer, event, action, this, element, interaction);
        return action;
    };
    /**
   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any
   * of it's parents match the given CSS selector or Element, no
   * drag/resize/gesture is started.
   *
   * @deprecated
   * Don't use this method. Instead set the `ignoreFrom` option for each action
   * or for `pointerEvents`
   *
   * ```js
   * interact(targett)
   *   .draggable({
   *     ignoreFrom: 'input, textarea, a[href]'',
   *   })
   *   .pointerEvents({
   *     ignoreFrom: '[no-pointer]',
   *   })
   * ```
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to not ignore any elements
   * @return {string | Element | object} The current ignoreFrom value or this
   * Interactable
   */ Interactable.prototype.ignoreFrom = (0, _miscJs.warnOnce)(function(newValue) {
        return this._backCompatOption("ignoreFrom", newValue);
    }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).");
    /**
   *
   * A drag/resize/gesture is started only If the target of the `mousedown`,
   * `pointerdown` or `touchstart` event or any of it's parents match the given
   * CSS selector or Element.
   *
   * @deprecated
   * Don't use this method. Instead set the `allowFrom` option for each action
   * or for `pointerEvents`
   *
   * ```js
   * interact(targett)
   *   .resizable({
   *     allowFrom: '.resize-handle',
   *   .pointerEvents({
   *     allowFrom: '.handle',,
   *   })
   * ```
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to allow from any element
   * @return {string | Element | object} The current allowFrom value or this
   * Interactable
   */ Interactable.prototype.allowFrom = (0, _miscJs.warnOnce)(function(newValue) {
        return this._backCompatOption("allowFrom", newValue);
    }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).");
    /**
   * ```js
   * interact('.resize-drag')
   *   .resizable(true)
   *   .draggable(true)
   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {
   *
   *     if (interact.matchesSelector(event.target, '.drag-handle')) {
   *       // force drag with handle target
   *       action.name = drag
   *     }
   *     else {
   *       // resize from the top and right edges
   *       action.name  = 'resize'
   *       action.edges = { top: true, right: true }
   *     }
   *
   *     return action
   * })
   * ```
   *
   * Returns or sets the function used to check action to be performed on
   * pointerDown
   *
   * @param {function | null} [checker] A function which takes a pointer event,
   * defaultAction string, interactable, element and interaction as parameters
   * and returns an object with name property 'drag' 'resize' or 'gesture' and
   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right
   * props.
   * @return {Function | Interactable} The checker function or this Interactable
   */ Interactable.prototype.actionChecker = actionChecker;
    /**
   * Returns or sets whether the the cursor should be changed depending on the
   * action that would be performed if the mouse were pressed and dragged.
   *
   * @param {boolean} [newValue]
   * @return {boolean | Interactable} The current setting or this Interactable
   */ Interactable.prototype.styleCursor = styleCursor;
}
function defaultActionChecker(interactable, event, interaction, element, scope) {
    const rect = interactable.getRect(element);
    const buttons = event.buttons || ({
        0: 1,
        1: 4,
        3: 8,
        4: 16
    })[event.button];
    const arg = {
        action: null,
        interactable,
        interaction,
        element,
        rect,
        buttons
    };
    scope.fire("auto-start:check", arg);
    return arg.action;
}
function styleCursor(newValue) {
    if ((0, _isJsDefault.default).bool(newValue)) {
        this.options.styleCursor = newValue;
        return this;
    }
    if (newValue === null) {
        delete this.options.styleCursor;
        return this;
    }
    return this.options.styleCursor;
}
function actionChecker(checker) {
    if ((0, _isJsDefault.default).func(checker)) {
        this.options.actionChecker = checker;
        return this;
    }
    if (checker === null) {
        delete this.options.actionChecker;
        return this;
    }
    return this.options.actionChecker;
}
exports.default = {
    id: "auto-start/interactableMethods",
    install
};

},{"../utils/is.js":"iRtxa","../utils/misc.js":"ckG7O","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"fJeHb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domUtilsJs = require("../utils/domUtils.js");
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _baseJs = require("./base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
function beforeStart({ interaction , eventTarget , dx , dy  }, scope) {
    if (interaction.prepared.name !== "drag") return; // check if a drag is in the correct axis
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const targetOptions = interaction.interactable.options.drag;
    const startAxis = targetOptions.startAxis;
    const currentAxis = absX > absY ? "x" : absX < absY ? "y" : "xy";
    interaction.prepared.axis = targetOptions.lockAxis === "start" ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'
     : targetOptions.lockAxis; // if the movement isn't in the startAxis of the interactable
    if (currentAxis !== "xy" && startAxis !== "xy" && startAxis !== currentAxis) {
        interaction.prepared.name = null; // then try to get a drag from another ineractable
        let element = eventTarget;
        const getDraggable = function(interactable) {
            if (interactable === interaction.interactable) return;
            const options = interaction.interactable.options.drag;
            if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {
                const action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);
                if (action && action.name === "drag" && checkStartAxis(currentAxis, interactable) && (0, _baseJsDefault.default).validateAction(action, interactable, element, eventTarget, scope)) return interactable;
            }
        }; // check all interactables
        while((0, _isJsDefault.default).element(element)){
            const interactable = scope.interactables.forEachMatch(element, getDraggable);
            if (interactable) {
                interaction.prepared.name = "drag";
                interaction.interactable = interactable;
                interaction.element = element;
                break;
            }
            element = (0, _domUtilsJs.parentNode)(element);
        }
    }
}
function checkStartAxis(startAxis, interactable) {
    if (!interactable) return false;
    const thisAxis = interactable.options.drag.startAxis;
    return startAxis === "xy" || thisAxis === "xy" || thisAxis === startAxis;
}
exports.default = {
    id: "auto-start/dragAxis",
    listeners: {
        "autoStart:before-start": beforeStart
    }
};

},{"../utils/domUtils.js":"813v2","../utils/is.js":"iRtxa","./base.js":"a2Uam","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cOBti":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseJs = require("./base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
function install(scope) {
    const { defaults  } = scope;
    scope.usePlugin((0, _baseJsDefault.default));
    defaults.perAction.hold = 0;
    defaults.perAction.delay = 0;
}
function getHoldDuration(interaction) {
    const actionName = interaction.prepared && interaction.prepared.name;
    if (!actionName) return null;
    const options = interaction.interactable.options;
    return options[actionName].hold || options[actionName].delay;
}
const hold = {
    id: "auto-start/hold",
    install,
    listeners: {
        "interactions:new": ({ interaction  })=>{
            interaction.autoStartHoldTimer = null;
        },
        "autoStart:prepared": ({ interaction  })=>{
            const hold = getHoldDuration(interaction);
            if (hold > 0) interaction.autoStartHoldTimer = setTimeout(()=>{
                interaction.start(interaction.prepared, interaction.interactable, interaction.element);
            }, hold);
        },
        "interactions:move": ({ interaction , duplicate  })=>{
            if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {
                clearTimeout(interaction.autoStartHoldTimer);
                interaction.autoStartHoldTimer = null;
            }
        },
        // prevent regular down->move autoStart
        "autoStart:before-start": ({ interaction  })=>{
            const holdDuration = getHoldDuration(interaction);
            if (holdDuration > 0) interaction.prepared.name = null;
        }
    },
    getHoldDuration
};
exports.default = hold;

},{"./base.js":"a2Uam","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bzEAu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "install", ()=>install);
var _domUtilsJs = require("../utils/domUtils.js");
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _windowJs = require("../utils/window.js");
function preventDefault(newValue) {
    if (/^(always|never|auto)$/.test(newValue)) {
        this.options.preventDefault = newValue;
        return this;
    }
    if ((0, _isJsDefault.default).bool(newValue)) {
        this.options.preventDefault = newValue ? "always" : "never";
        return this;
    }
    return this.options.preventDefault;
}
function checkAndPreventDefault(interactable, scope, event) {
    const setting = interactable.options.preventDefault;
    if (setting === "never") return;
    if (setting === "always") {
        event.preventDefault();
        return;
    } // setting === 'auto'
    // if the browser supports passive event listeners and isn't running on iOS,
    // don't preventDefault of touch{start,move} events. CSS touch-action and
    // user-select should be used instead of calling event.preventDefault().
    if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {
        const doc = (0, _windowJs.getWindow)(event.target).document;
        const docOptions = scope.getDocOptions(doc);
        if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) return;
    } // don't preventDefault of pointerdown events
    if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) return;
     // don't preventDefault on editable elements
    if ((0, _isJsDefault.default).element(event.target) && (0, _domUtilsJs.matchesSelector)(event.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *")) return;
    event.preventDefault();
}
function onInteractionEvent({ interaction , event  }) {
    if (interaction.interactable) interaction.interactable.checkAndPreventDefault(event);
}
function install(scope) {
    /** @lends Interactable */ const { Interactable  } = scope;
    /**
   * Returns or sets whether to prevent the browser's default behaviour in
   * response to pointer events. Can be set to:
   *  - `'always'` to always prevent
   *  - `'never'` to never prevent
   *  - `'auto'` to let interact.js try to determine what would be best
   *
   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`
   * @return {string | Interactable} The current setting or this Interactable
   */ Interactable.prototype.preventDefault = preventDefault;
    Interactable.prototype.checkAndPreventDefault = function(event) {
        return checkAndPreventDefault(this, scope, event);
    }; // prevent native HTML5 drag on interact.js target elements
    scope.interactions.docEvents.push({
        type: "dragstart",
        listener (event) {
            for (const interaction of scope.interactions.list)if (interaction.element && (interaction.element === event.target || (0, _domUtilsJs.nodeContains)(interaction.element, event.target))) {
                interaction.interactable.checkAndPreventDefault(event);
                return;
            }
        }
    });
}
exports.default = {
    id: "core/interactablePreventDefault",
    install,
    listeners: [
        "down",
        "move",
        "up",
        "cancel"
    ].reduce((acc, eventType)=>{
        acc[`interactions:${eventType}`] = onInteractionEvent;
        return acc;
    }, {})
};

},{"../utils/domUtils.js":"813v2","../utils/is.js":"iRtxa","../utils/window.js":"lQsRi","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cnVWp":[function(require,module,exports) {
// eslint-disable-next-line import/no-extraneous-dependencies
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pluginJs = require("./visualizer/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _domObjectsJs = require("../utils/domObjects.js");
var _domObjectsJsDefault = parcelHelpers.interopDefault(_domObjectsJs);
var _domUtilsJs = require("../utils/domUtils.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _windowJs = require("../utils/window.js");
var CheckName;
(function(CheckName) {
    CheckName["touchAction"] = "touchAction";
    CheckName["boxSizing"] = "boxSizing";
    CheckName["noListeners"] = "noListeners";
})(CheckName || (CheckName = {}));
const prefix = "[interact.js] ";
const links = {
    touchAction: "https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",
    boxSizing: "https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"
}; // eslint-disable-next-line no-undef
const isProduction = false;
function install(scope, { logger  } = {}) {
    const { Interactable , defaults  } = scope;
    scope.logger = logger || console;
    defaults.base.devTools = {
        ignore: {}
    };
    Interactable.prototype.devTools = function(options) {
        if (options) {
            (0, _extendJsDefault.default)(this.options.devTools, options);
            return this;
        }
        return this.options.devTools;
    };
    scope.usePlugin((0, _pluginJsDefault.default));
}
const checks = [
    {
        name: CheckName.touchAction,
        perform ({ element  }) {
            return !parentHasStyle(element, "touchAction", /pan-|pinch|none/);
        },
        getInfo ({ element  }) {
            return [
                element,
                links.touchAction
            ];
        },
        text: 'Consider adding CSS "touch-action: none" to this element\n'
    },
    {
        name: CheckName.boxSizing,
        perform (interaction) {
            const { element  } = interaction;
            return interaction.prepared.name === "resize" && element instanceof (0, _domObjectsJsDefault.default).HTMLElement && !hasStyle(element, "boxSizing", /border-box/);
        },
        text: 'Consider adding CSS "box-sizing: border-box" to this resizable element',
        getInfo ({ element  }) {
            return [
                element,
                links.boxSizing
            ];
        }
    },
    {
        name: CheckName.noListeners,
        perform (interaction) {
            const actionName = interaction.prepared.name;
            const moveListeners = interaction.interactable.events.types[`${actionName}move`] || [];
            return !moveListeners.length;
        },
        getInfo (interaction) {
            return [
                interaction.prepared.name,
                interaction.interactable
            ];
        },
        text: "There are no listeners set for this action"
    }
];
function hasStyle(element, prop, styleRe) {
    const value = element.style[prop] || _windowJs.window.getComputedStyle(element)[prop];
    return styleRe.test((value || "").toString());
}
function parentHasStyle(element, prop, styleRe) {
    let parent = element;
    while((0, _isJsDefault.default).element(parent)){
        if (hasStyle(parent, prop, styleRe)) return true;
        parent = (0, _domUtilsJs.parentNode)(parent);
    }
    return false;
}
const id = "dev-tools";
const defaultExport = isProduction ? {
    id,
    install: ()=>{}
} : {
    id,
    install,
    listeners: {
        "interactions:action-start": ({ interaction  }, scope)=>{
            for (const check of checks){
                const options = interaction.interactable && interaction.interactable.options;
                if (!(options && options.devTools && options.devTools.ignore[check.name]) && check.perform(interaction)) scope.logger.warn(prefix + check.text, ...check.getInfo(interaction));
            }
        }
    },
    checks,
    CheckName,
    links,
    prefix
};
exports.default = defaultExport;

},{"./visualizer/plugin.js":"68OYR","../utils/domObjects.js":"c7ipJ","../utils/domUtils.js":"813v2","../utils/extend.js":"cmcmr","../utils/is.js":"iRtxa","../utils/window.js":"lQsRi","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"68OYR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"e5sCX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InertiaState", ()=>InertiaState);
var _modificationJs = require("../modifiers/Modification.js");
var _modificationJsDefault = parcelHelpers.interopDefault(_modificationJs);
var _baseJs = require("../modifiers/base.js");
var _pluginJs = require("../offset/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _domUtilsJs = require("../utils/domUtils.js");
var _hypotJs = require("../utils/hypot.js");
var _hypotJsDefault = parcelHelpers.interopDefault(_hypotJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _pointerUtilsJs = require("../utils/pointerUtils.js");
var _rafJs = require("../utils/raf.js");
var _rafJsDefault = parcelHelpers.interopDefault(_rafJs);
function install(scope) {
    const { defaults  } = scope;
    scope.usePlugin((0, _pluginJsDefault.default));
    scope.usePlugin(_baseJs.default);
    scope.actions.phases.inertiastart = true;
    scope.actions.phases.resume = true;
    defaults.perAction.inertia = {
        enabled: false,
        resistance: 10,
        // the lambda in exponential decay
        minSpeed: 100,
        // target speed must be above this for inertia to start
        endSpeed: 10,
        // the speed at which inertia is slow enough to stop
        allowResume: true,
        // allow resuming an action in inertia phase
        smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia
    };
}
class InertiaState {
    active = false;
    isModified = false;
    smoothEnd = false;
    allowResume = false;
    modification;
    modifierCount = 0;
    modifierArg;
    startCoords;
    t0 = 0;
    v0 = 0;
    te = 0;
    targetOffset;
    modifiedOffset;
    currentOffset;
    lambda_v0 = 0;
    one_ve_v0 = 0;
    timeout;
    interaction;
    constructor(interaction){
        this.interaction = interaction;
    }
    start(event) {
        const { interaction  } = this;
        const options = getOptions(interaction);
        if (!options || !options.enabled) return false;
        const { client: velocityClient  } = interaction.coords.velocity;
        const pointerSpeed = (0, _hypotJsDefault.default)(velocityClient.x, velocityClient.y);
        const modification = this.modification || (this.modification = new (0, _modificationJsDefault.default)(interaction));
        modification.copyFrom(interaction.modification);
        this.t0 = interaction._now();
        this.allowResume = options.allowResume;
        this.v0 = pointerSpeed;
        this.currentOffset = {
            x: 0,
            y: 0
        };
        this.startCoords = interaction.coords.cur.page;
        this.modifierArg = modification.fillArg({
            pageCoords: this.startCoords,
            preEnd: true,
            phase: "inertiastart"
        });
        const thrown = this.t0 - interaction.coords.cur.timeStamp < 50 && pointerSpeed > options.minSpeed && pointerSpeed > options.endSpeed;
        if (thrown) this.startInertia();
        else {
            modification.result = modification.setAll(this.modifierArg);
            if (!modification.result.changed) return false;
            this.startSmoothEnd();
        } // force modification change
        interaction.modification.result.rect = null; // bring inertiastart event to the target coords
        interaction.offsetBy(this.targetOffset);
        interaction._doPhase({
            interaction,
            event,
            phase: "inertiastart"
        });
        interaction.offsetBy({
            x: -this.targetOffset.x,
            y: -this.targetOffset.y
        }); // force modification change
        interaction.modification.result.rect = null;
        this.active = true;
        interaction.simulation = this;
        return true;
    }
    startInertia() {
        const startVelocity = this.interaction.coords.velocity.client;
        const options = getOptions(this.interaction);
        const lambda = options.resistance;
        const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda;
        this.targetOffset = {
            x: (startVelocity.x - inertiaDur) / lambda,
            y: (startVelocity.y - inertiaDur) / lambda
        };
        this.te = inertiaDur;
        this.lambda_v0 = lambda / this.v0;
        this.one_ve_v0 = 1 - options.endSpeed / this.v0;
        const { modification , modifierArg  } = this;
        modifierArg.pageCoords = {
            x: this.startCoords.x + this.targetOffset.x,
            y: this.startCoords.y + this.targetOffset.y
        };
        modification.result = modification.setAll(modifierArg);
        if (modification.result.changed) {
            this.isModified = true;
            this.modifiedOffset = {
                x: this.targetOffset.x + modification.result.delta.x,
                y: this.targetOffset.y + modification.result.delta.y
            };
        }
        this.onNextFrame(()=>this.inertiaTick());
    }
    startSmoothEnd() {
        this.smoothEnd = true;
        this.isModified = true;
        this.targetOffset = {
            x: this.modification.result.delta.x,
            y: this.modification.result.delta.y
        };
        this.onNextFrame(()=>this.smoothEndTick());
    }
    onNextFrame(tickFn) {
        this.timeout = (0, _rafJsDefault.default).request(()=>{
            if (this.active) tickFn();
        });
    }
    inertiaTick() {
        const { interaction  } = this;
        const options = getOptions(interaction);
        const lambda = options.resistance;
        const t = (interaction._now() - this.t0) / 1000;
        if (t < this.te) {
            const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0;
            let newOffset;
            if (this.isModified) newOffset = getQuadraticCurvePoint(0, 0, this.targetOffset.x, this.targetOffset.y, this.modifiedOffset.x, this.modifiedOffset.y, progress);
            else newOffset = {
                x: this.targetOffset.x * progress,
                y: this.targetOffset.y * progress
            };
            const delta = {
                x: newOffset.x - this.currentOffset.x,
                y: newOffset.y - this.currentOffset.y
            };
            this.currentOffset.x += delta.x;
            this.currentOffset.y += delta.y;
            interaction.offsetBy(delta);
            interaction.move();
            this.onNextFrame(()=>this.inertiaTick());
        } else {
            interaction.offsetBy({
                x: this.modifiedOffset.x - this.currentOffset.x,
                y: this.modifiedOffset.y - this.currentOffset.y
            });
            this.end();
        }
    }
    smoothEndTick() {
        const { interaction  } = this;
        const t = interaction._now() - this.t0;
        const { smoothEndDuration: duration  } = getOptions(interaction);
        if (t < duration) {
            const newOffset = {
                x: easeOutQuad(t, 0, this.targetOffset.x, duration),
                y: easeOutQuad(t, 0, this.targetOffset.y, duration)
            };
            const delta = {
                x: newOffset.x - this.currentOffset.x,
                y: newOffset.y - this.currentOffset.y
            };
            this.currentOffset.x += delta.x;
            this.currentOffset.y += delta.y;
            interaction.offsetBy(delta);
            interaction.move({
                skipModifiers: this.modifierCount
            });
            this.onNextFrame(()=>this.smoothEndTick());
        } else {
            interaction.offsetBy({
                x: this.targetOffset.x - this.currentOffset.x,
                y: this.targetOffset.y - this.currentOffset.y
            });
            this.end();
        }
    }
    resume({ pointer , event , eventTarget  }) {
        const { interaction  } = this; // undo inertia changes to interaction coords
        interaction.offsetBy({
            x: -this.currentOffset.x,
            y: -this.currentOffset.y
        }); // update pointer at pointer down position
        interaction.updatePointer(pointer, event, eventTarget, true); // fire resume signals and event
        interaction._doPhase({
            interaction,
            event,
            phase: "resume"
        });
        (0, _pointerUtilsJs.copyCoords)(interaction.coords.prev, interaction.coords.cur);
        this.stop();
    }
    end() {
        this.interaction.move();
        this.interaction.end();
        this.stop();
    }
    stop() {
        this.active = this.smoothEnd = false;
        this.interaction.simulation = null;
        (0, _rafJsDefault.default).cancel(this.timeout);
    }
}
function start({ interaction , event  }) {
    if (!interaction._interacting || interaction.simulation) return null;
    const started = interaction.inertia.start(event); // prevent action end if inertia or smoothEnd
    return started ? false : null;
} // Check if the down event hits the current inertia target
// control should be return to the user
function resume(arg) {
    const { interaction , eventTarget  } = arg;
    const state = interaction.inertia;
    if (!state.active) return;
    let element = eventTarget; // climb up the DOM tree from the event target
    while((0, _isJsDefault.default).element(element)){
        // if interaction element is the current inertia target element
        if (element === interaction.element) {
            state.resume(arg);
            break;
        }
        element = _domUtilsJs.parentNode(element);
    }
}
function stop({ interaction  }) {
    const state = interaction.inertia;
    if (state.active) state.stop();
}
function getOptions({ interactable , prepared  }) {
    return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia;
}
const inertia = {
    id: "inertia",
    before: [
        "modifiers",
        "actions"
    ],
    install,
    listeners: {
        "interactions:new": ({ interaction  })=>{
            interaction.inertia = new InertiaState(interaction);
        },
        "interactions:before-action-end": start,
        "interactions:down": resume,
        "interactions:stop": stop,
        "interactions:before-action-resume": (arg)=>{
            const { modification  } = arg.interaction;
            modification.stop(arg);
            modification.start(arg, arg.interaction.coords.cur.page);
            modification.applyToInteraction(arg);
        },
        "interactions:before-action-inertiastart": (arg)=>arg.interaction.modification.setAndApply(arg),
        "interactions:action-resume": _baseJs.addEventModifiers,
        "interactions:action-inertiastart": _baseJs.addEventModifiers,
        "interactions:after-action-inertiastart": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg),
        "interactions:after-action-resume": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg)
    }
}; // http://stackoverflow.com/a/5634528/2280888
function _getQBezierValue(t, p1, p2, p3) {
    const iT = 1 - t;
    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;
}
function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {
    return {
        x: _getQBezierValue(position, startX, cpX, endX),
        y: _getQBezierValue(position, startY, cpY, endY)
    };
} // http://gizma.com/easing/
function easeOutQuad(t, b, c, d) {
    t /= d;
    return -c * t * (t - 2) + b;
}
exports.default = inertia;

},{"../modifiers/Modification.js":"iWpmt","../modifiers/base.js":"2oZRZ","../offset/plugin.js":"9Nc0j","../utils/domUtils.js":"813v2","../utils/hypot.js":"ekLIq","../utils/is.js":"iRtxa","../utils/pointerUtils.js":"g0cI1","../utils/raf.js":"54IvB","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iWpmt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRectOffset", ()=>getRectOffset);
var _cloneJs = require("../utils/clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _rectJs = require("../utils/rect.js");
class Modification {
    states = [];
    startOffset = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    startDelta;
    result;
    endResult;
    edges;
    interaction;
    constructor(interaction){
        this.interaction = interaction;
        this.result = createResult();
    }
    start({ phase  }, pageCoords) {
        const { interaction  } = this;
        const modifierList = getModifierList(interaction);
        this.prepareStates(modifierList);
        this.edges = (0, _extendJsDefault.default)({}, interaction.edges);
        this.startOffset = getRectOffset(interaction.rect, pageCoords);
        this.startDelta = {
            x: 0,
            y: 0
        };
        const arg = this.fillArg({
            phase,
            pageCoords,
            preEnd: false
        });
        this.result = createResult();
        this.startAll(arg);
        const result = this.result = this.setAll(arg);
        return result;
    }
    fillArg(arg) {
        const { interaction  } = this;
        arg.interaction = interaction;
        arg.interactable = interaction.interactable;
        arg.element = interaction.element;
        arg.rect = arg.rect || interaction.rect;
        arg.edges = this.edges;
        arg.startOffset = this.startOffset;
        return arg;
    }
    startAll(arg) {
        for (const state of this.states)if (state.methods.start) {
            arg.state = state;
            state.methods.start(arg);
        }
    }
    setAll(arg) {
        const { phase , preEnd , skipModifiers , rect: unmodifiedRect  } = arg;
        arg.coords = (0, _extendJsDefault.default)({}, arg.pageCoords);
        arg.rect = (0, _extendJsDefault.default)({}, unmodifiedRect);
        const states = skipModifiers ? this.states.slice(skipModifiers) : this.states;
        const newResult = createResult(arg.coords, arg.rect);
        for (const state of states){
            var _state$methods;
            const { options  } = state;
            const lastModifierCoords = (0, _extendJsDefault.default)({}, arg.coords);
            let returnValue = null;
            if ((_state$methods = state.methods) != null && _state$methods.set && this.shouldDo(options, preEnd, phase)) {
                arg.state = state;
                returnValue = state.methods.set(arg);
                _rectJs.addEdges(this.interaction.edges, arg.rect, {
                    x: arg.coords.x - lastModifierCoords.x,
                    y: arg.coords.y - lastModifierCoords.y
                });
            }
            newResult.eventProps.push(returnValue);
        }
        newResult.delta.x = arg.coords.x - arg.pageCoords.x;
        newResult.delta.y = arg.coords.y - arg.pageCoords.y;
        newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left;
        newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right;
        newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top;
        newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom;
        const prevCoords = this.result.coords;
        const prevRect = this.result.rect;
        if (prevCoords && prevRect) {
            const rectChanged = newResult.rect.left !== prevRect.left || newResult.rect.right !== prevRect.right || newResult.rect.top !== prevRect.top || newResult.rect.bottom !== prevRect.bottom;
            newResult.changed = rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y;
        }
        return newResult;
    }
    applyToInteraction(arg) {
        const { interaction  } = this;
        const { phase  } = arg;
        const curCoords = interaction.coords.cur;
        const startCoords = interaction.coords.start;
        const { result , startDelta  } = this;
        const curDelta = result.delta;
        if (phase === "start") (0, _extendJsDefault.default)(this.startDelta, result.delta);
        for (const [coordsSet, delta] of [
            [
                startCoords,
                startDelta
            ],
            [
                curCoords,
                curDelta
            ]
        ]){
            coordsSet.page.x += delta.x;
            coordsSet.page.y += delta.y;
            coordsSet.client.x += delta.x;
            coordsSet.client.y += delta.y;
        }
        const { rectDelta  } = this.result;
        const rect = arg.rect || interaction.rect;
        rect.left += rectDelta.left;
        rect.right += rectDelta.right;
        rect.top += rectDelta.top;
        rect.bottom += rectDelta.bottom;
        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
    }
    setAndApply(arg) {
        const { interaction  } = this;
        const { phase , preEnd , skipModifiers  } = arg;
        const result = this.setAll(this.fillArg({
            preEnd,
            phase,
            pageCoords: arg.modifiedCoords || interaction.coords.cur.page
        }));
        this.result = result; // don't fire an action move if a modifier would keep the event in the same
        // cordinates as before
        if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) return false;
        if (arg.modifiedCoords) {
            const { page  } = interaction.coords.cur;
            const adjustment = {
                x: arg.modifiedCoords.x - page.x,
                y: arg.modifiedCoords.y - page.y
            };
            result.coords.x += adjustment.x;
            result.coords.y += adjustment.y;
            result.delta.x += adjustment.x;
            result.delta.y += adjustment.y;
        }
        this.applyToInteraction(arg);
    }
    beforeEnd(arg) {
        const { interaction , event  } = arg;
        const states = this.states;
        if (!states || !states.length) return;
        let doPreend = false;
        for (const state of states){
            arg.state = state;
            const { options , methods  } = state;
            const endPosition = methods.beforeEnd && methods.beforeEnd(arg);
            if (endPosition) {
                this.endResult = endPosition;
                return false;
            }
            doPreend = doPreend || !doPreend && this.shouldDo(options, true, arg.phase, true);
        }
        if (doPreend) // trigger a final modified move before ending
        interaction.move({
            event,
            preEnd: true
        });
    }
    stop(arg) {
        const { interaction  } = arg;
        if (!this.states || !this.states.length) return;
        const modifierArg = (0, _extendJsDefault.default)({
            states: this.states,
            interactable: interaction.interactable,
            element: interaction.element,
            rect: null
        }, arg);
        this.fillArg(modifierArg);
        for (const state of this.states){
            modifierArg.state = state;
            if (state.methods.stop) state.methods.stop(modifierArg);
        }
        this.states = null;
        this.endResult = null;
    }
    prepareStates(modifierList) {
        this.states = [];
        for(let index = 0; index < modifierList.length; index++){
            const { options , methods , name  } = modifierList[index];
            this.states.push({
                options,
                methods,
                index,
                name
            });
        }
        return this.states;
    }
    restoreInteractionCoords({ interaction: { coords , rect , modification  }  }) {
        if (!modification.result) return;
        const { startDelta  } = modification;
        const { delta: curDelta , rectDelta  } = modification.result;
        const coordsAndDeltas = [
            [
                coords.start,
                startDelta
            ],
            [
                coords.cur,
                curDelta
            ]
        ];
        for (const [coordsSet, delta] of coordsAndDeltas){
            coordsSet.page.x -= delta.x;
            coordsSet.page.y -= delta.y;
            coordsSet.client.x -= delta.x;
            coordsSet.client.y -= delta.y;
        }
        rect.left -= rectDelta.left;
        rect.right -= rectDelta.right;
        rect.top -= rectDelta.top;
        rect.bottom -= rectDelta.bottom;
    }
    shouldDo(options, preEnd, phase, requireEndOnly) {
        if (!options || options.enabled === false || // check if we require endOnly option to fire move before end
        requireEndOnly && !options.endOnly || // don't apply endOnly modifiers when not ending
        options.endOnly && !preEnd || // check if modifier should run be applied on start
        phase === "start" && !options.setStart) return false;
        return true;
    }
    copyFrom(other) {
        this.startOffset = other.startOffset;
        this.startDelta = other.startDelta;
        this.edges = other.edges;
        this.states = other.states.map((s)=>(0, _cloneJsDefault.default)(s));
        this.result = createResult((0, _extendJsDefault.default)({}, other.result.coords), (0, _extendJsDefault.default)({}, other.result.rect));
    }
    destroy() {
        for(const prop in this)this[prop] = null;
    }
}
exports.default = Modification;
function createResult(coords, rect) {
    return {
        rect,
        coords,
        delta: {
            x: 0,
            y: 0
        },
        rectDelta: {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        eventProps: [],
        changed: true
    };
}
function getModifierList(interaction) {
    const actionOptions = interaction.interactable.options[interaction.prepared.name];
    const actionModifiers = actionOptions.modifiers;
    if (actionModifiers && actionModifiers.length) return actionModifiers;
    return [
        "snap",
        "snapSize",
        "snapEdges",
        "restrict",
        "restrictEdges",
        "restrictSize"
    ].map((type)=>{
        const options = actionOptions[type];
        return options && options.enabled && {
            options,
            methods: options._methods
        };
    }).filter((m)=>!!m);
}
function getRectOffset(rect, coords) {
    return rect ? {
        left: coords.x - rect.left,
        top: coords.y - rect.top,
        right: rect.right - coords.x,
        bottom: rect.bottom - coords.y
    } : {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
    };
}

},{"../utils/clone.js":"hkKOH","../utils/extend.js":"cmcmr","../utils/rect.js":"6qd7M","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hkKOH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrJs = require("./arr.js");
var _isJs = require("./is.js"); // tslint:disable-next-line ban-types
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
function clone(source) {
    const dest = {};
    for(const prop in source){
        const value = source[prop];
        if ((0, _isJsDefault.default).plainObject(value)) dest[prop] = clone(value);
        else if ((0, _isJsDefault.default).array(value)) dest[prop] = _arrJs.from(value);
        else dest[prop] = value;
    }
    return dest;
}
exports.default = clone;

},{"./arr.js":"8BYbE","./is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2oZRZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeModifier", ()=>makeModifier);
parcelHelpers.export(exports, "addEventModifiers", ()=>addEventModifiers);
var _modificationJs = require("./Modification.js");
var _modificationJsDefault = parcelHelpers.interopDefault(_modificationJs);
function makeModifier(module, name) {
    const { defaults  } = module;
    const methods = {
        start: module.start,
        set: module.set,
        beforeEnd: module.beforeEnd,
        stop: module.stop
    };
    const modifier = (_options)=>{
        const options = _options || {};
        options.enabled = options.enabled !== false; // add missing defaults to options
        for(const prop in defaults)if (!(prop in options)) options[prop] = defaults[prop];
        const m = {
            options,
            methods,
            name,
            enable: ()=>{
                options.enabled = true;
                return m;
            },
            disable: ()=>{
                options.enabled = false;
                return m;
            }
        };
        return m;
    };
    if (name && typeof name === "string") {
        // for backwrads compatibility
        modifier._defaults = defaults;
        modifier._methods = methods;
    }
    return modifier;
}
function addEventModifiers({ iEvent , interaction  }) {
    const result = interaction.modification.result;
    if (result) iEvent.modifiers = result.eventProps;
}
const modifiersBase = {
    id: "modifiers/base",
    before: [
        "actions"
    ],
    install: (scope)=>{
        scope.defaults.perAction.modifiers = [];
    },
    listeners: {
        "interactions:new": ({ interaction  })=>{
            interaction.modification = new (0, _modificationJsDefault.default)(interaction);
        },
        "interactions:before-action-start": (arg)=>{
            const modification = arg.interaction.modification;
            modification.start(arg, arg.interaction.coords.start.page);
            arg.interaction.edges = modification.edges;
            modification.applyToInteraction(arg);
        },
        "interactions:before-action-move": (arg)=>arg.interaction.modification.setAndApply(arg),
        "interactions:before-action-end": (arg)=>arg.interaction.modification.beforeEnd(arg),
        "interactions:action-start": addEventModifiers,
        "interactions:action-move": addEventModifiers,
        "interactions:action-end": addEventModifiers,
        "interactions:after-action-start": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg),
        "interactions:after-action-move": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg),
        "interactions:stop": (arg)=>arg.interaction.modification.stop(arg)
    }
};
exports.default = modifiersBase;

},{"./Modification.js":"iWpmt","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9Nc0j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addTotal", ()=>addTotal);
parcelHelpers.export(exports, "applyPending", ()=>applyPending);
var _interactionJs = require("../core/Interaction.js");
var _rectJs = require("../utils/rect.js");
(0, _interactionJs._ProxyMethods).offsetBy = "";
function addTotal(interaction) {
    if (!interaction.pointerIsDown) return;
    addToCoords(interaction.coords.cur, interaction.offset.total);
    interaction.offset.pending.x = 0;
    interaction.offset.pending.y = 0;
}
function beforeAction({ interaction  }) {
    applyPending(interaction);
}
function beforeEnd({ interaction  }) {
    const hadPending = applyPending(interaction);
    if (!hadPending) return;
    interaction.move({
        offset: true
    });
    interaction.end();
    return false;
}
function end({ interaction  }) {
    interaction.offset.total.x = 0;
    interaction.offset.total.y = 0;
    interaction.offset.pending.x = 0;
    interaction.offset.pending.y = 0;
}
function applyPending(interaction) {
    if (!hasPending(interaction)) return false;
    const { pending  } = interaction.offset;
    addToCoords(interaction.coords.cur, pending);
    addToCoords(interaction.coords.delta, pending);
    _rectJs.addEdges(interaction.edges, interaction.rect, pending);
    pending.x = 0;
    pending.y = 0;
    return true;
}
function offsetBy({ x , y  }) {
    this.offset.pending.x += x;
    this.offset.pending.y += y;
    this.offset.total.x += x;
    this.offset.total.y += y;
}
function addToCoords({ page , client  }, { x , y  }) {
    page.x += x;
    page.y += y;
    client.x += x;
    client.y += y;
}
function hasPending(interaction) {
    return !!(interaction.offset.pending.x || interaction.offset.pending.y);
}
const offset = {
    id: "offset",
    before: [
        "modifiers",
        "pointer-events",
        "actions",
        "inertia"
    ],
    install (scope) {
        scope.Interaction.prototype.offsetBy = offsetBy;
    },
    listeners: {
        "interactions:new": ({ interaction  })=>{
            interaction.offset = {
                total: {
                    x: 0,
                    y: 0
                },
                pending: {
                    x: 0,
                    y: 0
                }
            };
        },
        "interactions:update-pointer": ({ interaction  })=>addTotal(interaction),
        "interactions:before-action-start": beforeAction,
        "interactions:before-action-move": beforeAction,
        "interactions:before-action-end": beforeEnd,
        "interactions:stop": end
    }
};
exports.default = offset;

},{"../core/Interaction.js":"eImvN","../utils/rect.js":"6qd7M","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"eImvN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_ProxyValues", ()=>_ProxyValues);
parcelHelpers.export(exports, "_ProxyMethods", ()=>_ProxyMethods);
parcelHelpers.export(exports, "Interaction", ()=>Interaction);
parcelHelpers.export(exports, "PointerInfo", ()=>(0, _pointerInfoJs.PointerInfo));
var _arrJs = require("../utils/arr.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _hypotJs = require("../utils/hypot.js");
var _hypotJsDefault = parcelHelpers.interopDefault(_hypotJs);
var _miscJs = require("../utils/misc.js");
var _pointerUtilsJs = require("../utils/pointerUtils.js");
var _rectJs = require("../utils/rect.js");
var _interactEventJs = require("./InteractEvent.js");
var _pointerInfoJs = require("./PointerInfo.js");
let _ProxyValues;
(function(_ProxyValues) {
    _ProxyValues["interactable"] = "";
    _ProxyValues["element"] = "";
    _ProxyValues["prepared"] = "";
    _ProxyValues["pointerIsDown"] = "";
    _ProxyValues["pointerWasMoved"] = "";
    _ProxyValues["_proxy"] = "";
})(_ProxyValues || (_ProxyValues = {}));
let _ProxyMethods;
(function(_ProxyMethods) {
    _ProxyMethods["start"] = "";
    _ProxyMethods["move"] = "";
    _ProxyMethods["end"] = "";
    _ProxyMethods["stop"] = "";
    _ProxyMethods["interacting"] = "";
})(_ProxyMethods || (_ProxyMethods = {}));
let idCounter = 0;
class Interaction {
    // current interactable being interacted with
    interactable = null;
    element = null;
    rect = null;
    _rects;
    edges = null;
    _scopeFire;
    prepared = {
        name: null,
        axis: null,
        edges: null
    };
    pointerType;
    pointers = [];
    downEvent = null;
    downPointer = {};
    _latestPointer = {
        pointer: null,
        event: null,
        eventTarget: null
    };
    prevEvent = null;
    pointerIsDown = false;
    pointerWasMoved = false;
    _interacting = false;
    _ending = false;
    _stopped = true;
    _proxy = null;
    simulation = null;
    /** @internal */ get pointerMoveTolerance() {
        return 1;
    }
    /**
   * @alias Interaction.prototype.move
   */ doMove = (0, _miscJs.warnOnce)(function(signalArg) {
        this.move(signalArg);
    }, "The interaction.doMove() method has been renamed to interaction.move()");
    coords = {
        // Starting InteractEvent pointer coordinates
        start: _pointerUtilsJs.newCoords(),
        // Previous native pointer move event coordinates
        prev: _pointerUtilsJs.newCoords(),
        // current native pointer move event coordinates
        cur: _pointerUtilsJs.newCoords(),
        // Change in coordinates and time of the pointer
        delta: _pointerUtilsJs.newCoords(),
        // pointer velocity
        velocity: _pointerUtilsJs.newCoords()
    };
    _id = idCounter++;
    /** */ constructor({ pointerType , scopeFire  }){
        this._scopeFire = scopeFire;
        this.pointerType = pointerType;
        const that = this;
        this._proxy = {};
        for(const key in _ProxyValues)Object.defineProperty(this._proxy, key, {
            get () {
                return that[key];
            }
        });
        for(const key1 in _ProxyMethods)Object.defineProperty(this._proxy, key1, {
            value: (...args)=>that[key1](...args)
        });
        this._scopeFire("interactions:new", {
            interaction: this
        });
    }
    pointerDown(pointer, event, eventTarget) {
        const pointerIndex = this.updatePointer(pointer, event, eventTarget, true);
        const pointerInfo = this.pointers[pointerIndex];
        this._scopeFire("interactions:down", {
            pointer,
            event,
            eventTarget,
            pointerIndex,
            pointerInfo,
            type: "down",
            interaction: this
        });
    }
    /**
   * ```js
   * interact(target)
   *   .draggable({
   *     // disable the default drag start by down->move
   *     manualStart: true
   *   })
   *   // start dragging after the user holds the pointer down
   *   .on('hold', function (event) {
   *     var interaction = event.interaction
   *
   *     if (!interaction.interacting()) {
   *       interaction.start({ name: 'drag' },
   *                         event.interactable,
   *                         event.currentTarget)
   *     }
   * })
   * ```
   *
   * Start an action with the given Interactable and Element as tartgets. The
   * action must be enabled for the target Interactable and an appropriate
   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.
   *
   * Use it with `interactable.<action>able({ manualStart: false })` to always
   * [start actions manually](https://github.com/taye/interact.js/issues/114)
   *
   * @param {object} action   The action to be performed - drag, resize, etc.
   * @param {Interactable} target  The Interactable to target
   * @param {Element} element The DOM Element to target
   * @return {Boolean} Whether the interaction was successfully started
   */ start(action, interactable, element) {
        if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === "gesture" ? 2 : 1) || !interactable.options[action.name].enabled) return false;
        (0, _miscJs.copyAction)(this.prepared, action);
        this.interactable = interactable;
        this.element = element;
        this.rect = interactable.getRect(element);
        this.edges = this.prepared.edges ? (0, _extendJsDefault.default)({}, this.prepared.edges) : {
            left: true,
            right: true,
            top: true,
            bottom: true
        };
        this._stopped = false;
        this._interacting = this._doPhase({
            interaction: this,
            event: this.downEvent,
            phase: "start"
        }) && !this._stopped;
        return this._interacting;
    }
    pointerMove(pointer, event, eventTarget) {
        if (!this.simulation && !(this.modification && this.modification.endResult)) this.updatePointer(pointer, event, eventTarget, false);
        const duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        let dx;
        let dy; // register movement greater than pointerMoveTolerance
        if (this.pointerIsDown && !this.pointerWasMoved) {
            dx = this.coords.cur.client.x - this.coords.start.client.x;
            dy = this.coords.cur.client.y - this.coords.start.client.y;
            this.pointerWasMoved = (0, _hypotJsDefault.default)(dx, dy) > this.pointerMoveTolerance;
        }
        const pointerIndex = this.getPointerIndex(pointer);
        const signalArg = {
            pointer,
            pointerIndex,
            pointerInfo: this.pointers[pointerIndex],
            event,
            type: "move",
            eventTarget,
            dx,
            dy,
            duplicate: duplicateMove,
            interaction: this
        };
        if (!duplicateMove) // set pointer coordinate, time changes and velocity
        _pointerUtilsJs.setCoordVelocity(this.coords.velocity, this.coords.delta);
        this._scopeFire("interactions:move", signalArg);
        if (!duplicateMove && !this.simulation) {
            // if interacting, fire an 'action-move' signal etc
            if (this.interacting()) {
                signalArg.type = null;
                this.move(signalArg);
            }
            if (this.pointerWasMoved) _pointerUtilsJs.copyCoords(this.coords.prev, this.coords.cur);
        }
    }
    /**
   * ```js
   * interact(target)
   *   .draggable(true)
   *   .on('dragmove', function (event) {
   *     if (someCondition) {
   *       // change the snap settings
   *       event.interactable.draggable({ snap: { targets: [] }})
   *       // fire another move event with re-calculated snap
   *       event.interaction.move()
   *     }
   *   })
   * ```
   *
   * Force a move of the current action at the same coordinates. Useful if
   * snap/restrict has been changed and you want a movement with the new
   * settings.
   */ move(signalArg) {
        if (!signalArg || !signalArg.event) _pointerUtilsJs.setZeroCoords(this.coords.delta);
        signalArg = (0, _extendJsDefault.default)({
            pointer: this._latestPointer.pointer,
            event: this._latestPointer.event,
            eventTarget: this._latestPointer.eventTarget,
            interaction: this
        }, signalArg || {});
        signalArg.phase = "move";
        this._doPhase(signalArg);
    }
    pointerUp(pointer, event, eventTarget, curEventTarget) {
        let pointerIndex = this.getPointerIndex(pointer);
        if (pointerIndex === -1) pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
        const type = /cancel$/i.test(event.type) ? "cancel" : "up";
        this._scopeFire(`interactions:${type}`, {
            pointer,
            pointerIndex,
            pointerInfo: this.pointers[pointerIndex],
            event,
            eventTarget,
            type: type,
            curEventTarget,
            interaction: this
        });
        if (!this.simulation) this.end(event);
        this.removePointer(pointer, event);
    }
    documentBlur(event) {
        this.end(event);
        this._scopeFire("interactions:blur", {
            event,
            type: "blur",
            interaction: this
        });
    }
    /**
   * ```js
   * interact(target)
   *   .draggable(true)
   *   .on('move', function (event) {
   *     if (event.pageX > 1000) {
   *       // end the current action
   *       event.interaction.end()
   *       // stop all further listeners from being called
   *       event.stopImmediatePropagation()
   *     }
   *   })
   * ```
   *
   * @param {PointerEvent} [event]
   */ end(event) {
        this._ending = true;
        event = event || this._latestPointer.event;
        let endPhaseResult;
        if (this.interacting()) endPhaseResult = this._doPhase({
            event,
            interaction: this,
            phase: "end"
        });
        this._ending = false;
        if (endPhaseResult === true) this.stop();
    }
    currentAction() {
        return this._interacting ? this.prepared.name : null;
    }
    interacting() {
        return this._interacting;
    }
    /** */ stop() {
        this._scopeFire("interactions:stop", {
            interaction: this
        });
        this.interactable = this.element = null;
        this._interacting = false;
        this._stopped = true;
        this.prepared.name = this.prevEvent = null;
    }
    getPointerIndex(pointer) {
        const pointerId = _pointerUtilsJs.getPointerId(pointer); // mouse and pen interactions may have only one pointer
        return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : _arrJs.findIndex(this.pointers, (curPointer)=>curPointer.id === pointerId);
    }
    getPointerInfo(pointer) {
        return this.pointers[this.getPointerIndex(pointer)];
    }
    updatePointer(pointer, event, eventTarget, down) {
        const id = _pointerUtilsJs.getPointerId(pointer);
        let pointerIndex = this.getPointerIndex(pointer);
        let pointerInfo = this.pointers[pointerIndex];
        down = down === false ? false : down || /(down|start)$/i.test(event.type);
        if (!pointerInfo) {
            pointerInfo = new (0, _pointerInfoJs.PointerInfo)(id, pointer, event, null, null);
            pointerIndex = this.pointers.length;
            this.pointers.push(pointerInfo);
        } else pointerInfo.pointer = pointer;
        _pointerUtilsJs.setCoords(this.coords.cur, this.pointers.map((p)=>p.pointer), this._now());
        _pointerUtilsJs.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);
        if (down) {
            this.pointerIsDown = true;
            pointerInfo.downTime = this.coords.cur.timeStamp;
            pointerInfo.downTarget = eventTarget;
            _pointerUtilsJs.pointerExtend(this.downPointer, pointer);
            if (!this.interacting()) {
                _pointerUtilsJs.copyCoords(this.coords.start, this.coords.cur);
                _pointerUtilsJs.copyCoords(this.coords.prev, this.coords.cur);
                this.downEvent = event;
                this.pointerWasMoved = false;
            }
        }
        this._updateLatestPointer(pointer, event, eventTarget);
        this._scopeFire("interactions:update-pointer", {
            pointer,
            event,
            eventTarget,
            down,
            pointerInfo,
            pointerIndex,
            interaction: this
        });
        return pointerIndex;
    }
    removePointer(pointer, event) {
        const pointerIndex = this.getPointerIndex(pointer);
        if (pointerIndex === -1) return;
        const pointerInfo = this.pointers[pointerIndex];
        this._scopeFire("interactions:remove-pointer", {
            pointer,
            event,
            eventTarget: null,
            pointerIndex,
            pointerInfo,
            interaction: this
        });
        this.pointers.splice(pointerIndex, 1);
        this.pointerIsDown = false;
    }
    _updateLatestPointer(pointer, event, eventTarget) {
        this._latestPointer.pointer = pointer;
        this._latestPointer.event = event;
        this._latestPointer.eventTarget = eventTarget;
    }
    destroy() {
        this._latestPointer.pointer = null;
        this._latestPointer.event = null;
        this._latestPointer.eventTarget = null;
    }
    _createPreparedEvent(event, phase, preEnd, type) {
        return new (0, _interactEventJs.InteractEvent)(this, event, this.prepared.name, phase, this.element, preEnd, type);
    }
    _fireEvent(iEvent) {
        var _this$interactable;
        (_this$interactable = this.interactable) == null || _this$interactable.fire(iEvent);
        if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) this.prevEvent = iEvent;
    }
    _doPhase(signalArg) {
        const { event , phase , preEnd , type  } = signalArg;
        const { rect  } = this;
        if (rect && phase === "move") {
            // update the rect changes due to pointer move
            _rectJs.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource]);
            rect.width = rect.right - rect.left;
            rect.height = rect.bottom - rect.top;
        }
        const beforeResult = this._scopeFire(`interactions:before-action-${phase}`, signalArg);
        if (beforeResult === false) return false;
        const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);
        this._scopeFire(`interactions:action-${phase}`, signalArg);
        if (phase === "start") this.prevEvent = iEvent;
        this._fireEvent(iEvent);
        this._scopeFire(`interactions:after-action-${phase}`, signalArg);
        return true;
    }
    _now() {
        return Date.now();
    }
}
exports.default = Interaction;

},{"../utils/arr.js":"8BYbE","../utils/extend.js":"cmcmr","../utils/hypot.js":"ekLIq","../utils/misc.js":"ckG7O","../utils/pointerUtils.js":"g0cI1","../utils/rect.js":"6qd7M","./InteractEvent.js":"iXBLf","./PointerInfo.js":"6qISL","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iXBLf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InteractEvent", ()=>InteractEvent) // getters and setters defined here to support typescript 3.6 and below which
;
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _getOriginXYJs = require("../utils/getOriginXY.js");
var _getOriginXYJsDefault = parcelHelpers.interopDefault(_getOriginXYJs);
var _hypotJs = require("../utils/hypot.js");
var _hypotJsDefault = parcelHelpers.interopDefault(_hypotJs);
var _baseEventJs = require("./BaseEvent.js");
var _optionsJs = require("./options.js");
class InteractEvent extends (0, _baseEventJs.BaseEvent) {
    relatedTarget = null;
    screenX;
    screenY;
    button;
    buttons;
    ctrlKey;
    shiftKey;
    altKey;
    metaKey;
    page;
    client;
    delta;
    rect;
    x0;
    y0;
    t0;
    dt;
    duration;
    clientX0;
    clientY0;
    velocity;
    speed;
    swipe;
    axes;
    preEnd;
    /** */ constructor(interaction, event, actionName, phase, element, preEnd, type){
        super(interaction);
        element = element || interaction.element;
        const target = interaction.interactable;
        const deltaSource = (target && target.options || (0, _optionsJs.defaults)).deltaSource;
        const origin = (0, _getOriginXYJsDefault.default)(target, element, actionName);
        const starting = phase === "start";
        const ending = phase === "end";
        const prevEvent = starting ? this : interaction.prevEvent;
        const coords = starting ? interaction.coords.start : ending ? {
            page: prevEvent.page,
            client: prevEvent.client,
            timeStamp: interaction.coords.cur.timeStamp
        } : interaction.coords.cur;
        this.page = (0, _extendJsDefault.default)({}, coords.page);
        this.client = (0, _extendJsDefault.default)({}, coords.client);
        this.rect = (0, _extendJsDefault.default)({}, interaction.rect);
        this.timeStamp = coords.timeStamp;
        if (!ending) {
            this.page.x -= origin.x;
            this.page.y -= origin.y;
            this.client.x -= origin.x;
            this.client.y -= origin.y;
        }
        this.ctrlKey = event.ctrlKey;
        this.altKey = event.altKey;
        this.shiftKey = event.shiftKey;
        this.metaKey = event.metaKey;
        this.button = event.button;
        this.buttons = event.buttons;
        this.target = element;
        this.currentTarget = element;
        this.preEnd = preEnd;
        this.type = type || actionName + (phase || "");
        this.interactable = target;
        this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
        this.x0 = interaction.coords.start.page.x - origin.x;
        this.y0 = interaction.coords.start.page.y - origin.y;
        this.clientX0 = interaction.coords.start.client.x - origin.x;
        this.clientY0 = interaction.coords.start.client.y - origin.y;
        if (starting || ending) this.delta = {
            x: 0,
            y: 0
        };
        else this.delta = {
            x: this[deltaSource].x - prevEvent[deltaSource].x,
            y: this[deltaSource].y - prevEvent[deltaSource].y
        };
        this.dt = interaction.coords.delta.timeStamp;
        this.duration = this.timeStamp - this.t0; // velocity and speed in pixels per second
        this.velocity = (0, _extendJsDefault.default)({}, interaction.coords.velocity[deltaSource]);
        this.speed = (0, _hypotJsDefault.default)(this.velocity.x, this.velocity.y);
        this.swipe = ending || phase === "inertiastart" ? this.getSwipe() : null;
    }
    getSwipe() {
        const interaction = this._interaction;
        if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) return null;
        let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
        const overlap = 22.5;
        if (angle < 0) angle += 360;
        const left = 135 - overlap <= angle && angle < 225 + overlap;
        const up = 225 - overlap <= angle && angle < 315 + overlap;
        const right = !left && (315 - overlap <= angle || angle < 45 + overlap);
        const down = !up && 45 - overlap <= angle && angle < 135 + overlap;
        return {
            up,
            down,
            left,
            right,
            angle,
            speed: interaction.prevEvent.speed,
            velocity: {
                x: interaction.prevEvent.velocityX,
                y: interaction.prevEvent.velocityY
            }
        };
    }
    preventDefault() {}
    /**
   * Don't call listeners on the remaining targets
   */ stopImmediatePropagation() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    }
    /**
   * Don't call any other listeners (even on the current target)
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
// don't support getter and setters in .d.ts files
Object.defineProperties(InteractEvent.prototype, {
    pageX: {
        get () {
            return this.page.x;
        },
        set (value) {
            this.page.x = value;
        }
    },
    pageY: {
        get () {
            return this.page.y;
        },
        set (value) {
            this.page.y = value;
        }
    },
    clientX: {
        get () {
            return this.client.x;
        },
        set (value) {
            this.client.x = value;
        }
    },
    clientY: {
        get () {
            return this.client.y;
        },
        set (value) {
            this.client.y = value;
        }
    },
    dx: {
        get () {
            return this.delta.x;
        },
        set (value) {
            this.delta.x = value;
        }
    },
    dy: {
        get () {
            return this.delta.y;
        },
        set (value) {
            this.delta.y = value;
        }
    },
    velocityX: {
        get () {
            return this.velocity.x;
        },
        set (value) {
            this.velocity.x = value;
        }
    },
    velocityY: {
        get () {
            return this.velocity.y;
        },
        set (value) {
            this.velocity.y = value;
        }
    }
});

},{"../utils/extend.js":"cmcmr","../utils/getOriginXY.js":"eEJaA","../utils/hypot.js":"ekLIq","./BaseEvent.js":"fd10N","./options.js":"vopVv","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"vopVv":[function(require,module,exports) {
// eslint-disable-next-line @typescript-eslint/no-empty-interface
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaults", ()=>defaults);
const defaults = {
    base: {
        preventDefault: "auto",
        deltaSource: "page"
    },
    perAction: {
        enabled: false,
        origin: {
            x: 0,
            y: 0
        }
    },
    actions: {}
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6qISL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PointerInfo", ()=>PointerInfo);
class PointerInfo {
    id;
    pointer;
    event;
    downTime;
    downTarget;
    constructor(id, pointer, event, downTime, downTarget){
        this.id = id;
        this.pointer = pointer;
        this.event = event;
        this.downTime = downTime;
        this.downTarget = downTarget;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dQbVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scopeJs = require("../core/scope.js");
var _typesJs = require("../core/types.js");
parcelHelpers.exportAll(_typesJs, exports);
const scope = new (0, _scopeJs.Scope)();
const interact = scope.interactStatic;
exports.default = interact;
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
scope.init(_global);

},{"../core/scope.js":"hyG8O","../core/types.js":"cymvs","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"hyG8O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Scope", ()=>Scope);
parcelHelpers.export(exports, "initScope", ()=>initScope);
var _browserJs = require("../utils/browser.js");
var _browserJsDefault = parcelHelpers.interopDefault(_browserJs);
var _cloneJs = require("../utils/clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _domObjectsJs = require("../utils/domObjects.js");
var _domObjectsJsDefault = parcelHelpers.interopDefault(_domObjectsJs);
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _rafJs = require("../utils/raf.js");
var _rafJsDefault = parcelHelpers.interopDefault(_rafJs);
var _windowJs = require("../utils/window.js");
var _eventableJs = require("./Eventable.js");
var _interactEventJs = require("./InteractEvent.js");
var _interactStaticJs = require("./InteractStatic.js");
var _interactableJs = require("./Interactable.js");
var _interactableSetJs = require("./InteractableSet.js");
var _eventsJs = require("./events.js");
var _eventsJsDefault = parcelHelpers.interopDefault(_eventsJs);
var _interactionsJs = require("./interactions.js");
var _interactionsJsDefault = parcelHelpers.interopDefault(_interactionsJs);
var _optionsJs = require("./options.js");
class Scope {
    id = `__interact_scope_${Math.floor(Math.random() * 100)}`;
    isInitialized = false;
    listenerMaps = [];
    browser = (0, _browserJsDefault.default);
    defaults = (0, _cloneJsDefault.default)((0, _optionsJs.defaults));
    Eventable = (0, _eventableJs.Eventable);
    actions = {
        map: {},
        phases: {
            start: true,
            move: true,
            end: true
        },
        methodDict: {},
        phaselessTypes: {}
    };
    interactStatic = (0, _interactStaticJs.createInteractStatic)(this);
    InteractEvent = (0, _interactEventJs.InteractEvent);
    Interactable;
    interactables = new (0, _interactableSetJs.InteractableSet)(this);
    _win;
    document;
    window;
    documents = [];
    _plugins = {
        list: [],
        map: {}
    };
    constructor(){
        const scope = this;
        this.Interactable = class extends (0, _interactableJs.Interactable) {
            get _defaults() {
                return scope.defaults;
            }
            set(options) {
                super.set(options);
                scope.fire("interactable:set", {
                    options,
                    interactable: this
                });
                return this;
            }
            unset() {
                super.unset();
                const index = scope.interactables.list.indexOf(this);
                if (index < 0) return;
                super.unset();
                scope.interactables.list.splice(index, 1);
                scope.fire("interactable:unset", {
                    interactable: this
                });
            }
        };
    }
    addListeners(map, id) {
        this.listenerMaps.push({
            id,
            map
        });
    }
    fire(name, arg) {
        for (const { map: { [name]: listener  }  } of this.listenerMaps){
            if (!!listener && listener(arg, this, name) === false) return false;
        }
    }
    onWindowUnload = (event)=>this.removeDocument(event.target);
    init(window) {
        return this.isInitialized ? this : initScope(this, window);
    }
    pluginIsInstalled(plugin) {
        return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1;
    }
    usePlugin(plugin, options) {
        if (!this.isInitialized) return this;
        if (this.pluginIsInstalled(plugin)) return this;
        if (plugin.id) this._plugins.map[plugin.id] = plugin;
        this._plugins.list.push(plugin);
        if (plugin.install) plugin.install(this, options);
        if (plugin.listeners && plugin.before) {
            let index = 0;
            const len = this.listenerMaps.length;
            const before = plugin.before.reduce((acc, id)=>{
                acc[id] = true;
                acc[pluginIdRoot(id)] = true;
                return acc;
            }, {});
            for(; index < len; index++){
                const otherId = this.listenerMaps[index].id;
                if (before[otherId] || before[pluginIdRoot(otherId)]) break;
            }
            this.listenerMaps.splice(index, 0, {
                id: plugin.id,
                map: plugin.listeners
            });
        } else if (plugin.listeners) this.listenerMaps.push({
            id: plugin.id,
            map: plugin.listeners
        });
        return this;
    }
    addDocument(doc, options) {
        // do nothing if document is already known
        if (this.getDocIndex(doc) !== -1) return false;
        const window = _windowJs.getWindow(doc);
        options = options ? (0, _extendJsDefault.default)({}, options) : {};
        this.documents.push({
            doc,
            options
        });
        this.events.documents.push(doc); // don't add an unload event for the main document
        // so that the page may be cached in browser history
        if (doc !== this.document) this.events.add(window, "unload", this.onWindowUnload);
        this.fire("scope:add-document", {
            doc,
            window,
            scope: this,
            options
        });
    }
    removeDocument(doc) {
        const index = this.getDocIndex(doc);
        const window = _windowJs.getWindow(doc);
        const options = this.documents[index].options;
        this.events.remove(window, "unload", this.onWindowUnload);
        this.documents.splice(index, 1);
        this.events.documents.splice(index, 1);
        this.fire("scope:remove-document", {
            doc,
            window,
            scope: this,
            options
        });
    }
    getDocIndex(doc) {
        for(let i = 0; i < this.documents.length; i++){
            if (this.documents[i].doc === doc) return i;
        }
        return -1;
    }
    getDocOptions(doc) {
        const docIndex = this.getDocIndex(doc);
        return docIndex === -1 ? null : this.documents[docIndex].options;
    }
    now() {
        return (this.window.Date || Date).now();
    }
}
function initScope(scope, window) {
    scope.isInitialized = true;
    if ((0, _isJsDefault.default).window(window)) _windowJs.init(window);
    (0, _domObjectsJsDefault.default).init(window);
    (0, _browserJsDefault.default).init(window);
    (0, _rafJsDefault.default).init(window); // @ts-expect-error
    scope.window = window;
    scope.document = window.document;
    scope.usePlugin((0, _interactionsJsDefault.default));
    scope.usePlugin((0, _eventsJsDefault.default));
    return scope;
}
function pluginIdRoot(id) {
    return id && id.replace(/\/.*$/, "");
}

},{"../utils/browser.js":"3o3BE","../utils/clone.js":"hkKOH","../utils/domObjects.js":"c7ipJ","../utils/extend.js":"cmcmr","../utils/is.js":"iRtxa","../utils/raf.js":"54IvB","../utils/window.js":"lQsRi","./Eventable.js":"8LB0F","./InteractEvent.js":"iXBLf","./InteractStatic.js":"14q7z","./Interactable.js":"3aVdT","./InteractableSet.js":"kRKCU","./events.js":"5ojdg","./interactions.js":"mCewx","./options.js":"vopVv","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8LB0F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Eventable", ()=>Eventable);
var _arrJs = require("../utils/arr.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _normalizeListenersJs = require("../utils/normalizeListeners.js");
var _normalizeListenersJsDefault = parcelHelpers.interopDefault(_normalizeListenersJs);
function fireUntilImmediateStopped(event, listeners) {
    for (const listener of listeners){
        if (event.immediatePropagationStopped) break;
        listener(event);
    }
}
class Eventable {
    options;
    types = {};
    propagationStopped = false;
    immediatePropagationStopped = false;
    global;
    constructor(options){
        this.options = (0, _extendJsDefault.default)({}, options || {});
    }
    fire(event) {
        let listeners;
        const global = this.global; // Interactable#on() listeners
        // tslint:disable no-conditional-assignment
        if (listeners = this.types[event.type]) fireUntilImmediateStopped(event, listeners);
         // interact.on() listeners
        if (!event.propagationStopped && global && (listeners = global[event.type])) fireUntilImmediateStopped(event, listeners);
    }
    on(type, listener) {
        const listeners = (0, _normalizeListenersJsDefault.default)(type, listener);
        for(type in listeners)this.types[type] = _arrJs.merge(this.types[type] || [], listeners[type]);
    }
    off(type, listener) {
        const listeners = (0, _normalizeListenersJsDefault.default)(type, listener);
        for(type in listeners){
            const eventList = this.types[type];
            if (!eventList || !eventList.length) continue;
            for (const subListener of listeners[type]){
                const index = eventList.indexOf(subListener);
                if (index !== -1) eventList.splice(index, 1);
            }
        }
    }
    getRect(_element) {
        return null;
    }
}

},{"../utils/arr.js":"8BYbE","../utils/extend.js":"cmcmr","../utils/normalizeListeners.js":"9pcNh","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"14q7z":[function(require,module,exports) {
/** @module interact */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createInteractStatic", ()=>createInteractStatic);
var _browserJs = require("../utils/browser.js");
var _browserJsDefault = parcelHelpers.interopDefault(_browserJs);
var _domUtilsJs = require("../utils/domUtils.js");
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _miscJs = require("../utils/misc.js");
var _pointerUtilsJs = require("../utils/pointerUtils.js");
var _isNonNativeEventJs = require("./isNonNativeEvent.js");
var _isNonNativeEventJsDefault = parcelHelpers.interopDefault(_isNonNativeEventJs);
function createInteractStatic(scope) {
    /**
   * ```js
   * interact('#draggable').draggable(true)
   *
   * var rectables = interact('rect')
   * rectables
   *   .gesturable(true)
   *   .on('gesturemove', function (event) {
   *       // ...
   *   })
   * ```
   *
   * The methods of this variable can be used to set elements as interactables
   * and also to change various default settings.
   *
   * Calling it as a function and passing an element or a valid CSS selector
   * string returns an Interactable object which has various methods to configure
   * it.
   *
   * @global
   *
   * @param {Element | string} target The HTML or SVG Element to interact with
   * or CSS selector
   * @return {Interactable}
   */ const interact = (target, options)=>{
        let interactable = scope.interactables.get(target, options);
        if (!interactable) {
            interactable = scope.interactables.new(target, options);
            interactable.events.global = interact.globalEvents;
        }
        return interactable;
    }; // expose the functions used to calculate multi-touch properties
    interact.getPointerAverage = _pointerUtilsJs.pointerAverage;
    interact.getTouchBBox = _pointerUtilsJs.touchBBox;
    interact.getTouchDistance = _pointerUtilsJs.touchDistance;
    interact.getTouchAngle = _pointerUtilsJs.touchAngle;
    interact.getElementRect = _domUtilsJs.getElementRect;
    interact.getElementClientRect = _domUtilsJs.getElementClientRect;
    interact.matchesSelector = _domUtilsJs.matchesSelector;
    interact.closest = _domUtilsJs.closest;
    interact.globalEvents = {}; // eslint-disable-next-line no-undef
    interact.version = "1.10.14";
    interact.scope = scope;
    /**
   * Use a plugin
   *
   * @alias module:interact.use
   *
   */ interact.use = function(plugin, options) {
        this.scope.usePlugin(plugin, options);
        return this;
    };
    /**
   * Check if an element or selector has been set with the {@link interact}
   * function
   *
   * @alias module:interact.isSet
   *
   * @param {Target} target The Element or string being searched for
   * @param {object} options
   * @return {boolean} Indicates if the element or CSS selector was previously
   * passed to interact
   */ interact.isSet = function(target, options) {
        return !!this.scope.interactables.get(target, options && options.context);
    };
    /**
   * @deprecated
   * Add a global listener for an InteractEvent or adds a DOM event to `document`
   *
   * @alias module:interact.on
   *
   * @param {string | array | object} type The types of events to listen for
   * @param {function} listener The function event (s)
   * @param {object | boolean} [options] object or useCapture flag for
   * addEventListener
   * @return {object} interact
   */ interact.on = (0, _miscJs.warnOnce)(function on(type, listener, options) {
        if ((0, _isJsDefault.default).string(type) && type.search(" ") !== -1) type = type.trim().split(/ +/);
        if ((0, _isJsDefault.default).array(type)) {
            for (const eventType of type)this.on(eventType, listener, options);
            return this;
        }
        if ((0, _isJsDefault.default).object(type)) {
            for(const prop in type)this.on(prop, type[prop], listener);
            return this;
        } // if it is an InteractEvent type, add listener to globalEvents
        if ((0, _isNonNativeEventJsDefault.default)(type, this.scope.actions)) {
            // if this type of event was never bound
            if (!this.globalEvents[type]) this.globalEvents[type] = [
                listener
            ];
            else this.globalEvents[type].push(listener);
        } else this.scope.events.add(this.scope.document, type, listener, {
            options
        });
        return this;
    }, "The interact.on() method is being deprecated");
    /**
   * @deprecated
   * Removes a global InteractEvent listener or DOM event from `document`
   *
   * @alias module:interact.off
   *
   * @param {string | array | object} type The types of events that were listened
   * for
   * @param {function} listener The listener function to be removed
   * @param {object | boolean} options [options] object or useCapture flag for
   * removeEventListener
   * @return {object} interact
   */ interact.off = (0, _miscJs.warnOnce)(function off(type, listener, options) {
        if ((0, _isJsDefault.default).string(type) && type.search(" ") !== -1) type = type.trim().split(/ +/);
        if ((0, _isJsDefault.default).array(type)) {
            for (const eventType of type)this.off(eventType, listener, options);
            return this;
        }
        if ((0, _isJsDefault.default).object(type)) {
            for(const prop in type)this.off(prop, type[prop], listener);
            return this;
        }
        if ((0, _isNonNativeEventJsDefault.default)(type, this.scope.actions)) {
            let index;
            if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) this.globalEvents[type].splice(index, 1);
        } else this.scope.events.remove(this.scope.document, type, listener, options);
        return this;
    }, "The interact.off() method is being deprecated");
    interact.debug = function() {
        return this.scope;
    };
    /**
   * @alias module:interact.supportsTouch
   *
   * @return {boolean} Whether or not the browser supports touch input
   */ interact.supportsTouch = function() {
        return (0, _browserJsDefault.default).supportsTouch;
    };
    /**
   * @alias module:interact.supportsPointerEvent
   *
   * @return {boolean} Whether or not the browser supports PointerEvents
   */ interact.supportsPointerEvent = function() {
        return (0, _browserJsDefault.default).supportsPointerEvent;
    };
    /**
   * Cancels all interactions (end events are not fired)
   *
   * @alias module:interact.stop
   *
   * @return {object} interact
   */ interact.stop = function() {
        for (const interaction of this.scope.interactions.list)interaction.stop();
        return this;
    };
    /**
   * Returns or sets the distance the pointer must be moved before an action
   * sequence occurs. This also affects tolerance for tap events.
   *
   * @alias module:interact.pointerMoveTolerance
   *
   * @param {number} [newValue] The movement from the start position must be greater than this value
   * @return {interact | number}
   */ interact.pointerMoveTolerance = function(newValue) {
        if ((0, _isJsDefault.default).number(newValue)) {
            this.scope.interactions.pointerMoveTolerance = newValue;
            return this;
        }
        return this.scope.interactions.pointerMoveTolerance;
    };
    interact.addDocument = function(doc, options) {
        this.scope.addDocument(doc, options);
    };
    interact.removeDocument = function(doc) {
        this.scope.removeDocument(doc);
    };
    return interact;
}

},{"../utils/browser.js":"3o3BE","../utils/domUtils.js":"813v2","../utils/is.js":"iRtxa","../utils/misc.js":"ckG7O","../utils/pointerUtils.js":"g0cI1","./isNonNativeEvent.js":"jBB6L","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"jBB6L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isNonNativeEvent(type, actions) {
    if (actions.phaselessTypes[type]) return true;
    for(const name in actions.map){
        if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) return true;
    }
    return false;
}
exports.default = isNonNativeEvent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3aVdT":[function(require,module,exports) {
/* eslint-disable no-dupe-class-members */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** */ parcelHelpers.export(exports, "Interactable", ()=>Interactable);
var _arrJs = require("../utils/arr.js");
var _browserJs = require("../utils/browser.js");
var _browserJsDefault = parcelHelpers.interopDefault(_browserJs);
var _cloneJs = require("../utils/clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _domUtilsJs = require("../utils/domUtils.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _normalizeListenersJs = require("../utils/normalizeListeners.js");
var _normalizeListenersJsDefault = parcelHelpers.interopDefault(_normalizeListenersJs);
var _windowJs = require("../utils/window.js");
var _eventableJs = require("./Eventable.js");
var _isNonNativeEventJs = require("./isNonNativeEvent.js");
var _isNonNativeEventJsDefault = parcelHelpers.interopDefault(_isNonNativeEventJs);
class Interactable {
    /** @internal */ get _defaults() {
        return {
            base: {},
            perAction: {},
            actions: {}
        };
    }
    options;
    _actions;
    target;
    events = new (0, _eventableJs.Eventable)();
    _context;
    _win;
    _doc;
    _scopeEvents;
    /** @internal */ _rectChecker;
    /** */ constructor(target, options, defaultContext, scopeEvents){
        this._actions = options.actions;
        this.target = target;
        this._context = options.context || defaultContext;
        this._win = (0, _windowJs.getWindow)((0, _domUtilsJs.trySelector)(target) ? this._context : target);
        this._doc = this._win.document;
        this._scopeEvents = scopeEvents;
        this.set(options);
    }
    setOnEvents(actionName, phases) {
        if ((0, _isJsDefault.default).func(phases.onstart)) this.on(`${actionName}start`, phases.onstart);
        if ((0, _isJsDefault.default).func(phases.onmove)) this.on(`${actionName}move`, phases.onmove);
        if ((0, _isJsDefault.default).func(phases.onend)) this.on(`${actionName}end`, phases.onend);
        if ((0, _isJsDefault.default).func(phases.oninertiastart)) this.on(`${actionName}inertiastart`, phases.oninertiastart);
        return this;
    }
    updatePerActionListeners(actionName, prev, cur) {
        if ((0, _isJsDefault.default).array(prev) || (0, _isJsDefault.default).object(prev)) this.off(actionName, prev);
        if ((0, _isJsDefault.default).array(cur) || (0, _isJsDefault.default).object(cur)) this.on(actionName, cur);
    }
    setPerAction(actionName, options) {
        const defaults = this._defaults; // for all the default per-action options
        for(const optionName_ in options){
            const optionName = optionName_;
            const actionOptions = this.options[actionName];
            const optionValue = options[optionName]; // remove old event listeners and add new ones
            if (optionName === "listeners") this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
             // if the option value is an array
            if ((0, _isJsDefault.default).array(optionValue)) actionOptions[optionName] = _arrJs.from(optionValue);
            else if ((0, _isJsDefault.default).plainObject(optionValue)) {
                actionOptions[optionName] = (0, _extendJsDefault.default)(actionOptions[optionName] || {}, (0, _cloneJsDefault.default)(optionValue)); // set anabled field to true if it exists in the defaults
                if ((0, _isJsDefault.default).object(defaults.perAction[optionName]) && "enabled" in defaults.perAction[optionName]) actionOptions[optionName].enabled = optionValue.enabled !== false;
            } else if ((0, _isJsDefault.default).bool(optionValue) && (0, _isJsDefault.default).object(defaults.perAction[optionName])) actionOptions[optionName].enabled = optionValue;
            else actionOptions[optionName] = optionValue;
        }
    }
    /**
   * The default function to get an Interactables bounding rect. Can be
   * overridden using {@link Interactable.rectChecker}.
   *
   * @param {Element} [element] The element to measure.
   * @return {Rect} The object's bounding rectangle.
   */ getRect(element) {
        element = element || ((0, _isJsDefault.default).element(this.target) ? this.target : null);
        if ((0, _isJsDefault.default).string(this.target)) element = element || this._context.querySelector(this.target);
        return (0, _domUtilsJs.getElementRect)(element);
    }
    /**
   * Returns or sets the function used to calculate the interactable's
   * element's rectangle
   *
   * @param {function} [checker] A function which returns this Interactable's
   * bounding rectangle. See {@link Interactable.getRect}
   * @return {function | object} The checker function or this Interactable
   */ rectChecker(checker) {
        if ((0, _isJsDefault.default).func(checker)) {
            this._rectChecker = checker;
            this.getRect = (element)=>{
                const rect = (0, _extendJsDefault.default)({}, this._rectChecker(element));
                if (!("width" in rect)) {
                    rect.width = rect.right - rect.left;
                    rect.height = rect.bottom - rect.top;
                }
                return rect;
            };
            return this;
        }
        if (checker === null) {
            delete this.getRect;
            delete this._rectChecker;
            return this;
        }
        return this.getRect;
    }
    _backCompatOption(optionName, newValue) {
        if ((0, _domUtilsJs.trySelector)(newValue) || (0, _isJsDefault.default).object(newValue)) {
            this.options[optionName] = newValue;
            for(const action in this._actions.map)this.options[action][optionName] = newValue;
            return this;
        }
        return this.options[optionName];
    }
    /**
   * Gets or sets the origin of the Interactable's element.  The x and y
   * of the origin will be subtracted from action event coordinates.
   *
   * @param {Element | object | string} [origin] An HTML or SVG Element whose
   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'
   * or any CSS selector
   *
   * @return {object} The current origin or this Interactable
   */ origin(newValue) {
        return this._backCompatOption("origin", newValue);
    }
    /**
   * Returns or sets the mouse coordinate types used to calculate the
   * movement of the pointer.
   *
   * @param {string} [newValue] Use 'client' if you will be scrolling while
   * interacting; Use 'page' if you want autoScroll to work
   * @return {string | object} The current deltaSource or this Interactable
   */ deltaSource(newValue) {
        if (newValue === "page" || newValue === "client") {
            this.options.deltaSource = newValue;
            return this;
        }
        return this.options.deltaSource;
    }
    /**
   * Gets the selector context Node of the Interactable. The default is
   * `window.document`.
   *
   * @return {Node} The context Node of this Interactable
   */ context() {
        return this._context;
    }
    inContext(element) {
        return this._context === element.ownerDocument || (0, _domUtilsJs.nodeContains)(this._context, element);
    }
    testIgnoreAllow(options, targetNode, eventTarget) {
        return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
    }
    testAllow(allowFrom, targetNode, element) {
        if (!allowFrom) return true;
        if (!(0, _isJsDefault.default).element(element)) return false;
        if ((0, _isJsDefault.default).string(allowFrom)) return (0, _domUtilsJs.matchesUpTo)(element, allowFrom, targetNode);
        else if ((0, _isJsDefault.default).element(allowFrom)) return (0, _domUtilsJs.nodeContains)(allowFrom, element);
        return false;
    }
    testIgnore(ignoreFrom, targetNode, element) {
        if (!ignoreFrom || !(0, _isJsDefault.default).element(element)) return false;
        if ((0, _isJsDefault.default).string(ignoreFrom)) return (0, _domUtilsJs.matchesUpTo)(element, ignoreFrom, targetNode);
        else if ((0, _isJsDefault.default).element(ignoreFrom)) return (0, _domUtilsJs.nodeContains)(ignoreFrom, element);
        return false;
    }
    /**
   * Calls listeners for the given InteractEvent type bound globally
   * and directly to this Interactable
   *
   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this
   * Interactable
   * @return {Interactable} this Interactable
   */ fire(iEvent) {
        this.events.fire(iEvent);
        return this;
    }
    _onOff(method, typeArg, listenerArg, options) {
        if ((0, _isJsDefault.default).object(typeArg) && !(0, _isJsDefault.default).array(typeArg)) {
            options = listenerArg;
            listenerArg = null;
        }
        const addRemove = method === "on" ? "add" : "remove";
        const listeners = (0, _normalizeListenersJsDefault.default)(typeArg, listenerArg);
        for(let type in listeners){
            if (type === "wheel") type = (0, _browserJsDefault.default).wheelEvent;
            for (const listener of listeners[type]){
                // if it is an action event type
                if ((0, _isNonNativeEventJsDefault.default)(type, this._actions)) this.events[method](type, listener);
                else if ((0, _isJsDefault.default).string(this.target)) this._scopeEvents[`${addRemove}Delegate`](this.target, this._context, type, listener, options);
                else this._scopeEvents[addRemove](this.target, type, listener, options);
            }
        }
        return this;
    }
    /**
   * Binds a listener for an InteractEvent, pointerEvent or DOM event.
   *
   * @param {string | array | object} types The types of events to listen
   * for
   * @param {function | array | object} [listener] The event listener function(s)
   * @param {object | boolean} [options] options object or useCapture flag for
   * addEventListener
   * @return {Interactable} This Interactable
   */ on(types, listener, options) {
        return this._onOff("on", types, listener, options);
    }
    /**
   * Removes an InteractEvent, pointerEvent or DOM event listener.
   *
   * @param {string | array | object} types The types of events that were
   * listened for
   * @param {function | array | object} [listener] The event listener function(s)
   * @param {object | boolean} [options] options object or useCapture flag for
   * removeEventListener
   * @return {Interactable} This Interactable
   */ off(types, listener, options) {
        return this._onOff("off", types, listener, options);
    }
    /**
   * Reset the options of this Interactable
   *
   * @param {object} options The new settings to apply
   * @return {object} This Interactable
   */ set(options) {
        const defaults = this._defaults;
        if (!(0, _isJsDefault.default).object(options)) options = {};
        this.options = (0, _cloneJsDefault.default)(defaults.base);
        for(const actionName_ in this._actions.methodDict){
            const actionName = actionName_;
            const methodName = this._actions.methodDict[actionName];
            this.options[actionName] = {};
            this.setPerAction(actionName, (0, _extendJsDefault.default)((0, _extendJsDefault.default)({}, defaults.perAction), defaults.actions[actionName]));
            this[methodName](options[actionName]);
        }
        for(const setting in options)if ((0, _isJsDefault.default).func(this[setting])) this[setting](options[setting]);
        return this;
    }
    /**
   * Remove this interactable from the list of interactables and remove it's
   * action capabilities and event listeners
   */ unset() {
        if ((0, _isJsDefault.default).string(this.target)) // remove delegated events
        for(const type in this._scopeEvents.delegatedEvents){
            const delegated = this._scopeEvents.delegatedEvents[type];
            for(let i = delegated.length - 1; i >= 0; i--){
                const { selector , context , listeners  } = delegated[i];
                if (selector === this.target && context === this._context) delegated.splice(i, 1);
                for(let l = listeners.length - 1; l >= 0; l--)this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1]);
            }
        }
        else this._scopeEvents.remove(this.target, "all");
    }
}

},{"../utils/arr.js":"8BYbE","../utils/browser.js":"3o3BE","../utils/clone.js":"hkKOH","../utils/domUtils.js":"813v2","../utils/extend.js":"cmcmr","../utils/is.js":"iRtxa","../utils/normalizeListeners.js":"9pcNh","../utils/window.js":"lQsRi","./Eventable.js":"8LB0F","./isNonNativeEvent.js":"jBB6L","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"kRKCU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InteractableSet", ()=>InteractableSet);
var _arrJs = require("../utils/arr.js");
var _domUtilsJs = require("../utils/domUtils.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
class InteractableSet {
    // all set interactables
    list = [];
    selectorMap = {};
    scope;
    constructor(scope){
        this.scope = scope;
        scope.addListeners({
            "interactable:unset": ({ interactable  })=>{
                const { target , _context: context  } = interactable;
                const targetMappings = (0, _isJsDefault.default).string(target) ? this.selectorMap[target] : target[this.scope.id];
                const targetIndex = _arrJs.findIndex(targetMappings, (m)=>m.context === context);
                if (targetMappings[targetIndex]) {
                    // Destroying mappingInfo's context and interactable
                    targetMappings[targetIndex].context = null;
                    targetMappings[targetIndex].interactable = null;
                }
                targetMappings.splice(targetIndex, 1);
            }
        });
    }
    new(target, options) {
        options = (0, _extendJsDefault.default)(options || {}, {
            actions: this.scope.actions
        });
        const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events);
        const mappingInfo = {
            context: interactable._context,
            interactable
        };
        this.scope.addDocument(interactable._doc);
        this.list.push(interactable);
        if ((0, _isJsDefault.default).string(target)) {
            if (!this.selectorMap[target]) this.selectorMap[target] = [];
            this.selectorMap[target].push(mappingInfo);
        } else {
            if (!interactable.target[this.scope.id]) Object.defineProperty(target, this.scope.id, {
                value: [],
                configurable: true
            });
            target[this.scope.id].push(mappingInfo);
        }
        this.scope.fire("interactable:new", {
            target,
            options,
            interactable,
            win: this.scope._win
        });
        return interactable;
    }
    get(target, options) {
        const context = options && options.context || this.scope.document;
        const isSelector = (0, _isJsDefault.default).string(target);
        const targetMappings = isSelector ? this.selectorMap[target] : target[this.scope.id];
        if (!targetMappings) return null;
        const found = _arrJs.find(targetMappings, (m)=>m.context === context && (isSelector || m.interactable.inContext(target)));
        return found && found.interactable;
    }
    forEachMatch(node, callback) {
        for (const interactable of this.list){
            let ret;
            if (((0, _isJsDefault.default).string(interactable.target) ? (0, _isJsDefault.default).element(node) && _domUtilsJs.matchesSelector(node, interactable.target) : node === interactable.target) && // the element is in context
            interactable.inContext(node)) ret = callback(interactable);
            if (ret !== undefined) return ret;
        }
    }
}

},{"../utils/arr.js":"8BYbE","../utils/domUtils.js":"813v2","../utils/extend.js":"cmcmr","../utils/is.js":"iRtxa","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5ojdg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrJs = require("../utils/arr.js");
var _domUtilsJs = require("../utils/domUtils.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _pointerExtendJs = require("../utils/pointerExtend.js");
var _pointerExtendJsDefault = parcelHelpers.interopDefault(_pointerExtendJs);
var _pointerUtilsJs = require("../utils/pointerUtils.js");
function install(scope) {
    var _scope$document;
    const targets = [];
    const delegatedEvents = {};
    const documents = [];
    const eventsMethods = {
        add,
        remove,
        addDelegate,
        removeDelegate,
        delegateListener,
        delegateUseCapture,
        delegatedEvents,
        documents,
        targets,
        supportsOptions: false,
        supportsPassive: false
    }; // check if browser supports passive events and options arg
    (_scope$document = scope.document) == null || _scope$document.createElement("div").addEventListener("test", null, {
        get capture () {
            return eventsMethods.supportsOptions = true;
        },
        get passive () {
            return eventsMethods.supportsPassive = true;
        }
    });
    scope.events = eventsMethods;
    function add(eventTarget, type, listener, optionalArg) {
        const options = getOptions(optionalArg);
        let target = _arrJs.find(targets, (t)=>t.eventTarget === eventTarget);
        if (!target) {
            target = {
                eventTarget,
                events: {}
            };
            targets.push(target);
        }
        if (!target.events[type]) target.events[type] = [];
        if (eventTarget.addEventListener && !_arrJs.contains(target.events[type], listener)) {
            eventTarget.addEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
            target.events[type].push(listener);
        }
    }
    function remove(eventTarget, type, listener, optionalArg) {
        const options = getOptions(optionalArg);
        const targetIndex = _arrJs.findIndex(targets, (t)=>t.eventTarget === eventTarget);
        const target = targets[targetIndex];
        if (!target || !target.events) return;
        if (type === "all") {
            for(type in target.events)if (target.events.hasOwnProperty(type)) remove(eventTarget, type, "all");
            return;
        }
        let typeIsEmpty = false;
        const typeListeners = target.events[type];
        if (typeListeners) {
            if (listener === "all") {
                for(let i = typeListeners.length - 1; i >= 0; i--)remove(eventTarget, type, typeListeners[i], options);
                return;
            } else {
                for(let i1 = 0; i1 < typeListeners.length; i1++)if (typeListeners[i1] === listener) {
                    eventTarget.removeEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
                    typeListeners.splice(i1, 1);
                    if (typeListeners.length === 0) {
                        delete target.events[type];
                        typeIsEmpty = true;
                    }
                    break;
                }
            }
        }
        if (typeIsEmpty && !Object.keys(target.events).length) targets.splice(targetIndex, 1);
    }
    function addDelegate(selector, context, type, listener, optionalArg) {
        const options = getOptions(optionalArg);
        if (!delegatedEvents[type]) {
            delegatedEvents[type] = []; // add delegate listener functions
            for (const doc of documents){
                add(doc, type, delegateListener);
                add(doc, type, delegateUseCapture, true);
            }
        }
        const delegates = delegatedEvents[type];
        let delegate = _arrJs.find(delegates, (d)=>d.selector === selector && d.context === context);
        if (!delegate) {
            delegate = {
                selector,
                context,
                listeners: []
            };
            delegates.push(delegate);
        }
        delegate.listeners.push([
            listener,
            options
        ]);
    }
    function removeDelegate(selector, context, type, listener, optionalArg) {
        const options = getOptions(optionalArg);
        const delegates = delegatedEvents[type];
        let matchFound = false;
        let index;
        if (!delegates) return; // count from last index of delegated to 0
        for(index = delegates.length - 1; index >= 0; index--){
            const cur = delegates[index]; // look for matching selector and context Node
            if (cur.selector === selector && cur.context === context) {
                const { listeners  } = cur; // each item of the listeners array is an array: [function, capture, passive]
                for(let i = listeners.length - 1; i >= 0; i--){
                    const [fn, { capture , passive  }] = listeners[i]; // check if the listener functions and capture and passive flags match
                    if (fn === listener && capture === options.capture && passive === options.passive) {
                        // remove the listener from the array of listeners
                        listeners.splice(i, 1); // if all listeners for this target have been removed
                        // remove the target from the delegates array
                        if (!listeners.length) {
                            delegates.splice(index, 1); // remove delegate function from context
                            remove(context, type, delegateListener);
                            remove(context, type, delegateUseCapture, true);
                        } // only remove one listener
                        matchFound = true;
                        break;
                    }
                }
                if (matchFound) break;
            }
        }
    } // bound to the interactable context when a DOM event
    // listener is added to a selector interactable
    function delegateListener(event, optionalArg) {
        const options = getOptions(optionalArg);
        const fakeEvent = new FakeEvent(event);
        const delegates = delegatedEvents[event.type];
        const [eventTarget] = _pointerUtilsJs.getEventTargets(event);
        let element = eventTarget; // climb up document tree looking for selector matches
        while((0, _isJsDefault.default).element(element)){
            for(let i = 0; i < delegates.length; i++){
                const cur = delegates[i];
                const { selector , context  } = cur;
                if (_domUtilsJs.matchesSelector(element, selector) && _domUtilsJs.nodeContains(context, eventTarget) && _domUtilsJs.nodeContains(context, element)) {
                    const { listeners  } = cur;
                    fakeEvent.currentTarget = element;
                    for (const [fn, { capture , passive  }] of listeners)if (capture === options.capture && passive === options.passive) fn(fakeEvent);
                }
            }
            element = _domUtilsJs.parentNode(element);
        }
    }
    function delegateUseCapture(event) {
        return delegateListener.call(this, event, true);
    } // for type inferrence
    return eventsMethods;
}
class FakeEvent {
    currentTarget;
    originalEvent;
    type;
    constructor(originalEvent){
        this.originalEvent = originalEvent; // duplicate the event so that currentTarget can be changed
        (0, _pointerExtendJsDefault.default)(this, originalEvent);
    }
    preventOriginalDefault() {
        this.originalEvent.preventDefault();
    }
    stopPropagation() {
        this.originalEvent.stopPropagation();
    }
    stopImmediatePropagation() {
        this.originalEvent.stopImmediatePropagation();
    }
}
function getOptions(param) {
    if (!(0, _isJsDefault.default).object(param)) return {
        capture: !!param,
        passive: false
    };
    const options = (0, _extendJsDefault.default)({}, param);
    options.capture = !!param.capture;
    options.passive = !!param.passive;
    return options;
}
exports.default = {
    id: "events",
    install
};

},{"../utils/arr.js":"8BYbE","../utils/domUtils.js":"813v2","../utils/extend.js":"cmcmr","../utils/is.js":"iRtxa","../utils/pointerExtend.js":"9yeZb","../utils/pointerUtils.js":"g0cI1","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"mCewx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _browserJs = require("../utils/browser.js");
var _browserJsDefault = parcelHelpers.interopDefault(_browserJs);
var _domObjectsJs = require("../utils/domObjects.js");
var _domObjectsJsDefault = parcelHelpers.interopDefault(_domObjectsJs);
var _domUtilsJs = require("../utils/domUtils.js");
var _pointerUtilsJs = require("../utils/pointerUtils.js");
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _interactablePreventDefaultJs = require("./interactablePreventDefault.js");
var _interactablePreventDefaultJsDefault = parcelHelpers.interopDefault(_interactablePreventDefaultJs);
var _interactionFinderJs = require("./interactionFinder.js");
var _interactionFinderJsDefault = parcelHelpers.interopDefault(_interactionFinderJs);
const methodNames = [
    "pointerDown",
    "pointerMove",
    "pointerUp",
    "updatePointer",
    "removePointer",
    "windowBlur"
];
function install(scope) {
    const listeners = {};
    for (const method of methodNames)listeners[method] = doOnInteractions(method, scope);
    const pEventTypes = (0, _browserJsDefault.default).pEventTypes;
    let docEvents;
    if ((0, _domObjectsJsDefault.default).PointerEvent) docEvents = [
        {
            type: pEventTypes.down,
            listener: releasePointersOnRemovedEls
        },
        {
            type: pEventTypes.down,
            listener: listeners.pointerDown
        },
        {
            type: pEventTypes.move,
            listener: listeners.pointerMove
        },
        {
            type: pEventTypes.up,
            listener: listeners.pointerUp
        },
        {
            type: pEventTypes.cancel,
            listener: listeners.pointerUp
        }
    ];
    else docEvents = [
        {
            type: "mousedown",
            listener: listeners.pointerDown
        },
        {
            type: "mousemove",
            listener: listeners.pointerMove
        },
        {
            type: "mouseup",
            listener: listeners.pointerUp
        },
        {
            type: "touchstart",
            listener: releasePointersOnRemovedEls
        },
        {
            type: "touchstart",
            listener: listeners.pointerDown
        },
        {
            type: "touchmove",
            listener: listeners.pointerMove
        },
        {
            type: "touchend",
            listener: listeners.pointerUp
        },
        {
            type: "touchcancel",
            listener: listeners.pointerUp
        }
    ];
    docEvents.push({
        type: "blur",
        listener (event) {
            for (const interaction of scope.interactions.list)interaction.documentBlur(event);
        }
    }); // for ignoring browser's simulated mouse events
    scope.prevTouchTime = 0;
    scope.Interaction = class extends (0, _interactionJsDefault.default) {
        get pointerMoveTolerance() {
            return scope.interactions.pointerMoveTolerance;
        }
        set pointerMoveTolerance(value) {
            scope.interactions.pointerMoveTolerance = value;
        }
        _now() {
            return scope.now();
        }
    };
    scope.interactions = {
        // all active and idle interactions
        list: [],
        new (options) {
            options.scopeFire = (name, arg)=>scope.fire(name, arg);
            const interaction = new scope.Interaction(options);
            scope.interactions.list.push(interaction);
            return interaction;
        },
        listeners,
        docEvents,
        pointerMoveTolerance: 1
    };
    function releasePointersOnRemovedEls() {
        // for all inactive touch interactions with pointers down
        for (const interaction of scope.interactions.list){
            if (!interaction.pointerIsDown || interaction.pointerType !== "touch" || interaction._interacting) continue;
             // if a pointer is down on an element that is no longer in the DOM tree
            for (const pointer of interaction.pointers)if (!scope.documents.some(({ doc  })=>(0, _domUtilsJs.nodeContains)(doc, pointer.downTarget))) // remove the pointer from the interaction
            interaction.removePointer(pointer.pointer, pointer.event);
        }
    }
    scope.usePlugin((0, _interactablePreventDefaultJsDefault.default));
}
function doOnInteractions(method, scope) {
    return function(event) {
        const interactions = scope.interactions.list;
        const pointerType = _pointerUtilsJs.getPointerType(event);
        const [eventTarget, curEventTarget] = _pointerUtilsJs.getEventTargets(event);
        const matches = []; // [ [pointer, interaction], ...]
        if (/^touch/.test(event.type)) {
            scope.prevTouchTime = scope.now(); // @ts-expect-error
            for (const changedTouch of event.changedTouches){
                const pointer = changedTouch;
                const pointerId = _pointerUtilsJs.getPointerId(pointer);
                const searchDetails = {
                    pointer,
                    pointerId,
                    pointerType,
                    eventType: event.type,
                    eventTarget,
                    curEventTarget,
                    scope
                };
                const interaction = getInteraction(searchDetails);
                matches.push([
                    searchDetails.pointer,
                    searchDetails.eventTarget,
                    searchDetails.curEventTarget,
                    interaction
                ]);
            }
        } else {
            let invalidPointer = false;
            if (!(0, _browserJsDefault.default).supportsPointerEvent && /mouse/.test(event.type)) {
                // ignore mouse events while touch interactions are active
                for(let i = 0; i < interactions.length && !invalidPointer; i++)invalidPointer = interactions[i].pointerType !== "mouse" && interactions[i].pointerIsDown;
                 // try to ignore mouse events that are simulated by the browser
                // after a touch event
                invalidPointer = invalidPointer || scope.now() - scope.prevTouchTime < 500 || // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated
                event.timeStamp === 0;
            }
            if (!invalidPointer) {
                const searchDetails1 = {
                    pointer: event,
                    pointerId: _pointerUtilsJs.getPointerId(event),
                    pointerType,
                    eventType: event.type,
                    curEventTarget,
                    eventTarget,
                    scope
                };
                const interaction1 = getInteraction(searchDetails1);
                matches.push([
                    searchDetails1.pointer,
                    searchDetails1.eventTarget,
                    searchDetails1.curEventTarget,
                    interaction1
                ]);
            }
        } // eslint-disable-next-line no-shadow
        for (const [pointer1, eventTarget1, curEventTarget1, interaction2] of matches)interaction2[method](pointer1, event, eventTarget1, curEventTarget1);
    };
}
function getInteraction(searchDetails) {
    const { pointerType , scope  } = searchDetails;
    const foundInteraction = (0, _interactionFinderJsDefault.default).search(searchDetails);
    const signalArg = {
        interaction: foundInteraction,
        searchDetails
    };
    scope.fire("interactions:find", signalArg);
    return signalArg.interaction || scope.interactions.new({
        pointerType
    });
}
function onDocSignal({ doc , scope , options  }, eventMethodName) {
    const { interactions: { docEvents  } , events  } = scope;
    const eventMethod = events[eventMethodName];
    if (scope.browser.isIOS && !options.events) options.events = {
        passive: false
    };
     // delegate event listener
    for(const eventType in events.delegatedEvents){
        eventMethod(doc, eventType, events.delegateListener);
        eventMethod(doc, eventType, events.delegateUseCapture, true);
    }
    const eventOptions = options && options.events;
    for (const { type , listener  } of docEvents)eventMethod(doc, type, listener, eventOptions);
}
const interactions = {
    id: "core/interactions",
    install,
    listeners: {
        "scope:add-document": (arg)=>onDocSignal(arg, "add"),
        "scope:remove-document": (arg)=>onDocSignal(arg, "remove"),
        "interactable:unset": ({ interactable  }, scope)=>{
            // Stop and destroy related interactions when an Interactable is unset
            for(let i = scope.interactions.list.length - 1; i >= 0; i--){
                const interaction = scope.interactions.list[i];
                if (interaction.interactable !== interactable) continue;
                interaction.stop();
                scope.fire("interactions:destroy", {
                    interaction
                });
                interaction.destroy();
                if (scope.interactions.list.length > 2) scope.interactions.list.splice(i, 1);
            }
        }
    },
    onDocSignal,
    doOnInteractions,
    methodNames
};
exports.default = interactions;

},{"../utils/browser.js":"3o3BE","../utils/domObjects.js":"c7ipJ","../utils/domUtils.js":"813v2","../utils/pointerUtils.js":"g0cI1","./Interaction.js":"eImvN","./interactablePreventDefault.js":"bzEAu","./interactionFinder.js":"gaHDI","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"gaHDI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domUtilsJs = require("../utils/domUtils.js");
const finder = {
    methodOrder: [
        "simulationResume",
        "mouseOrPen",
        "hasPointer",
        "idle"
    ],
    search (details) {
        for (const method of finder.methodOrder){
            const interaction = finder[method](details);
            if (interaction) return interaction;
        }
        return null;
    },
    // try to resume simulation with a new pointer
    simulationResume ({ pointerType , eventType , eventTarget , scope  }) {
        if (!/down|start/i.test(eventType)) return null;
        for (const interaction of scope.interactions.list){
            let element = eventTarget;
            if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) while(element){
                // if the element is the interaction element
                if (element === interaction.element) return interaction;
                element = _domUtilsJs.parentNode(element);
            }
        }
        return null;
    },
    // if it's a mouse or pen interaction
    mouseOrPen ({ pointerId , pointerType , eventType , scope  }) {
        if (pointerType !== "mouse" && pointerType !== "pen") return null;
        let firstNonActive;
        for (const interaction of scope.interactions.list)if (interaction.pointerType === pointerType) {
            // if it's a down event, skip interactions with running simulations
            if (interaction.simulation && !hasPointerId(interaction, pointerId)) continue;
             // if the interaction is active, return it immediately
            if (interaction.interacting()) return interaction;
            else if (!firstNonActive) firstNonActive = interaction;
        }
         // if no active mouse interaction was found use the first inactive mouse
        // interaction
        if (firstNonActive) return firstNonActive;
         // find any mouse or pen interaction.
        // ignore the interaction if the eventType is a *down, and a simulation
        // is active
        for (const interaction1 of scope.interactions.list){
            if (interaction1.pointerType === pointerType && !(/down/i.test(eventType) && interaction1.simulation)) return interaction1;
        }
        return null;
    },
    // get interaction that has this pointer
    hasPointer ({ pointerId , scope  }) {
        for (const interaction of scope.interactions.list){
            if (hasPointerId(interaction, pointerId)) return interaction;
        }
        return null;
    },
    // get first idle interaction with a matching pointerType
    idle ({ pointerType , scope  }) {
        for (const interaction of scope.interactions.list){
            // if there's already a pointer held down
            if (interaction.pointers.length === 1) {
                const target = interaction.interactable; // don't add this pointer if there is a target interactable and it
                // isn't gesturable
                if (target && !(target.options.gesture && target.options.gesture.enabled)) continue;
            } else if (interaction.pointers.length >= 2) continue;
            if (!interaction.interacting() && pointerType === interaction.pointerType) return interaction;
        }
        return null;
    }
};
function hasPointerId(interaction, pointerId) {
    return interaction.pointers.some(({ id  })=>id === pointerId);
}
exports.default = finder;

},{"../utils/domUtils.js":"813v2","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cymvs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"jtg1V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pluginJs = require("../snappers/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _allJs = require("./all.js");
var _allJsDefault = parcelHelpers.interopDefault(_allJs);
var _baseJs = require("./base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
const modifiers = {
    id: "modifiers",
    install (scope) {
        const { interactStatic: interact  } = scope;
        scope.usePlugin((0, _baseJsDefault.default));
        scope.usePlugin((0, _pluginJsDefault.default));
        interact.modifiers = (0, _allJsDefault.default); // for backwrads compatibility
        for(const type in 0, _allJsDefault.default){
            const { _defaults , _methods  } = (0, _allJsDefault.default)[type];
            _defaults._methods = _methods;
            scope.defaults.perAction[type] = _defaults;
        }
    }
};
exports.default = modifiers;

},{"../snappers/plugin.js":"broGO","./all.js":"dWDiS","./base.js":"2oZRZ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"broGO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _allJs = require("./all.js");
const snappersPlugin = {
    id: "snappers",
    install (scope) {
        const { interactStatic: interact  } = scope;
        interact.snappers = (0, _extendJsDefault.default)(interact.snappers || {}, _allJs);
        interact.createSnapGrid = interact.snappers.grid;
    }
};
exports.default = snappersPlugin;

},{"../utils/extend.js":"cmcmr","./all.js":"9lgpp","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9lgpp":[function(require,module,exports) {
/* eslint-disable import/no-named-as-default, import/no-unresolved */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "edgeTarget", ()=>(0, _edgeTargetJsDefault.default));
parcelHelpers.export(exports, "elements", ()=>(0, _elementsJsDefault.default));
parcelHelpers.export(exports, "grid", ()=>(0, _gridJsDefault.default));
var _edgeTargetJs = require("./edgeTarget.js");
var _edgeTargetJsDefault = parcelHelpers.interopDefault(_edgeTargetJs);
var _elementsJs = require("./elements.js");
var _elementsJsDefault = parcelHelpers.interopDefault(_elementsJs);
var _gridJs = require("./grid.js");
var _gridJsDefault = parcelHelpers.interopDefault(_gridJs);

},{"./edgeTarget.js":"ePQl8","./elements.js":"7Y6D4","./grid.js":"1WHjT","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ePQl8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = ()=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7Y6D4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = ()=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1WHjT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = (grid)=>{
    const coordFields = [
        [
            "x",
            "y"
        ],
        [
            "left",
            "top"
        ],
        [
            "right",
            "bottom"
        ],
        [
            "width",
            "height"
        ]
    ].filter(([xField, yField])=>xField in grid || yField in grid);
    const gridFunc = (x, y)=>{
        const { range , limits ={
            left: -Infinity,
            right: Infinity,
            top: -Infinity,
            bottom: Infinity
        } , offset ={
            x: 0,
            y: 0
        }  } = grid;
        const result = {
            range,
            grid,
            x: null,
            y: null
        };
        for (const [xField, yField] of coordFields){
            const gridx = Math.round((x - offset.x) / grid[xField]);
            const gridy = Math.round((y - offset.y) / grid[yField]);
            result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid[xField] + offset.x));
            result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid[yField] + offset.y));
        }
        return result;
    };
    gridFunc.grid = grid;
    gridFunc.coordFields = coordFields;
    return gridFunc;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dWDiS":[function(require,module,exports) {
/* eslint-disable n/no-extraneous-import, import/no-unresolved */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _aspectRatioJs = require("./aspectRatio.js");
var _aspectRatioJsDefault = parcelHelpers.interopDefault(_aspectRatioJs);
var _avoidJs = require("./avoid/avoid.js");
var _avoidJsDefault = parcelHelpers.interopDefault(_avoidJs);
var _edgesJs = require("./restrict/edges.js");
var _edgesJsDefault = parcelHelpers.interopDefault(_edgesJs);
var _pointerJs = require("./restrict/pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rectJs = require("./restrict/rect.js");
var _rectJsDefault = parcelHelpers.interopDefault(_rectJs);
var _sizeJs = require("./restrict/size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _rubberbandJs = require("./rubberband/rubberband.js");
var _rubberbandJsDefault = parcelHelpers.interopDefault(_rubberbandJs);
var _edgesJs1 = require("./snap/edges.js");
var _edgesJsDefault1 = parcelHelpers.interopDefault(_edgesJs1);
var _pointerJs1 = require("./snap/pointer.js");
var _pointerJsDefault1 = parcelHelpers.interopDefault(_pointerJs1);
var _sizeJs1 = require("./snap/size.js");
var _sizeJsDefault1 = parcelHelpers.interopDefault(_sizeJs1);
var _springJs = require("./spring/spring.js");
var _springJsDefault = parcelHelpers.interopDefault(_springJs);
var _transformJs = require("./transform/transform.js");
var _transformJsDefault = parcelHelpers.interopDefault(_transformJs);
exports.default = {
    aspectRatio: (0, _aspectRatioJsDefault.default),
    restrictEdges: (0, _edgesJsDefault.default),
    restrict: (0, _pointerJsDefault.default),
    restrictRect: (0, _rectJsDefault.default),
    restrictSize: (0, _sizeJsDefault.default),
    snapEdges: (0, _edgesJsDefault1.default),
    snap: (0, _pointerJsDefault1.default),
    snapSize: (0, _sizeJsDefault1.default),
    spring: (0, _springJsDefault.default),
    avoid: (0, _avoidJsDefault.default),
    transform: (0, _transformJsDefault.default),
    rubberband: (0, _rubberbandJsDefault.default)
};

},{"./aspectRatio.js":"lcft6","./avoid/avoid.js":"ljtMf","./restrict/edges.js":"dfSIG","./restrict/pointer.js":"8imLL","./restrict/rect.js":"iVp0a","./restrict/size.js":"ebypn","./rubberband/rubberband.js":"zdyc7","./snap/edges.js":"8zAyU","./snap/pointer.js":"b9IBq","./snap/size.js":"bBOB3","./spring/spring.js":"87ZGa","./transform/transform.js":"516Ej","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lcft6":[function(require,module,exports) {
/**
 * @module modifiers/aspectRatio
 *
 * @description
 * This module forces elements to be resized with a specified dx/dy ratio.
 *
 * ```js
 * interact(target).resizable({
 *   modifiers: [
 *     interact.modifiers.snapSize({
 *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],
 *     }),
 *     interact.aspectRatio({ ratio: 'preserve' }),
 *   ],
 * });
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "aspectRatio", ()=>aspectRatio);
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _rectJs = require("../utils/rect.js");
var _modificationJs = require("./Modification.js");
var _modificationJsDefault = parcelHelpers.interopDefault(_modificationJs);
var _baseJs = require("./base.js");
const aspectRatio = {
    start (arg) {
        const { state , rect , edges: originalEdges , pageCoords: coords  } = arg;
        let { ratio  } = state.options;
        const { equalDelta , modifiers  } = state.options;
        if (ratio === "preserve") ratio = rect.width / rect.height;
        state.startCoords = (0, _extendJsDefault.default)({}, coords);
        state.startRect = (0, _extendJsDefault.default)({}, rect);
        state.ratio = ratio;
        state.equalDelta = equalDelta;
        const linkedEdges = state.linkedEdges = {
            top: originalEdges.top || originalEdges.left && !originalEdges.bottom,
            left: originalEdges.left || originalEdges.top && !originalEdges.right,
            bottom: originalEdges.bottom || originalEdges.right && !originalEdges.top,
            right: originalEdges.right || originalEdges.bottom && !originalEdges.left
        };
        state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right);
        if (state.equalDelta) {
            const sign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1);
            state.edgeSign = {
                x: sign,
                y: sign
            };
        } else state.edgeSign = {
            x: linkedEdges.left ? -1 : 1,
            y: linkedEdges.top ? -1 : 1
        };
        (0, _extendJsDefault.default)(arg.edges, linkedEdges);
        if (!modifiers || !modifiers.length) return;
        const subModification = new (0, _modificationJsDefault.default)(arg.interaction);
        subModification.copyFrom(arg.interaction.modification);
        subModification.prepareStates(modifiers);
        state.subModification = subModification;
        subModification.startAll({
            ...arg
        });
    },
    set (arg) {
        const { state , rect , coords  } = arg;
        const initialCoords = (0, _extendJsDefault.default)({}, coords);
        const aspectMethod = state.equalDelta ? setEqualDelta : setRatio;
        aspectMethod(state, state.xIsPrimaryAxis, coords, rect);
        if (!state.subModification) return null;
        const correctedRect = (0, _extendJsDefault.default)({}, rect);
        (0, _rectJs.addEdges)(state.linkedEdges, correctedRect, {
            x: coords.x - initialCoords.x,
            y: coords.y - initialCoords.y
        });
        const result = state.subModification.setAll({
            ...arg,
            rect: correctedRect,
            edges: state.linkedEdges,
            pageCoords: coords,
            prevCoords: coords,
            prevRect: correctedRect
        });
        const { delta  } = result;
        if (result.changed) {
            const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y); // do aspect modification again with critical edge axis as primary
            aspectMethod(state, xIsCriticalAxis, result.coords, result.rect);
            (0, _extendJsDefault.default)(coords, result.coords);
        }
        return result.eventProps;
    },
    defaults: {
        ratio: "preserve",
        equalDelta: false,
        modifiers: [],
        enabled: false
    }
};
function setEqualDelta({ startCoords , edgeSign  }, xIsPrimaryAxis, coords) {
    if (xIsPrimaryAxis) coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign.y;
    else coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign.x;
}
function setRatio({ startRect , startCoords , ratio , edgeSign  }, xIsPrimaryAxis, coords, rect) {
    if (xIsPrimaryAxis) {
        const newHeight = rect.width / ratio;
        coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign.y;
    } else {
        const newWidth = rect.height * ratio;
        coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign.x;
    }
}
exports.default = (0, _baseJs.makeModifier)(aspectRatio, "aspectRatio");

},{"../utils/extend.js":"cmcmr","../utils/rect.js":"6qd7M","./Modification.js":"iWpmt","./base.js":"2oZRZ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ljtMf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _noopJsDefault.default));
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);

},{"../noop.js":"c82So","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"c82So":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const noop = ()=>{};
noop._defaults = {};
exports.default = noop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dfSIG":[function(require,module,exports) {
// This module adds the options.resize.restrictEdges setting which sets min and
// max for the top, left, bottom and right edges of the target being resized.
//
// interact(target).resize({
//   edges: { top: true, left: true },
//   restrictEdges: {
//     inner: { top: 200, left: 200, right: 400, bottom: 400 },
//     outer: { top:   0, left:   0, right: 600, bottom: 600 },
//   },
// })
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "restrictEdges", ()=>restrictEdges);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _rectJs = require("../../utils/rect.js");
var _baseJs = require("../base.js");
var _pointerJs = require("./pointer.js");
const noInner = {
    top: Infinity,
    left: Infinity,
    bottom: -Infinity,
    right: -Infinity
};
const noOuter = {
    top: -Infinity,
    left: -Infinity,
    bottom: Infinity,
    right: Infinity
};
function start({ interaction , startOffset , state  }) {
    const { options  } = state;
    let offset;
    if (options) {
        const offsetRect = (0, _pointerJs.getRestrictionRect)(options.offset, interaction, interaction.coords.start.page);
        offset = _rectJs.rectToXY(offsetRect);
    }
    offset = offset || {
        x: 0,
        y: 0
    };
    state.offset = {
        top: offset.y + startOffset.top,
        left: offset.x + startOffset.left,
        bottom: offset.y - startOffset.bottom,
        right: offset.x - startOffset.right
    };
}
function set({ coords , edges , interaction , state  }) {
    const { offset , options  } = state;
    if (!edges) return;
    const page = (0, _extendJsDefault.default)({}, coords);
    const inner = (0, _pointerJs.getRestrictionRect)(options.inner, interaction, page) || {};
    const outer = (0, _pointerJs.getRestrictionRect)(options.outer, interaction, page) || {};
    fixRect(inner, noInner);
    fixRect(outer, noOuter);
    if (edges.top) coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);
    else if (edges.bottom) coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom);
    if (edges.left) coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);
    else if (edges.right) coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right);
}
function fixRect(rect, defaults) {
    for (const edge of [
        "top",
        "left",
        "bottom",
        "right"
    ])if (!(edge in rect)) rect[edge] = defaults[edge];
    return rect;
}
const defaults = {
    inner: null,
    outer: null,
    offset: null,
    endOnly: false,
    enabled: false
};
const restrictEdges = {
    noInner,
    noOuter,
    start,
    set,
    defaults
};
exports.default = (0, _baseJs.makeModifier)(restrictEdges, "restrictEdges");

},{"../../utils/extend.js":"cmcmr","../../utils/rect.js":"6qd7M","../base.js":"2oZRZ","./pointer.js":"8imLL","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8imLL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRestrictionRect", ()=>getRestrictionRect);
parcelHelpers.export(exports, "restrict", ()=>restrict);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _rectJs = require("../../utils/rect.js");
var _baseJs = require("../base.js");
function start({ rect , startOffset , state , interaction , pageCoords  }) {
    const { options  } = state;
    const { elementRect  } = options;
    const offset = (0, _extendJsDefault.default)({
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
    }, options.offset || {});
    if (rect && elementRect) {
        const restriction = getRestrictionRect(options.restriction, interaction, pageCoords);
        if (restriction) {
            const widthDiff = restriction.right - restriction.left - rect.width;
            const heightDiff = restriction.bottom - restriction.top - rect.height;
            if (widthDiff < 0) {
                offset.left += widthDiff;
                offset.right += widthDiff;
            }
            if (heightDiff < 0) {
                offset.top += heightDiff;
                offset.bottom += heightDiff;
            }
        }
        offset.left += startOffset.left - rect.width * elementRect.left;
        offset.top += startOffset.top - rect.height * elementRect.top;
        offset.right += startOffset.right - rect.width * (1 - elementRect.right);
        offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom);
    }
    state.offset = offset;
}
function set({ coords , interaction , state  }) {
    const { options , offset  } = state;
    const restriction = getRestrictionRect(options.restriction, interaction, coords);
    if (!restriction) return;
    const rect = _rectJs.xywhToTlbr(restriction);
    coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left);
    coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top);
}
function getRestrictionRect(value, interaction, coords) {
    if ((0, _isJsDefault.default).func(value)) return _rectJs.resolveRectLike(value, interaction.interactable, interaction.element, [
        coords.x,
        coords.y,
        interaction
    ]);
    else return _rectJs.resolveRectLike(value, interaction.interactable, interaction.element);
}
const defaults = {
    restriction: null,
    elementRect: null,
    offset: null,
    endOnly: false,
    enabled: false
};
const restrict = {
    start,
    set,
    defaults
};
exports.default = (0, _baseJs.makeModifier)(restrict, "restrict");

},{"../../utils/extend.js":"cmcmr","../../utils/is.js":"iRtxa","../../utils/rect.js":"6qd7M","../base.js":"2oZRZ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iVp0a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "restrictRect", ()=>restrictRect);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _baseJs = require("../base.js");
var _pointerJs = require("./pointer.js");
const defaults = (0, _extendJsDefault.default)({
    get elementRect () {
        return {
            top: 0,
            left: 0,
            bottom: 1,
            right: 1
        };
    },
    set elementRect (_){}
}, (0, _pointerJs.restrict).defaults);
const restrictRect = {
    start: (0, _pointerJs.restrict).start,
    set: (0, _pointerJs.restrict).set,
    defaults
};
exports.default = (0, _baseJs.makeModifier)(restrictRect, "restrictRect");

},{"../../utils/extend.js":"cmcmr","../base.js":"2oZRZ","./pointer.js":"8imLL","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"ebypn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "restrictSize", ()=>restrictSize);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _rectJs = require("../../utils/rect.js");
var _baseJs = require("../base.js");
var _edgesJs = require("./edges.js");
var _pointerJs = require("./pointer.js");
const noMin = {
    width: -Infinity,
    height: -Infinity
};
const noMax = {
    width: Infinity,
    height: Infinity
};
function start(arg) {
    return (0, _edgesJs.restrictEdges).start(arg);
}
function set(arg) {
    const { interaction , state , rect , edges  } = arg;
    const { options  } = state;
    if (!edges) return;
    const minSize = _rectJs.tlbrToXywh((0, _pointerJs.getRestrictionRect)(options.min, interaction, arg.coords)) || noMin;
    const maxSize = _rectJs.tlbrToXywh((0, _pointerJs.getRestrictionRect)(options.max, interaction, arg.coords)) || noMax;
    state.options = {
        endOnly: options.endOnly,
        inner: (0, _extendJsDefault.default)({}, (0, _edgesJs.restrictEdges).noInner),
        outer: (0, _extendJsDefault.default)({}, (0, _edgesJs.restrictEdges).noOuter)
    };
    if (edges.top) {
        state.options.inner.top = rect.bottom - minSize.height;
        state.options.outer.top = rect.bottom - maxSize.height;
    } else if (edges.bottom) {
        state.options.inner.bottom = rect.top + minSize.height;
        state.options.outer.bottom = rect.top + maxSize.height;
    }
    if (edges.left) {
        state.options.inner.left = rect.right - minSize.width;
        state.options.outer.left = rect.right - maxSize.width;
    } else if (edges.right) {
        state.options.inner.right = rect.left + minSize.width;
        state.options.outer.right = rect.left + maxSize.width;
    }
    (0, _edgesJs.restrictEdges).set(arg);
    state.options = options;
}
const defaults = {
    min: null,
    max: null,
    endOnly: false,
    enabled: false
};
const restrictSize = {
    start,
    set,
    defaults
};
exports.default = (0, _baseJs.makeModifier)(restrictSize, "restrictSize");

},{"../../utils/extend.js":"cmcmr","../../utils/rect.js":"6qd7M","../base.js":"2oZRZ","./edges.js":"dfSIG","./pointer.js":"8imLL","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"zdyc7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _noopJsDefault.default));
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);

},{"../noop.js":"c82So","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8zAyU":[function(require,module,exports) {
/**
 * @module modifiers/snapEdges
 *
 * @description
 * WOW> This module allows snapping of the edges of targets during resize
 * interactions.
 *
 * ```js
 * interact(target).resizable({
 *   snapEdges: {
 *     targets: [interact.snappers.grid({ x: 100, y: 50 })],
 *   },
 * })
 *
 * interact(target).resizable({
 *   snapEdges: {
 *     targets: [
 *       interact.snappers.grid({
 *        top: 50,
 *        left: 50,
 *        bottom: 100,
 *        right: 100,
 *       }),
 *     ],
 *   },
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "snapEdges", ()=>snapEdges);
var _cloneJs = require("../../utils/clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _baseJs = require("../base.js");
var _sizeJs = require("./size.js");
function start(arg) {
    const { edges  } = arg;
    if (!edges) return null;
    arg.state.targetFields = arg.state.targetFields || [
        [
            edges.left ? "left" : "right",
            edges.top ? "top" : "bottom"
        ]
    ];
    return (0, _sizeJs.snapSize).start(arg);
}
const snapEdges = {
    start,
    set: (0, _sizeJs.snapSize).set,
    defaults: (0, _extendJsDefault.default)((0, _cloneJsDefault.default)((0, _sizeJs.snapSize).defaults), {
        targets: null,
        range: null,
        offset: {
            x: 0,
            y: 0
        }
    })
};
exports.default = (0, _baseJs.makeModifier)(snapEdges, "snapEdges");

},{"../../utils/clone.js":"hkKOH","../../utils/extend.js":"cmcmr","../base.js":"2oZRZ","./size.js":"bBOB3","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bBOB3":[function(require,module,exports) {
// This module allows snapping of the size of targets during resize
// interactions.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "snapSize", ()=>snapSize);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _baseJs = require("../base.js");
var _pointerJs = require("./pointer.js");
function start(arg) {
    const { state , edges  } = arg;
    const { options  } = state;
    if (!edges) return null;
    arg.state = {
        options: {
            targets: null,
            relativePoints: [
                {
                    x: edges.left ? 0 : 1,
                    y: edges.top ? 0 : 1
                }
            ],
            offset: options.offset || "self",
            origin: {
                x: 0,
                y: 0
            },
            range: options.range
        }
    };
    state.targetFields = state.targetFields || [
        [
            "width",
            "height"
        ],
        [
            "x",
            "y"
        ]
    ];
    (0, _pointerJs.snap).start(arg);
    state.offsets = arg.state.offsets;
    arg.state = state;
}
function set(arg) {
    const { interaction , state , coords  } = arg;
    const { options , offsets  } = state;
    const relative = {
        x: coords.x - offsets[0].x,
        y: coords.y - offsets[0].y
    };
    state.options = (0, _extendJsDefault.default)({}, options);
    state.options.targets = [];
    for (const snapTarget of options.targets || []){
        let target;
        if ((0, _isJsDefault.default).func(snapTarget)) target = snapTarget(relative.x, relative.y, interaction);
        else target = snapTarget;
        if (!target) continue;
        for (const [xField, yField] of state.targetFields)if (xField in target || yField in target) {
            target.x = target[xField];
            target.y = target[yField];
            break;
        }
        state.options.targets.push(target);
    }
    const returnValue = (0, _pointerJs.snap).set(arg);
    state.options = options;
    return returnValue;
}
const defaults = {
    range: Infinity,
    targets: null,
    offset: null,
    endOnly: false,
    enabled: false
};
const snapSize = {
    start,
    set,
    defaults
};
exports.default = (0, _baseJs.makeModifier)(snapSize, "snapSize");

},{"../../utils/extend.js":"cmcmr","../../utils/is.js":"iRtxa","../base.js":"2oZRZ","./pointer.js":"b9IBq","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"b9IBq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "snap", ()=>snap);
var _extendJs = require("../../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _getOriginXYJs = require("../../utils/getOriginXY.js");
var _getOriginXYJsDefault = parcelHelpers.interopDefault(_getOriginXYJs);
var _hypotJs = require("../../utils/hypot.js");
var _hypotJsDefault = parcelHelpers.interopDefault(_hypotJs);
var _isJs = require("../../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _rectJs = require("../../utils/rect.js");
var _baseJs = require("../base.js");
function start(arg) {
    const { interaction , interactable , element , rect , state , startOffset  } = arg;
    const { options  } = state;
    const origin = options.offsetWithOrigin ? getOrigin(arg) : {
        x: 0,
        y: 0
    };
    let snapOffset;
    if (options.offset === "startCoords") snapOffset = {
        x: interaction.coords.start.page.x,
        y: interaction.coords.start.page.y
    };
    else {
        const offsetRect = (0, _rectJs.resolveRectLike)(options.offset, interactable, element, [
            interaction
        ]);
        snapOffset = (0, _rectJs.rectToXY)(offsetRect) || {
            x: 0,
            y: 0
        };
        snapOffset.x += origin.x;
        snapOffset.y += origin.y;
    }
    const { relativePoints  } = options;
    state.offsets = rect && relativePoints && relativePoints.length ? relativePoints.map((relativePoint, index)=>({
            index,
            relativePoint,
            x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,
            y: startOffset.top - rect.height * relativePoint.y + snapOffset.y
        })) : [
        {
            index: 0,
            relativePoint: null,
            x: snapOffset.x,
            y: snapOffset.y
        }
    ];
}
function set(arg) {
    const { interaction , coords , state  } = arg;
    const { options , offsets  } = state;
    const origin = (0, _getOriginXYJsDefault.default)(interaction.interactable, interaction.element, interaction.prepared.name);
    const page = (0, _extendJsDefault.default)({}, coords);
    const targets = [];
    if (!options.offsetWithOrigin) {
        page.x -= origin.x;
        page.y -= origin.y;
    }
    for (const offset of offsets){
        const relativeX = page.x - offset.x;
        const relativeY = page.y - offset.y;
        for(let index = 0, len = options.targets.length; index < len; index++){
            const snapTarget = options.targets[index];
            let target;
            if ((0, _isJsDefault.default).func(snapTarget)) target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index);
            else target = snapTarget;
            if (!target) continue;
            targets.push({
                x: ((0, _isJsDefault.default).number(target.x) ? target.x : relativeX) + offset.x,
                y: ((0, _isJsDefault.default).number(target.y) ? target.y : relativeY) + offset.y,
                range: (0, _isJsDefault.default).number(target.range) ? target.range : options.range,
                source: snapTarget,
                index,
                offset
            });
        }
    }
    const closest = {
        target: null,
        inRange: false,
        distance: 0,
        range: 0,
        delta: {
            x: 0,
            y: 0
        }
    };
    for (const target1 of targets){
        const range = target1.range;
        const dx = target1.x - page.x;
        const dy = target1.y - page.y;
        const distance = (0, _hypotJsDefault.default)(dx, dy);
        let inRange = distance <= range; // Infinite targets count as being out of range
        // compared to non infinite ones that are in range
        if (range === Infinity && closest.inRange && closest.range !== Infinity) inRange = false;
        if (!closest.target || (inRange ? closest.inRange && range !== Infinity ? distance / range < closest.distance / closest.range : range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest
        distance < closest.distance : !closest.inRange && distance < closest.distance)) {
            closest.target = target1;
            closest.distance = distance;
            closest.range = range;
            closest.inRange = inRange;
            closest.delta.x = dx;
            closest.delta.y = dy;
        }
    }
    if (closest.inRange) {
        coords.x = closest.target.x;
        coords.y = closest.target.y;
    }
    state.closest = closest;
    return closest;
}
function getOrigin(arg) {
    const { element  } = arg.interaction;
    const optionsOrigin = (0, _rectJs.rectToXY)((0, _rectJs.resolveRectLike)(arg.state.options.origin, null, null, [
        element
    ]));
    const origin = optionsOrigin || (0, _getOriginXYJsDefault.default)(arg.interactable, element, arg.interaction.prepared.name);
    return origin;
}
const defaults = {
    range: Infinity,
    targets: null,
    offset: null,
    offsetWithOrigin: true,
    origin: null,
    relativePoints: null,
    endOnly: false,
    enabled: false
};
const snap = {
    start,
    set,
    defaults
};
exports.default = (0, _baseJs.makeModifier)(snap, "snap");

},{"../../utils/extend.js":"cmcmr","../../utils/getOriginXY.js":"eEJaA","../../utils/hypot.js":"ekLIq","../../utils/is.js":"iRtxa","../../utils/rect.js":"6qd7M","../base.js":"2oZRZ","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"87ZGa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _noopJsDefault.default));
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);

},{"../noop.js":"c82So","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"516Ej":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _noopJsDefault.default));
var _noopJs = require("../noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);

},{"../noop.js":"c82So","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1Qpuq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseJs = require("./base.js");
var _holdRepeatJs = require("./holdRepeat.js");
var _holdRepeatJsDefault = parcelHelpers.interopDefault(_holdRepeatJs);
var _interactableTargetsJs = require("./interactableTargets.js");
var _interactableTargetsJsDefault = parcelHelpers.interopDefault(_interactableTargetsJs);
const plugin = {
    id: "pointer-events",
    install (scope) {
        scope.usePlugin(_baseJs);
        scope.usePlugin((0, _holdRepeatJsDefault.default));
        scope.usePlugin((0, _interactableTargetsJsDefault.default));
    }
};
exports.default = plugin;

},{"./base.js":"2a2dx","./holdRepeat.js":"1JX8i","./interactableTargets.js":"2F0Yd","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2a2dx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domUtilsJs = require("../utils/domUtils.js");
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _getOriginXYJs = require("../utils/getOriginXY.js");
var _getOriginXYJsDefault = parcelHelpers.interopDefault(_getOriginXYJs);
var _pointerEventJs = require("./PointerEvent.js");
const defaults = {
    holdDuration: 600,
    ignoreFrom: null,
    allowFrom: null,
    origin: {
        x: 0,
        y: 0
    }
};
const pointerEvents = {
    id: "pointer-events/base",
    before: [
        "inertia",
        "modifiers",
        "auto-start",
        "actions"
    ],
    install,
    listeners: {
        "interactions:new": addInteractionProps,
        "interactions:update-pointer": addHoldInfo,
        "interactions:move": moveAndClearHold,
        "interactions:down": (arg, scope)=>{
            downAndStartHold(arg, scope);
            fire(arg, scope);
        },
        "interactions:up": (arg, scope)=>{
            clearHold(arg);
            fire(arg, scope);
            tapAfterUp(arg, scope);
        },
        "interactions:cancel": (arg, scope)=>{
            clearHold(arg);
            fire(arg, scope);
        }
    },
    PointerEvent: (0, _pointerEventJs.PointerEvent),
    fire,
    collectEventTargets,
    defaults,
    types: {
        down: true,
        move: true,
        up: true,
        cancel: true,
        tap: true,
        doubletap: true,
        hold: true
    }
};
function fire(arg, scope) {
    const { interaction , pointer , event , eventTarget , type , targets =collectEventTargets(arg, scope)  } = arg;
    const pointerEvent = new (0, _pointerEventJs.PointerEvent)(type, pointer, event, eventTarget, interaction, scope.now());
    scope.fire("pointerEvents:new", {
        pointerEvent
    });
    const signalArg = {
        interaction,
        pointer,
        event,
        eventTarget,
        targets,
        type,
        pointerEvent
    };
    for(let i = 0; i < targets.length; i++){
        const target = targets[i];
        for(const prop in target.props || {})pointerEvent[prop] = target.props[prop];
        const origin = (0, _getOriginXYJsDefault.default)(target.eventable, target.node);
        pointerEvent._subtractOrigin(origin);
        pointerEvent.eventable = target.eventable;
        pointerEvent.currentTarget = target.node;
        target.eventable.fire(pointerEvent);
        pointerEvent._addOrigin(origin);
        if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].node !== pointerEvent.currentTarget) break;
    }
    scope.fire("pointerEvents:fired", signalArg);
    if (type === "tap") {
        // if pointerEvent should make a double tap, create and fire a doubletap
        // PointerEvent and use that as the prevTap
        const prevTap = pointerEvent.double ? fire({
            interaction,
            pointer,
            event,
            eventTarget,
            type: "doubletap"
        }, scope) : pointerEvent;
        interaction.prevTap = prevTap;
        interaction.tapTime = prevTap.timeStamp;
    }
    return pointerEvent;
}
function collectEventTargets({ interaction , pointer , event , eventTarget , type  }, scope) {
    const pointerIndex = interaction.getPointerIndex(pointer);
    const pointerInfo = interaction.pointers[pointerIndex]; // do not fire a tap event if the pointer was moved before being lifted
    if (type === "tap" && (interaction.pointerWasMoved || // or if the pointerup target is different to the pointerdown target
    !(pointerInfo && pointerInfo.downTarget === eventTarget))) return [];
    const path = _domUtilsJs.getPath(eventTarget);
    const signalArg = {
        interaction,
        pointer,
        event,
        eventTarget,
        type,
        path,
        targets: [],
        node: null
    };
    for (const node of path){
        signalArg.node = node;
        scope.fire("pointerEvents:collect-targets", signalArg);
    }
    if (type === "hold") signalArg.targets = signalArg.targets.filter((target)=>{
        var _interaction$pointers;
        return target.eventable.options.holdDuration === ((_interaction$pointers = interaction.pointers[pointerIndex]) == null ? void 0 : _interaction$pointers.hold.duration);
    });
    return signalArg.targets;
}
function addInteractionProps({ interaction  }) {
    interaction.prevTap = null; // the most recent tap event on this interaction
    interaction.tapTime = 0; // time of the most recent tap event
}
function addHoldInfo({ down , pointerInfo  }) {
    if (!down && pointerInfo.hold) return;
    pointerInfo.hold = {
        duration: Infinity,
        timeout: null
    };
}
function clearHold({ interaction , pointerIndex  }) {
    const hold = interaction.pointers[pointerIndex].hold;
    if (hold && hold.timeout) {
        clearTimeout(hold.timeout);
        hold.timeout = null;
    }
}
function moveAndClearHold(arg, scope) {
    const { interaction , pointer , event , eventTarget , duplicate  } = arg;
    if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {
        if (interaction.pointerIsDown) clearHold(arg);
        fire({
            interaction,
            pointer,
            event,
            eventTarget: eventTarget,
            type: "move"
        }, scope);
    }
}
function downAndStartHold({ interaction , pointer , event , eventTarget , pointerIndex  }, scope) {
    const timer = interaction.pointers[pointerIndex].hold;
    const path = _domUtilsJs.getPath(eventTarget);
    const signalArg = {
        interaction,
        pointer,
        event,
        eventTarget,
        type: "hold",
        targets: [],
        path,
        node: null
    };
    for (const node of path){
        signalArg.node = node;
        scope.fire("pointerEvents:collect-targets", signalArg);
    }
    if (!signalArg.targets.length) return;
    let minDuration = Infinity;
    for (const target of signalArg.targets){
        const holdDuration = target.eventable.options.holdDuration;
        if (holdDuration < minDuration) minDuration = holdDuration;
    }
    timer.duration = minDuration;
    timer.timeout = setTimeout(()=>{
        fire({
            interaction,
            eventTarget,
            pointer,
            event,
            type: "hold"
        }, scope);
    }, minDuration);
}
function tapAfterUp({ interaction , pointer , event , eventTarget  }, scope) {
    if (!interaction.pointerWasMoved) fire({
        interaction,
        eventTarget,
        pointer,
        event,
        type: "tap"
    }, scope);
}
function install(scope) {
    scope.pointerEvents = pointerEvents;
    scope.defaults.actions.pointerEvents = pointerEvents.defaults;
    (0, _extendJsDefault.default)(scope.actions.phaselessTypes, pointerEvents.types);
}
exports.default = pointerEvents;

},{"../utils/domUtils.js":"813v2","../utils/extend.js":"cmcmr","../utils/getOriginXY.js":"eEJaA","./PointerEvent.js":"dDsr2","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dDsr2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PointerEvent", ()=>PointerEvent);
var _baseEventJs = require("../core/BaseEvent.js");
var _pointerUtilsJs = require("../utils/pointerUtils.js");
class PointerEvent extends (0, _baseEventJs.BaseEvent) {
    /** */ constructor(type, pointer, event, eventTarget, interaction, timeStamp){
        super(interaction);
        _pointerUtilsJs.pointerExtend(this, event);
        if (event !== pointer) _pointerUtilsJs.pointerExtend(this, pointer);
        this.timeStamp = timeStamp;
        this.originalEvent = event;
        this.type = type;
        this.pointerId = _pointerUtilsJs.getPointerId(pointer);
        this.pointerType = _pointerUtilsJs.getPointerType(pointer);
        this.target = eventTarget;
        this.currentTarget = null;
        if (type === "tap") {
            const pointerIndex = interaction.getPointerIndex(pointer);
            this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime;
            const interval = this.timeStamp - interaction.tapTime;
            this.double = !!interaction.prevTap && interaction.prevTap.type !== "doubletap" && interaction.prevTap.target === this.target && interval < 500;
        } else if (type === "doubletap") {
            this.dt = pointer.timeStamp - interaction.tapTime;
            this.double = true;
        }
    }
    _subtractOrigin({ x: originX , y: originY  }) {
        this.pageX -= originX;
        this.pageY -= originY;
        this.clientX -= originX;
        this.clientY -= originY;
        return this;
    }
    _addOrigin({ x: originX , y: originY  }) {
        this.pageX += originX;
        this.pageY += originY;
        this.clientX += originX;
        this.clientY += originY;
        return this;
    }
    /**
   * Prevent the default behaviour of the original Event
   */ preventDefault() {
        this.originalEvent.preventDefault();
    }
}
exports.default = PointerEvent;

},{"../core/BaseEvent.js":"fd10N","../utils/pointerUtils.js":"g0cI1","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1JX8i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseJs = require("./base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
function install(scope) {
    scope.usePlugin((0, _baseJsDefault.default));
    const { pointerEvents  } = scope; // don't repeat by default
    pointerEvents.defaults.holdRepeatInterval = 0;
    pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true;
}
function onNew({ pointerEvent  }) {
    if (pointerEvent.type !== "hold") return;
    pointerEvent.count = (pointerEvent.count || 0) + 1;
}
function onFired({ interaction , pointerEvent , eventTarget , targets  }, scope) {
    if (pointerEvent.type !== "hold" || !targets.length) return; // get the repeat interval from the first eventable
    const interval = targets[0].eventable.options.holdRepeatInterval; // don't repeat if the interval is 0 or less
    if (interval <= 0) return; // set a timeout to fire the holdrepeat event
    interaction.holdIntervalHandle = setTimeout(()=>{
        scope.pointerEvents.fire({
            interaction,
            eventTarget,
            type: "hold",
            pointer: pointerEvent,
            event: pointerEvent
        }, scope);
    }, interval);
}
function endHoldRepeat({ interaction  }) {
    // set the interaction's holdStopTime property
    // to stop further holdRepeat events
    if (interaction.holdIntervalHandle) {
        clearInterval(interaction.holdIntervalHandle);
        interaction.holdIntervalHandle = null;
    }
}
const holdRepeat = {
    id: "pointer-events/holdRepeat",
    install,
    listeners: [
        "move",
        "up",
        "cancel",
        "endall"
    ].reduce((acc, enderTypes)=>{
        acc[`pointerEvents:${enderTypes}`] = endHoldRepeat;
        return acc;
    }, {
        "pointerEvents:new": onNew,
        "pointerEvents:fired": onFired
    })
};
exports.default = holdRepeat;

},{"./base.js":"2a2dx","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"2F0Yd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extendJs = require("../utils/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
function install(scope) {
    const { Interactable  } = scope;
    Interactable.prototype.pointerEvents = pointerEventsMethod;
    const __backCompatOption = Interactable.prototype._backCompatOption;
    Interactable.prototype._backCompatOption = function(optionName, newValue) {
        const ret = __backCompatOption.call(this, optionName, newValue);
        if (ret === this) this.events.options[optionName] = newValue;
        return ret;
    };
}
function pointerEventsMethod(options) {
    (0, _extendJsDefault.default)(this.events.options, options);
    return this;
}
const plugin = {
    id: "pointer-events/interactableTargets",
    install,
    listeners: {
        "pointerEvents:collect-targets": ({ targets , node , type , eventTarget  }, scope)=>{
            scope.interactables.forEachMatch(node, (interactable)=>{
                const eventable = interactable.events;
                const options = eventable.options;
                if (eventable.types[type] && eventable.types[type].length && interactable.testIgnoreAllow(options, node, eventTarget)) targets.push({
                    node,
                    eventable,
                    props: {
                        interactable
                    }
                });
            });
        },
        "interactable:new": ({ interactable  })=>{
            interactable.events.getRect = function(element) {
                return interactable.getRect(element);
            };
        },
        "interactable:set": ({ interactable , options  }, scope)=>{
            (0, _extendJsDefault.default)(interactable.events.options, scope.pointerEvents.defaults);
            (0, _extendJsDefault.default)(interactable.events.options, options.pointerEvents || {});
        }
    }
};
exports.default = plugin;

},{"../utils/extend.js":"cmcmr","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iia1Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "install", ()=>install);
var _arrJs = require("../utils/arr.js");
var _isJs = require("../utils/is.js");
var _isJsDefault = parcelHelpers.interopDefault(_isJs);
var _miscJs = require("../utils/misc.js");
var _pointerUtilsJs = require("../utils/pointerUtils.js");
var _rectJs = require("../utils/rect.js");
function install(scope) {
    const { /** @lends Interactable */ Interactable  } = scope;
    scope.actions.phases.reflow = true;
    /**
   * ```js
   * const interactable = interact(target)
   * const drag = { name: drag, axis: 'x' }
   * const resize = { name: resize, edges: { left: true, bottom: true }
   *
   * interactable.reflow(drag)
   * interactable.reflow(resize)
   * ```
   *
   * Start an action sequence to re-apply modifiers, check drops, etc.
   *
   * @param { Object } action The action to begin
   * @param { string } action.name The name of the action
   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended
   */ Interactable.prototype.reflow = function(action) {
        return doReflow(this, action, scope);
    };
}
function doReflow(interactable, action, scope) {
    const elements = (0, _isJsDefault.default).string(interactable.target) ? _arrJs.from(interactable._context.querySelectorAll(interactable.target)) : [
        interactable.target
    ]; // tslint:disable-next-line variable-name
    const Promise = scope.window.Promise;
    const promises = Promise ? [] : null;
    for (const element of elements){
        const rect = interactable.getRect(element);
        if (!rect) break;
        const runningInteraction = _arrJs.find(scope.interactions.list, (interaction)=>{
            return interaction.interacting() && interaction.interactable === interactable && interaction.element === element && interaction.prepared.name === action.name;
        });
        let reflowPromise;
        if (runningInteraction) {
            runningInteraction.move();
            if (promises) reflowPromise = runningInteraction._reflowPromise || new Promise((resolve)=>{
                runningInteraction._reflowResolve = resolve;
            });
        } else {
            const xywh = (0, _rectJs.tlbrToXywh)(rect);
            const coords = {
                page: {
                    x: xywh.x,
                    y: xywh.y
                },
                client: {
                    x: xywh.x,
                    y: xywh.y
                },
                timeStamp: scope.now()
            };
            const event = _pointerUtilsJs.coordsToEvent(coords);
            reflowPromise = startReflow(scope, interactable, element, action, event);
        }
        if (promises) promises.push(reflowPromise);
    }
    return promises && Promise.all(promises).then(()=>interactable);
}
function startReflow(scope, interactable, element, action, event) {
    const interaction = scope.interactions.new({
        pointerType: "reflow"
    });
    const signalArg = {
        interaction,
        event,
        pointer: event,
        eventTarget: element,
        phase: "reflow"
    };
    interaction.interactable = interactable;
    interaction.element = element;
    interaction.prevEvent = event;
    interaction.updatePointer(event, event, element, true);
    _pointerUtilsJs.setZeroCoords(interaction.coords.delta);
    (0, _miscJs.copyAction)(interaction.prepared, action);
    interaction._doPhase(signalArg);
    const { Promise  } = scope.window;
    const reflowPromise = Promise ? new Promise((resolve)=>{
        interaction._reflowResolve = resolve;
    }) : undefined;
    interaction._reflowPromise = reflowPromise;
    interaction.start(action, interactable, element);
    if (interaction._interacting) {
        interaction.move(signalArg);
        interaction.end(event);
    } else {
        interaction.stop();
        interaction._reflowResolve();
    }
    interaction.removePointer(event, event);
    return reflowPromise;
}
const reflow = {
    id: "reflow",
    install,
    listeners: {
        // remove completed reflow interactions
        "interactions:stop": ({ interaction  }, scope)=>{
            if (interaction.pointerType === "reflow") {
                if (interaction._reflowResolve) interaction._reflowResolve();
                _arrJs.remove(scope.interactions.list, interaction);
            }
        }
    }
};
exports.default = reflow;

},{"../utils/arr.js":"8BYbE","../utils/is.js":"iRtxa","../utils/misc.js":"ckG7O","../utils/pointerUtils.js":"g0cI1","../utils/rect.js":"6qd7M","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"gp15G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelImagePreload", ()=>JuelImagePreload);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelImagePreload = class JuelImagePreload extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.type = "all";
    }
    firstUpdated() {
        if (this.type == "css" || this.type == "all") {
            let regex = /(?<=url\()[\w:/._\-%]+(?=\);?)/g;
            let styles = Array.prototype.slice.call(document.head.getElementsByTagName("style"));
            styles = styles.concat(Array.prototype.slice.call(document.body.getElementsByTagName("style")));
            styles = styles.filter((el)=>el.id != "juel-styles");
            for (let el of styles){
                let res = el.textContent.match(regex);
                if (res) res.forEach((match)=>{
                    let img = new Image();
                    img.src = match;
                });
            }
        }
        if (this.type == "element" || this.type == "all") {
            let els = Array.prototype.slice.call(document.body.getElementsByTagName("img"));
            for (let el1 of els){
                let img = new Image();
                img.src = el1.src;
            }
        }
    }
    createRenderRoot() {
        return this;
    }
};
__decorate([
    (0, _decorators.property)()
], JuelImagePreload.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)()
], JuelImagePreload.prototype, "exclude", void 0);
JuelImagePreload = __decorate([
    (0, _decorators.customElement)("juel-image-preload")
], JuelImagePreload);

},{"lit":"l2dGb","lit/decorators":"04xNl","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"9lAlL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelPage", ()=>JuelPage);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _pageLess = require("bundle-text:./Page.less");
var _pageLessDefault = parcelHelpers.interopDefault(_pageLess);
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelPage = class JuelPage extends (0, _juelComponent.JuelComponent) {
    load() {
        let header = this.shadowRoot.querySelector("header");
        let footer = this.shadowRoot.querySelector("footer");
        if (footer && header) {
            let offset = $(header).outerHeight() + $(footer).outerHeight();
            this.style.setProperty("--main-height", `calc((var(--vh) * 100) - ${offset}px`);
        } else if (footer) {
            let offset1 = footer.clientHeight;
            this.style.setProperty("--main-height", `calc((var(--vh) * 100) - ${offset1}px`);
        } else if (header) {
            let offset2 = header.clientHeight;
            this.style.setProperty("--main-height", `calc((var(--vh) * 100) - ${offset2}px`);
        }
    }
    render() {
        return (0, _lit.html)`<header><slot name="header"></slot></header>
        <aside id="left-side"><slot name="left"></aside><article><slot name="main"></slot></article><aside id="right-side"><slot name="right"></slot></aside>
        <footer><slot name="footer"></slot></footer>`;
    }
};
JuelPage.styles = (0, _lit.unsafeCSS)((0, _pageLessDefault.default));
JuelPage = __decorate([
    (0, _decorators.customElement)("juel-page")
], JuelPage);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Page.less":"crG3n","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"crG3n":[function(require,module,exports) {
module.exports = ":host {\n  --main-height: var(--vh) * 100;\n  height: calc(100 * var(--vh));\n  flex-direction: column;\n  display: flex;\n}\n\narticle {\n  overflow: scroll;\n}\n\n";

},{}],"9SPFn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelToolbar", ()=>JuelToolbar);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _ifDefined = require("lit/directives/if-defined");
var _juelComponent = require("../_Base/JuelComponent");
var _toolbarLess = require("bundle-text:./Toolbar.less");
var _toolbarLessDefault = parcelHelpers.interopDefault(_toolbarLess);
var _dispatchFunction = require("../_Core/DispatchFunction");
var _eventNames = require("../_Core/Events/EventNames");
var _fillTemplate = require("../_Utils/FillTemplate");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelToolbar = class JuelToolbar extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.items = [];
    }
    itemClicked(index, item) {
        let args = {
            index: index,
            item: item
        };
        (0, _dispatchFunction.Dispatch)(this, (0, _eventNames.EventNames).ItemSelected, args);
    }
    render() {
        let klass = "";
        if (this.vertical) klass += " vertical";
        return (0, _lit.html)`<div id="items" class="${klass}">
        ${this.items.map((item, index)=>{
            let i = index;
            let itm = item;
            if (item.template) return (0, _lit.html)`<div id="item-${i}" @click="${()=>this.itemClicked(i, itm)}">${(0, _fillTemplate.FillTemplate)(itm.template, itm)}</div>`;
            else return (0, _lit.html)`<juel-button id="item-${i}" label="${(0, _ifDefined.ifDefined)(item.label)}" @button-clicked=${()=>this.itemClicked(i, itm)}><juel-button>`;
        })}
        </div>`;
    }
};
JuelToolbar.styles = (0, _lit.unsafeCSS)((0, _toolbarLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelToolbar.prototype, "items", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelToolbar.prototype, "vertical", void 0);
JuelToolbar = __decorate([
    (0, _decorators.customElement)("juel-toolbar")
], JuelToolbar);

},{"lit":"l2dGb","lit/decorators":"04xNl","lit/directives/if-defined":"9nrkg","../_Base/JuelComponent":"bVHZk","bundle-text:./Toolbar.less":"jAk0i","../_Core/DispatchFunction":"6kMCY","../_Core/Events/EventNames":"eFaYm","../_Utils/FillTemplate":"cAWvu","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"jAk0i":[function(require,module,exports) {
module.exports = ":root {\n  width: 100%;\n}\n\n#items.vertical {\n  flex-direction: row;\n}\n\n#items.vertical * {\n  padding: 4px 2px;\n}\n\n#items div {\n  display: inline-block;\n}\n\n#items * {\n  padding: 2px 4px;\n}\n\n";

},{}],"fV3at":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelToolbarItem", ()=>JuelToolbarItem);
var _decorators = require("lit/decorators");
var _commandComponent = require("../_Base/CommandComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelToolbarItem = class JuelToolbarItem extends (0, _commandComponent.CommandComponent) {
    constructor(){
        super();
        this.item = {};
    }
    load(_changedProperties) {
        this.item.id = this.id;
        this.item.name = this.name;
        this.item.label = this.label;
        let template = this.querySelector("template");
        if (template) this.item.template = template.innerHTML;
        if (this.parentElement.nodeName.toUpperCase() == "JUEL-TOOLBAR") {
            let parent = this.parentElement;
            if (!parent.items.some((i)=>i == this.item)) {
                parent.items.push(this.item);
                parent.requestUpdate();
            }
        } else if (this.parentElement.nodeName.toUpperCase() == "JUEL-TOOLBARITEM") {
            let parent1 = this.parentElement;
            if (!parent1.item.items && parent1.item.items.length > 0) parent1.item.items = [];
            if (!parent1.item.items.some((i)=>i == this.item)) {
                parent1.item.items.push(this.item);
                let com = this.getParentComponent();
                com.requestUpdate();
            }
        }
    }
};
__decorate([
    (0, _decorators.property)()
], JuelToolbarItem.prototype, "name", void 0);
__decorate([
    (0, _decorators.property)()
], JuelToolbarItem.prototype, "label", void 0);
__decorate([
    (0, _decorators.property)()
], JuelToolbarItem.prototype, "icon", void 0);
JuelToolbarItem = __decorate([
    (0, _decorators.customElement)("juel-toolbar-item")
], JuelToolbarItem);

},{"lit/decorators":"04xNl","../_Base/CommandComponent":"dgzG7","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"dgzG7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommandComponent", ()=>CommandComponent);
var _juelComponent = require("./JuelComponent");
class CommandComponent extends (0, _juelComponent.JuelComponent) {
    getParentComponent() {
        if (this.parentElement) {
            if ("getParentComponent" in this.parentElement) return this.parentElement["getParentComponent"]();
            else return this.parentElement;
        }
    }
    createRenderRoot() {
        return this;
    }
}

},{"./JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"e57Ex":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelLightbox", ()=>JuelLightbox);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _lightboxLess = require("bundle-text:./Lightbox.less");
var _lightboxLessDefault = parcelHelpers.interopDefault(_lightboxLess);
var _externalMediaModule = require("../_Modules/ExternalMediaModule");
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelLightbox = class JuelLightbox extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.type = "image";
        this.icon = false;
        this.open = false;
        this.sources = [];
        this.content = [];
        this.position = 0;
    }
    firstLoad() {
        this.sp = this.shadowRoot.querySelector("juel-scroll-pane");
        var elements = Array.prototype.slice.call(document.querySelectorAll("[data-lightbox], [data-lightbox-src"));
        for (var el of elements){
            el.addEventListener("click", (e)=>{
                this.toggle(e);
            });
            if (el.hasAttribute("data-lightbox-src")) this.sources.push(el.dataset.lightboxSrc);
            else if (el.hasAttribute("src")) this.sources.push(el.getAttribute("src"));
        }
        this.requestUpdate();
        this.sp.requestUpdate();
    }
    load() {
        $(this.sp).off("scroll").on("scroll", (e)=>{
            console.log(e.detail);
            this.position = e.detail.index;
            this.requestUpdate();
        });
    }
    toggle(e) {
        e.stopPropagation();
        let lightboxContainer = this.shadowRoot.querySelector("#lightbox-container");
        if (this.open == true) {
            lightboxContainer.style.display = "none";
            this.open = false;
        } else {
            lightboxContainer.style.display = "flex";
            this.open = true;
        }
    }
    render() {
        return (0, _lit.html)`
            <div id="preview-container" @click="${this.toggle}">
                ${this.icon == true ? (0, _lit.html)`<div id="icon-container">
                            <a><slot name="icon"><slot></a>
                        </div>` : ``}
                <img src="${this.preview}" />
            </div>
            <div id="lightbox-container" @click="${this.toggle}"> 
                <div id="lightbox-nav">
                    <span>${this.position + 1} / ${this.sources.length}</span>
                    <div id="close" @click="${this.toggle}"></div>
                </div>
                <juel-scroll-pane id="lightbox-context" controls="true">
                    ${this.sources.map((src, index)=>{
            if (src.includes("youtu.be")) {
                var match = src.match((0, _externalMediaModule.ExternalMediaModule).youtube.regexp);
                if (match && match[2].length == 11) return (0, _externalMediaModule.ExternalMediaModule).youtube.template({
                    id: match[2]
                });
                return ``;
            } else return (0, _lit.html)`<img src="${src}">`;
        })}
                </juel-scroll-pane>
            </div>
        `;
    }
};
JuelLightbox.styles = (0, _lit.unsafeCSS)((0, _lightboxLessDefault.default));
__decorate([
    (0, _decorators.property)()
], JuelLightbox.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelLightbox.prototype, "icon", void 0);
__decorate([
    (0, _decorators.property)()
], JuelLightbox.prototype, "preview", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelLightbox.prototype, "position", void 0);
JuelLightbox = __decorate([
    (0, _decorators.customElement)("juel-lightbox")
], JuelLightbox);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Lightbox.less":"3HfXB","../_Modules/ExternalMediaModule":"lGqUr","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"3HfXB":[function(require,module,exports) {
module.exports = "#icon-container {\n  text-align: center;\n  margin: 0 auto;\n  position: absolute;\n  top: 50%;\n  left: 0;\n  right: 0;\n  transform: translateY(-50%);\n}\n\n#icon-container a {\n  filter: progid:DXImageTransform. Microsoft. gradient(startColorstr= \"#c054ff\", endColorstr= \"#5274ff\", GradientType= 0);\n  width: 60px;\n  height: 60px;\n  color: #fff;\n  text-align: center;\n  background: linear-gradient(#c054ff 0%, #5274ff 100%);\n  border-radius: 50%;\n  line-height: 60px;\n  display: inline-block;\n  position: relative;\n}\n\n#icon-container a:before {\n  content: \"\";\n  border-radius: inherit;\n  border: 1px solid #fff;\n  animation: 2s cubic-bezier(.23, 1, .32, 1) infinite both btnIconRipple;\n  display: inline-block;\n  position: absolute;\n  inset: -2px;\n}\n\n#icon-container a:after {\n  content: \"\";\n  z-index: 0;\n  background: none;\n  border: 70px solid #404dff1a;\n  border-radius: 50%;\n  position: absolute;\n  top: -38px;\n  left: -39px;\n  right: 0;\n}\n\n@keyframes btnIconRipple {\n  0% {\n    border-width: 4px;\n    transform: scale(1);\n  }\n\n  50% {\n    border-width: 1px;\n    transform: scale(1.5);\n  }\n\n  80% {\n    border-width: 1px;\n    transform: scale(1.9);\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n\n#lightbox-container {\n  z-index: 1000000000;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(#1e1e1ee6, #000 1810%);\n  flex-direction: column;\n  align-items: center;\n  font-family: Arial, sans-serif;\n  display: none;\n  position: fixed;\n  top: 0;\n  left: 0;\n}\n\n#lightbox-nav {\n  color: #fff;\n}\n\n:host {\n  display: inline-block;\n}\n\n#container {\n  display: inline-block;\n  position: relative;\n}\n\n#content {\n  position: relative;\n}\n\n#tabs, #tabs li {\n  display: inline-block;\n}\n\n#previous {\n  z-index: 1;\n  width: 15%;\n  color: #fff;\n  text-align: center;\n  opacity: .5;\n  background: none;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n}\n\n#previous span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-previous);\n}\n\n#next {\n  z-index: 1;\n  width: 15%;\n  color: #fff;\n  text-align: center;\n  opacity: .5;\n  background: none;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n\n#next span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-next);\n}\n\njuel-scroll-pane {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n\n#close {\n  height: 100%;\n  width: 45px;\n  cursor: pointer;\n  color: #fff;\n  background-image: var(--icon-close);\n}\n\n";

},{}],"lGqUr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExternalMediaModule", ()=>ExternalMediaModule);
var _lit = require("lit");
var ExternalMediaModule;
(function(ExternalMediaModule) {
    ExternalMediaModule.youtube = {
        regexp: /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/,
        link: "https://youtube.com",
        linkText: "YouTube",
        template: (info)=>{
            return (0, _lit.html)`<iframe width="560" height="315" src="https://www.youtube.com/embed/${info.id}" title="YouTube video player" frameborder="0" allowfullscreen></iframe>`;
        }
    };
})(ExternalMediaModule || (ExternalMediaModule = {}));

},{"lit":"l2dGb","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cm6wg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelFlip", ()=>JuelFlip);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _flipLess = require("bundle-text:./Flip.less");
var _flipLessDefault = parcelHelpers.interopDefault(_flipLess);
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelFlip = class JuelFlip extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.vertical = false;
        this.trigger = "click";
    }
    init() {
        let evtName;
        switch(this.trigger){
            case "click":
                evtName = "click";
                break;
            case "hover":
                evtName = "mouseenter";
                break;
        }
        $(this.shadowRoot.getElementById("container")).off().on(evtName, ()=>{
            let el = this.shadowRoot.getElementById("inner");
            if (this.vertical) el.classList.add("vertical");
            el.classList.toggle("flip");
        });
    }
    firstLoad() {
        this.init();
    }
    render() {
        return (0, _lit.html)` <div id="container">
        <div id="inner">
          <div class="front" part="front">
            <slot name="front"></front>>
          </div>
          <div class="back" part="back">
            <slot name="back"></slot>
          </div>
        </div>
      </div> `;
    }
};
JuelFlip.styles = (0, _lit.unsafeCSS)((0, _flipLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Boolean
    })
], JuelFlip.prototype, "vertical", void 0);
__decorate([
    (0, _decorators.property)()
], JuelFlip.prototype, "trigger", void 0);
JuelFlip = __decorate([
    (0, _decorators.customElement)("juel-flip")
], JuelFlip);

},{"lit":"l2dGb","lit/decorators":"04xNl","bundle-text:./Flip.less":"flNjJ","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"flNjJ":[function(require,module,exports) {
module.exports = "* {\n  height: 100%;\n}\n\n.container {\n  width: 300px;\n  height: 200px;\n  perspective: 1000px;\n  background-color: #0000;\n  border: 1px solid #f1f1f1;\n}\n\n#inner {\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  transform-style: preserve-3d;\n  transition: transform .8s;\n  position: relative;\n}\n\n#inner .front, #inner .back {\n  width: 100%;\n  height: 100%;\n  backface-visibility: hidden;\n}\n\n#inner.flip:not(.vertical) {\n  transform: rotateY(180deg);\n}\n\n#inner.flip.vertical, #inner.vertical .back {\n  transform: rotateX(180deg);\n}\n\n.front {\n  position: relative;\n}\n\n.back {\n  background: #fff;\n  position: absolute;\n  top: 0;\n  transform: rotateY(180deg);\n}\n\n::slotted(*) {\n  width: 100%;\n  height: 100%;\n}\n\n";

},{}],"7XKFx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelTilt", ()=>JuelTilt);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _vanillaTilt = require("vanilla-tilt");
var _vanillaTiltDefault = parcelHelpers.interopDefault(_vanillaTilt);
var _tiltLess = require("bundle-text:./Tilt.less");
var _tiltLessDefault = parcelHelpers.interopDefault(_tiltLess);
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelTilt = class JuelTilt extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super(...arguments);
        this.perspective = 250;
    }
    firstLoad() {
        let el = this.shadowRoot.getElementById("tilt");
        (0, _vanillaTiltDefault.default).init(el, {
            perspective: this.perspective
        });
        if (this.childElementCount > 1) el.style.transformStyle = "preserve-3d";
    }
    render() {
        return (0, _lit.html)`<div id="tilt">
            <slot></slot>
        </div>`;
    }
};
JuelTilt.styles = (0, _lit.unsafeCSS)((0, _tiltLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelTilt.prototype, "perspective", void 0);
JuelTilt = __decorate([
    (0, _decorators.customElement)("juel-tilt")
], JuelTilt);

},{"lit":"l2dGb","lit/decorators":"04xNl","vanilla-tilt":"iFZGP","bundle-text:./Tilt.less":"hBnv3","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"iFZGP":[function(require,module,exports) {
"use strict";
var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
};
/**
 * Created by Sergiu Șandor (micku7zu) on 1/27/2017.
 * Original idea: https://github.com/gijsroge/tilt.js
 * MIT License.
 * Version 1.7.2
 */ var VanillaTilt = function() {
    function VanillaTilt(element) {
        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, VanillaTilt);
        if (!(element instanceof Node)) throw "Can't initialize VanillaTilt because " + element + " is not a Node.";
        this.width = null;
        this.height = null;
        this.clientWidth = null;
        this.clientHeight = null;
        this.left = null;
        this.top = null;
        // for Gyroscope sampling
        this.gammazero = null;
        this.betazero = null;
        this.lastgammazero = null;
        this.lastbetazero = null;
        this.transitionTimeout = null;
        this.updateCall = null;
        this.event = null;
        this.updateBind = this.update.bind(this);
        this.resetBind = this.reset.bind(this);
        this.element = element;
        this.settings = this.extendSettings(settings);
        this.reverse = this.settings.reverse ? -1 : 1;
        this.glare = VanillaTilt.isSettingTrue(this.settings.glare);
        this.glarePrerender = VanillaTilt.isSettingTrue(this.settings["glare-prerender"]);
        this.fullPageListening = VanillaTilt.isSettingTrue(this.settings["full-page-listening"]);
        this.gyroscope = VanillaTilt.isSettingTrue(this.settings.gyroscope);
        this.gyroscopeSamples = this.settings.gyroscopeSamples;
        this.elementListener = this.getElementListener();
        if (this.glare) this.prepareGlare();
        if (this.fullPageListening) this.updateClientSize();
        this.addEventListeners();
        this.reset();
        this.updateInitialPosition();
    }
    VanillaTilt.isSettingTrue = function isSettingTrue(setting) {
        return setting === "" || setting === true || setting === 1;
    };
    /**
   * Method returns element what will be listen mouse events
   * @return {Node}
   */ VanillaTilt.prototype.getElementListener = function getElementListener() {
        if (this.fullPageListening) return window.document;
        if (typeof this.settings["mouse-event-element"] === "string") {
            var mouseEventElement = document.querySelector(this.settings["mouse-event-element"]);
            if (mouseEventElement) return mouseEventElement;
        }
        if (this.settings["mouse-event-element"] instanceof Node) return this.settings["mouse-event-element"];
        return this.element;
    };
    /**
   * Method set listen methods for this.elementListener
   * @return {Node}
   */ VanillaTilt.prototype.addEventListeners = function addEventListeners() {
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseMoveBind = this.onMouseMove.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.onWindowResizeBind = this.onWindowResize.bind(this);
        this.onDeviceOrientationBind = this.onDeviceOrientation.bind(this);
        this.elementListener.addEventListener("mouseenter", this.onMouseEnterBind);
        this.elementListener.addEventListener("mouseleave", this.onMouseLeaveBind);
        this.elementListener.addEventListener("mousemove", this.onMouseMoveBind);
        if (this.glare || this.fullPageListening) window.addEventListener("resize", this.onWindowResizeBind);
        if (this.gyroscope) window.addEventListener("deviceorientation", this.onDeviceOrientationBind);
    };
    /**
   * Method remove event listeners from current this.elementListener
   */ VanillaTilt.prototype.removeEventListeners = function removeEventListeners() {
        this.elementListener.removeEventListener("mouseenter", this.onMouseEnterBind);
        this.elementListener.removeEventListener("mouseleave", this.onMouseLeaveBind);
        this.elementListener.removeEventListener("mousemove", this.onMouseMoveBind);
        if (this.gyroscope) window.removeEventListener("deviceorientation", this.onDeviceOrientationBind);
        if (this.glare || this.fullPageListening) window.removeEventListener("resize", this.onWindowResizeBind);
    };
    VanillaTilt.prototype.destroy = function destroy() {
        clearTimeout(this.transitionTimeout);
        if (this.updateCall !== null) cancelAnimationFrame(this.updateCall);
        this.reset();
        this.removeEventListeners();
        this.element.vanillaTilt = null;
        delete this.element.vanillaTilt;
        this.element = null;
    };
    VanillaTilt.prototype.onDeviceOrientation = function onDeviceOrientation(event) {
        if (event.gamma === null || event.beta === null) return;
        this.updateElementPosition();
        if (this.gyroscopeSamples > 0) {
            this.lastgammazero = this.gammazero;
            this.lastbetazero = this.betazero;
            if (this.gammazero === null) {
                this.gammazero = event.gamma;
                this.betazero = event.beta;
            } else {
                this.gammazero = (event.gamma + this.lastgammazero) / 2;
                this.betazero = (event.beta + this.lastbetazero) / 2;
            }
            this.gyroscopeSamples -= 1;
        }
        var totalAngleX = this.settings.gyroscopeMaxAngleX - this.settings.gyroscopeMinAngleX;
        var totalAngleY = this.settings.gyroscopeMaxAngleY - this.settings.gyroscopeMinAngleY;
        var degreesPerPixelX = totalAngleX / this.width;
        var degreesPerPixelY = totalAngleY / this.height;
        var angleX = event.gamma - (this.settings.gyroscopeMinAngleX + this.gammazero);
        var angleY = event.beta - (this.settings.gyroscopeMinAngleY + this.betazero);
        var posX = angleX / degreesPerPixelX;
        var posY = angleY / degreesPerPixelY;
        if (this.updateCall !== null) cancelAnimationFrame(this.updateCall);
        this.event = {
            clientX: posX + this.left,
            clientY: posY + this.top
        };
        this.updateCall = requestAnimationFrame(this.updateBind);
    };
    VanillaTilt.prototype.onMouseEnter = function onMouseEnter() {
        this.updateElementPosition();
        this.element.style.willChange = "transform";
        this.setTransition();
    };
    VanillaTilt.prototype.onMouseMove = function onMouseMove(event) {
        if (this.updateCall !== null) cancelAnimationFrame(this.updateCall);
        this.event = event;
        this.updateCall = requestAnimationFrame(this.updateBind);
    };
    VanillaTilt.prototype.onMouseLeave = function onMouseLeave() {
        this.setTransition();
        if (this.settings.reset) requestAnimationFrame(this.resetBind);
    };
    VanillaTilt.prototype.reset = function reset() {
        this.event = {
            clientX: this.left + this.width / 2,
            clientY: this.top + this.height / 2
        };
        if (this.element && this.element.style) this.element.style.transform = "perspective(" + this.settings.perspective + "px) " + "rotateX(0deg) " + "rotateY(0deg) " + "scale3d(1, 1, 1)";
        this.resetGlare();
    };
    VanillaTilt.prototype.resetGlare = function resetGlare() {
        if (this.glare) {
            this.glareElement.style.transform = "rotate(180deg) translate(-50%, -50%)";
            this.glareElement.style.opacity = "0";
        }
    };
    VanillaTilt.prototype.updateInitialPosition = function updateInitialPosition() {
        if (this.settings.startX === 0 && this.settings.startY === 0) return;
        this.onMouseEnter();
        if (this.fullPageListening) this.event = {
            clientX: (this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.clientWidth,
            clientY: (this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.clientHeight
        };
        else this.event = {
            clientX: this.left + (this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.width,
            clientY: this.top + (this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.height
        };
        var backupScale = this.settings.scale;
        this.settings.scale = 1;
        this.update();
        this.settings.scale = backupScale;
        this.resetGlare();
    };
    VanillaTilt.prototype.getValues = function getValues() {
        var x = void 0, y = void 0;
        if (this.fullPageListening) {
            x = this.event.clientX / this.clientWidth;
            y = this.event.clientY / this.clientHeight;
        } else {
            x = (this.event.clientX - this.left) / this.width;
            y = (this.event.clientY - this.top) / this.height;
        }
        x = Math.min(Math.max(x, 0), 1);
        y = Math.min(Math.max(y, 0), 1);
        var tiltX = (this.reverse * (this.settings.max - x * this.settings.max * 2)).toFixed(2);
        var tiltY = (this.reverse * (y * this.settings.max * 2 - this.settings.max)).toFixed(2);
        var angle = Math.atan2(this.event.clientX - (this.left + this.width / 2), -(this.event.clientY - (this.top + this.height / 2))) * (180 / Math.PI);
        return {
            tiltX: tiltX,
            tiltY: tiltY,
            percentageX: x * 100,
            percentageY: y * 100,
            angle: angle
        };
    };
    VanillaTilt.prototype.updateElementPosition = function updateElementPosition() {
        var rect = this.element.getBoundingClientRect();
        this.width = this.element.offsetWidth;
        this.height = this.element.offsetHeight;
        this.left = rect.left;
        this.top = rect.top;
    };
    VanillaTilt.prototype.update = function update() {
        var values = this.getValues();
        this.element.style.transform = "perspective(" + this.settings.perspective + "px) " + "rotateX(" + (this.settings.axis === "x" ? 0 : values.tiltY) + "deg) " + "rotateY(" + (this.settings.axis === "y" ? 0 : values.tiltX) + "deg) " + "scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")";
        if (this.glare) {
            this.glareElement.style.transform = "rotate(" + values.angle + "deg) translate(-50%, -50%)";
            this.glareElement.style.opacity = "" + values.percentageY * this.settings["max-glare"] / 100;
        }
        this.element.dispatchEvent(new CustomEvent("tiltChange", {
            "detail": values
        }));
        this.updateCall = null;
    };
    /**
   * Appends the glare element (if glarePrerender equals false)
   * and sets the default style
   */ VanillaTilt.prototype.prepareGlare = function prepareGlare() {
        // If option pre-render is enabled we assume all html/css is present for an optimal glare effect.
        if (!this.glarePrerender) {
            // Create glare element
            var jsTiltGlare = document.createElement("div");
            jsTiltGlare.classList.add("js-tilt-glare");
            var jsTiltGlareInner = document.createElement("div");
            jsTiltGlareInner.classList.add("js-tilt-glare-inner");
            jsTiltGlare.appendChild(jsTiltGlareInner);
            this.element.appendChild(jsTiltGlare);
        }
        this.glareElementWrapper = this.element.querySelector(".js-tilt-glare");
        this.glareElement = this.element.querySelector(".js-tilt-glare-inner");
        if (this.glarePrerender) return;
        Object.assign(this.glareElementWrapper.style, {
            "position": "absolute",
            "top": "0",
            "left": "0",
            "width": "100%",
            "height": "100%",
            "overflow": "hidden",
            "pointer-events": "none"
        });
        Object.assign(this.glareElement.style, {
            "position": "absolute",
            "top": "50%",
            "left": "50%",
            "pointer-events": "none",
            "background-image": "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)",
            "transform": "rotate(180deg) translate(-50%, -50%)",
            "transform-origin": "0% 0%",
            "opacity": "0"
        });
        this.updateGlareSize();
    };
    VanillaTilt.prototype.updateGlareSize = function updateGlareSize() {
        if (this.glare) {
            var glareSize = (this.element.offsetWidth > this.element.offsetHeight ? this.element.offsetWidth : this.element.offsetHeight) * 2;
            Object.assign(this.glareElement.style, {
                "width": glareSize + "px",
                "height": glareSize + "px"
            });
        }
    };
    VanillaTilt.prototype.updateClientSize = function updateClientSize() {
        this.clientWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        this.clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    };
    VanillaTilt.prototype.onWindowResize = function onWindowResize() {
        this.updateGlareSize();
        this.updateClientSize();
    };
    VanillaTilt.prototype.setTransition = function setTransition() {
        var _this = this;
        clearTimeout(this.transitionTimeout);
        this.element.style.transition = this.settings.speed + "ms " + this.settings.easing;
        if (this.glare) this.glareElement.style.transition = "opacity " + this.settings.speed + "ms " + this.settings.easing;
        this.transitionTimeout = setTimeout(function() {
            _this.element.style.transition = "";
            if (_this.glare) _this.glareElement.style.transition = "";
        }, this.settings.speed);
    };
    /**
   * Method return patched settings of instance
   * @param {boolean} settings.reverse - reverse the tilt direction
   * @param {number} settings.max - max tilt rotation (degrees)
   * @param {startX} settings.startX - the starting tilt on the X axis, in degrees. Default: 0
   * @param {startY} settings.startY - the starting tilt on the Y axis, in degrees. Default: 0
   * @param {number} settings.perspective - Transform perspective, the lower the more extreme the tilt gets
   * @param {string} settings.easing - Easing on enter/exit
   * @param {number} settings.scale - 2 = 200%, 1.5 = 150%, etc..
   * @param {number} settings.speed - Speed of the enter/exit transition
   * @param {boolean} settings.transition - Set a transition on enter/exit
   * @param {string|null} settings.axis - What axis should be disabled. Can be X or Y
   * @param {boolean} settings.glare - What axis should be disabled. Can be X or Y
   * @param {number} settings.max-glare - the maximum "glare" opacity (1 = 100%, 0.5 = 50%)
   * @param {boolean} settings.glare-prerender - false = VanillaTilt creates the glare elements for you, otherwise
   * @param {boolean} settings.full-page-listening - If true, parallax effect will listen to mouse move events on the whole document, not only the selected element
   * @param {string|object} settings.mouse-event-element - String selector or link to HTML-element what will be listen mouse events
   * @param {boolean} settings.reset - false = If the tilt effect has to be reset on exit
   * @param {gyroscope} settings.gyroscope - Enable tilting by deviceorientation events
   * @param {gyroscopeSensitivity} settings.gyroscopeSensitivity - Between 0 and 1 - The angle at which max tilt position is reached. 1 = 90deg, 0.5 = 45deg, etc..
   * @param {gyroscopeSamples} settings.gyroscopeSamples - How many gyroscope moves to decide the starting position.
   */ VanillaTilt.prototype.extendSettings = function extendSettings(settings) {
        var defaultSettings = {
            reverse: false,
            max: 15,
            startX: 0,
            startY: 0,
            perspective: 1000,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: 1,
            speed: 300,
            transition: true,
            axis: null,
            glare: false,
            "max-glare": 1,
            "glare-prerender": false,
            "full-page-listening": false,
            "mouse-event-element": null,
            reset: true,
            gyroscope: true,
            gyroscopeMinAngleX: -45,
            gyroscopeMaxAngleX: 45,
            gyroscopeMinAngleY: -45,
            gyroscopeMaxAngleY: 45,
            gyroscopeSamples: 10
        };
        var newSettings = {};
        for(var property in defaultSettings){
            if (property in settings) newSettings[property] = settings[property];
            else if (this.element.hasAttribute("data-tilt-" + property)) {
                var attribute = this.element.getAttribute("data-tilt-" + property);
                try {
                    newSettings[property] = JSON.parse(attribute);
                } catch (e) {
                    newSettings[property] = attribute;
                }
            } else newSettings[property] = defaultSettings[property];
        }
        return newSettings;
    };
    VanillaTilt.init = function init(elements, settings) {
        if (elements instanceof Node) elements = [
            elements
        ];
        if (elements instanceof NodeList) elements = [].slice.call(elements);
        if (!(elements instanceof Array)) return;
        elements.forEach(function(element) {
            if (!("vanillaTilt" in element)) element.vanillaTilt = new VanillaTilt(element, settings);
        });
    };
    return VanillaTilt;
}();
if (typeof document !== "undefined") {
    /* expose the class to window */ window.VanillaTilt = VanillaTilt;
    /**
   * Auto load
   */ VanillaTilt.init(document.querySelectorAll("[data-tilt]"));
}
module.exports = VanillaTilt;

},{}],"hBnv3":[function(require,module,exports) {
module.exports = ":host {\n  display: inline-flex;\n  position: relative;\n}\n\n";

},{}],"h5x8O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelIcons", ()=>JuelIcons);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _arrayConverter = require("../_Converters/ArrayConverter");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelIcons = class JuelIcons extends (0, _lit.LitElement) {
    createRenderRoot() {
        return this;
    }
    updated() {
        if (this.icons && this.icons) {
            let el = $(this.querySelector("#juel-icons"));
            el.empty();
            for (let name of this.icons){
                let svg = juel.icon.get(name);
                if (svg) el.append(svg);
            }
        }
    }
    render() {
        return (0, _lit.html)`<div id="juel-icons" class="hidden"></div>`;
    }
};
__decorate([
    (0, _decorators.property)({
        converter: (0, _arrayConverter.ArrayConverter)()
    })
], JuelIcons.prototype, "icons", void 0);
JuelIcons = __decorate([
    (0, _decorators.customElement)("juel-icons")
], JuelIcons);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Converters/ArrayConverter":"kTirk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"5XoDN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelContents", ()=>JuelContents);
var _bindDecorator = require("bind-decorator");
var _bindDecoratorDefault = parcelHelpers.interopDefault(_bindDecorator);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _nextUntil = require("../_Utils/NextUntil");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelContents = class JuelContents extends (0, _lit.LitElement) {
    populateContents() {
        this.contents = [];
        var h1s = document.querySelectorAll("h1");
        for (let h1 of h1s){
            let item = {
                id: h1.id,
                title: h1.textContent
            };
            let h2s = (0, _nextUntil.NextUntil)(h1, `h1`, `h2`);
            for (let h2 of h2s)this.populateChildren(h2, 2, item);
            this.contents.push(item);
        }
    }
    populateChildren(heading, level, item) {
        let child = {
            id: heading.id,
            title: heading.textContent
        };
        let childHeadings = (0, _nextUntil.NextUntil)(heading, `h${level}`, `h${level + 1}`);
        for (let h of childHeadings)this.populateChildren(h, level + 1, child);
        if (!item.children) item.children = [
            child
        ];
        else item.children.push(child);
    }
    firstUpdated() {
        setTimeout(()=>{
            this.populateContents();
            this.requestUpdate();
        });
    }
    renderContentsItem(item) {
        return (0, _lit.html)`<li>
            <a href="#${item.id}">${item.title}</a>
            ${item.children ? (0, _lit.html)`<ul>
                    ${item.children.map(this.renderContentsItem)}
                </ul>` : ""}
        </li>`;
    }
    render() {
        return (0, _lit.html)`
            <ul id="toc">
                ${this.contents ? this.contents.map(this.renderContentsItem) : ""}
            </ul>
        `;
    }
};
__decorate([
    (0, _bindDecoratorDefault.default)
], JuelContents.prototype, "renderContentsItem", null);
JuelContents = __decorate([
    (0, _decorators.customElement)("juel-contents")
], JuelContents);

},{"bind-decorator":"fKOgr","lit":"l2dGb","lit/decorators":"04xNl","../_Utils/NextUntil":"6TX5G","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"6TX5G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NextUntil", ()=>NextUntil);
function NextUntil(elem, selector, filter) {
    var siblings = [];
    elem = elem.nextElementSibling;
    while(elem){
        if (elem.matches(selector)) break;
        if (filter && !elem.matches(filter)) {
            elem = elem.nextElementSibling;
            continue;
        }
        siblings.push(elem);
        elem = elem.nextElementSibling;
    }
    return siblings;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bKVa3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelTemplate", ()=>JuelTemplate);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _fillTemplate = require("../_Utils/FillTemplate");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelTemplate = class JuelTemplate extends (0, _lit.LitElement) {
    render() {
        return (0, _lit.html)`${this.context ? (0, _fillTemplate.FillTemplate)(this.innerHTML, this.context) : (0, _lit.nothing)}`;
    }
};
__decorate([
    (0, _decorators.property)()
], JuelTemplate.prototype, "context", void 0);
JuelTemplate = __decorate([
    (0, _decorators.customElement)("juel-template")
], JuelTemplate);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Utils/FillTemplate":"cAWvu","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"cdwqj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpeechSection", ()=>SpeechSection);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _speechSectionService = require("./SpeechSectionService");
var _speechSectionCss = require("bundle-text:./SpeechSection.css");
var _speechSectionCssDefault = parcelHelpers.interopDefault(_speechSectionCss);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SpeechSection = class SpeechSection extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.pitchLabel = "Pitch";
        this.rateLabel = "Rate";
        this.voiceLabel = "Voice";
        this.volumeLabel = "Volume";
        this.controlPitch = false;
        this.controlRate = false;
        this.controlVolume = false;
        this.service = new (0, _speechSectionService.SpeechSectionService)(this);
        this.service.getVoices();
    }
    firstUpdated() {
        this.service.init();
        this.service.volume = this.volume;
    }
    render() {
        return (0, _lit.html)`
        <div class="header">
            <div class="trigger"><slot name="trigger">💬</slot></div>
            ${this.controls == "true" ? (0, _lit.html)`
                    <span class="control">
                        <label for="voice">${this.voiceLabel}</label>
                        <select id="voice" @change="${this.service.voiceChangeHandler}">
                            ${this.service.voices.map((v, i)=>(0, _lit.html)`<option value="${i}">${v.name} (${v.lang})</option>`)}
                        </select>
                    </span>
                    ${this.controlVolume ? (0, _lit.html)`
                        <span class="control">
                            <label for="volume">${this.volumeLabel}</label>
                            <input type="range" id="volume" name="volume"
                                value="1" min="0" max="1" step=".01" @change="${this.service.volumeChangeHandler}">
                        </span>` : ""}
                    ${this.controlRate ? (0, _lit.html)`
                            <span class="control">
                                <label for="rate">${this.rateLabel}</label>
                                <input type="range" id="rate"
                                    value="1" min="0" max="1" step=".01" @change="${this.service.rateChangeHandler}">
                            </span>` : ""}
                    ${this.controlPitch ? (0, _lit.html)`
                            <span class="control">
                                <label for="pitch">${this.pitchLabel}</label>
                                <input type="range" id="pitch"
                                    value="1" min="0" max="1" step=".01" @change="${this.service.pitchChangeHandler}">
                            </span>` : ""}
                    ` : ""}
        </div>
        <div class="content"><slot name="content"></slot></div>`;
    }
};
SpeechSection.styles = (0, _lit.unsafeCSS)((0, _speechSectionCssDefault.default));
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "lang", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "pitch", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "pitchLabel", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "rate", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "rateLabel", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "voice", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "voiceLabel", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "volume", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "volumeLabel", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "controls", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "controlPitch", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "controlRate", void 0);
__decorate([
    (0, _decorators.property)()
], SpeechSection.prototype, "controlVolume", void 0);
SpeechSection = __decorate([
    (0, _decorators.customElement)("speech-section")
], SpeechSection);

},{"lit":"l2dGb","lit/decorators":"04xNl","./SpeechSectionService":"e44XZ","bundle-text:./SpeechSection.css":"1OOLw","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"e44XZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpeechSectionService", ()=>SpeechSectionService);
class SpeechSectionService {
    constructor(ele){
        this.voiceIndex = 0;
        this.ele = ele;
        this.voiceChangeHandler = this.voiceChangeHandler.bind(this);
        this.volumeChangeHandler = this.volumeChangeHandler.bind(this);
        this.rateChangeHandler = this.rateChangeHandler.bind(this);
        this.pitchChangeHandler = this.pitchChangeHandler.bind(this);
    }
    getVoices() {
        this.voices = window.speechSynthesis.getVoices();
    }
    voiceChangeHandler(e) {
        this.voiceIndex = e.target.value;
    }
    volumeChangeHandler(e) {
        this.volume = e.target.value;
    }
    rateChangeHandler(e) {
        this.rate = e.target.value;
    }
    pitchChangeHandler(e) {
        this.pitch = e.target.value;
    }
    initExternalControl() {
        let con = $(this.ele.controls);
        con.find('[data-control="voice"]').each((index, element)=>{
            let options = this.voices.map((v, voiceIndex)=>{
                let opt = document.createElement("option");
                opt.value = voiceIndex.toString();
                opt.text = `${v.name} (${v.lang})`;
                return opt;
            });
            $(element).append(options);
        }).change(this.voiceChangeHandler).on("selectmenuchange", this.voiceChangeHandler);
        con.find('[data-control="volume"]').on("slidechange", (e, ui)=>{
            e.target.value = ui.value;
            this.volumeChangeHandler(e);
        });
        con.find('[data-control="rate"]').on("slidechange", (e, ui)=>{
            e.target.value = ui.value;
            this.rateChangeHandler(e);
        });
        con.find('[data-control="pitch"]').on("slidechange", (e, ui)=>{
            e.target.value = ui.value / 100;
            this.pitchChangeHandler(e);
        });
    }
    init() {
        let $ele = $(this.ele);
        if (this.ele.controls != "true" && this.ele.controls != "false") this.initExternalControl();
        $(this.ele.shadowRoot).find(".trigger").click((e)=>{
            let text = $ele.find('[slot="content"').text();
            let udder = new SpeechSynthesisUtterance(text);
            if (this.voices) udder.voice = this.voices[this.voiceIndex];
            if (this.volume) udder.volume = this.volume;
            if (this.rate) udder.rate = this.rate;
            if (this.pitch) udder.pitch = this.pitch;
            window.speechSynthesis.speak(udder);
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1OOLw":[function(require,module,exports) {
module.exports = ":host {\n  --trigger-font-size: 2em;\n}\n\n.trigger {\n  cursor: pointer;\n  font-size: var(--trigger-font-size);\n}\n\nspan.control {\n  display: inline-grid;\n}\n\n";

},{}],"6kGc0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FishEye", ()=>FishEye);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _fishEyeService = require("./FishEyeService");
var _fishEyeCss = require("bundle-text:./FishEye.css");
var _fishEyeCssDefault = parcelHelpers.interopDefault(_fishEyeCss);
var _juelComponent = require("../_Base/JuelComponent");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let FishEye = class FishEye extends (0, _juelComponent.JuelComponent) {
    constructor(){
        super();
        this.service = new (0, _fishEyeService.FishEyeService)(this);
    }
    firstLoad() {
        this.service.init();
    }
    createRenderRoot() {
        return this;
    }
};
FishEye.styles = (0, _lit.unsafeCSS)((0, _fishEyeCssDefault.default));
__decorate([
    (0, _decorators.property)()
], FishEye.prototype, "closeWidth", void 0);
__decorate([
    (0, _decorators.property)()
], FishEye.prototype, "closeHeight", void 0);
__decorate([
    (0, _decorators.property)()
], FishEye.prototype, "openWidth", void 0);
__decorate([
    (0, _decorators.property)()
], FishEye.prototype, "openHeight", void 0);
FishEye = __decorate([
    (0, _decorators.customElement)("fish-eye")
], FishEye);

},{"lit":"l2dGb","lit/decorators":"04xNl","./FishEyeService":"7dTF9","bundle-text:./FishEye.css":"56aaA","../_Base/JuelComponent":"bVHZk","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"7dTF9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FishEyeService", ()=>FishEyeService);
const caption_class = ".caption";
class FishEyeService {
    constructor(ele){
        this.ele = ele;
    }
    close(ele) {
        let w = this.ele.closeWidth;
        let h = this.ele.closeHeight;
        if (ele[0]) ele[0].style.transform = "scale(1)";
        ele.removeClass("open");
        ele.children(caption_class).css({
            display: "none"
        });
    }
    open(ele, scale, displayCaption) {
        let w = this.ele.openWidth;
        let h = this.ele.openHeight;
        let caption = ele.children(caption_class);
        if (ele[0] && displayCaption && caption.length > 0) ele[0].style.transform = `scale(${scale}) translate(0, -${caption.height() / 2}px)`;
        else if (ele[0]) ele[0].style.transform = `scale(${scale})`;
        if (scale >= 1) {
            ele.addClass("open");
            if (displayCaption) ele.children(caption_class).css({
                display: "block",
                top: -(h * scale / 2)
            });
        } else ele.addClass("lui-fisheye-part");
    }
    init() {
        $(this.ele).children().each((index, element)=>{
            let $this = $(element);
            var title = $this.find(caption_class);
            let w = this.ele.style.getPropertyValue("--closeWidth");
            let h = this.ele.style.getPropertyValue("--closeHeight");
            title.css({
                display: "none"
            });
            $this.hover(()=>{
                this.open($this.prev(), 2);
                this.open($this, 3, true);
                this.open($this.next(), 2);
            }, ()=>{
                this.close($this.prev());
                this.close($this);
                this.close($this.next());
            });
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"56aaA":[function(require,module,exports) {
module.exports = ":host * {\n  text-align: center;\n}\n\n";

},{}],"5i8sQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoxMenu", ()=>BoxMenu);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _boxMenuService = require("./BoxMenuService");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let BoxMenu = class BoxMenu extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.slice = 1;
        this.span = 2;
        this.width = 100;
        this.height = 100;
        this.type = "cascade";
        this.pattern = "zigzag";
        this.duration = "fast";
        this.direction = "right";
        this.service = new (0, _boxMenuService.BoxMenuService)(this);
    }
    firstUpdated() {
        this.service.init();
    }
    render() {
        return (0, _lit.html)`<slot></slot>`;
    }
};
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "slice", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "span", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "width", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "height", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "type", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "pattern", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "duration", void 0);
__decorate([
    (0, _decorators.property)()
], BoxMenu.prototype, "direction", void 0);
BoxMenu = __decorate([
    (0, _decorators.customElement)("box-menu")
], BoxMenu);

},{"lit":"l2dGb","lit/decorators":"04xNl","./BoxMenuService":"gfhWU","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"gfhWU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoxMenuService", ()=>BoxMenuService);
class BoxMenuService {
    constructor(ele){
        this.changeDirection = false;
        this.dirCase = 1;
        this.patternPoints = [];
        this.ele = ele;
    }
    bindElementEvents(index, ele, pos) {
        ele.bind("mouseenter", (e)=>{
            let $this = $(e.target);
            event.stopPropagation();
            this.closeFollowing($this);
            pos = {
                x: $this.offset().left,
                y: $this.offset().top
            };
            if (this.ele.type != "all" && this.ele.type != "all-cascade") this.showNextElement(index, $this, pos);
        }).bind("mouseleave", function(e) {
            let $this = $(this);
            if (index == 0) {
                if ($this.nextAll(".open").length < 1) $this.removeClass("open").hide();
            } else if ($this.prevAll(".open").length < 1) $this.removeClass("open").hide();
        });
    }
    closeFollowing(ele) {
        ele.nextAll(".open").removeClass("open").hide();
    }
    closeOpenSiblings(listItem) {
        listItem.siblings().removeClass("open").each(function(index, element) {
            $(element).children().slice(1).removeClass("open").hide();
        });
    }
    closeOpenChildren(listItem) {
        listItem.children(".open").removeClass("open").hide();
    }
    showElement(index, ele, pos) {
        var pre = ele.prev();
        ele.css({
            left: pos.x,
            top: pos.y,
            zIndex: parseInt(pre.css("zIndex")) - 1
        }).unbind("mouseenter mouseleave");
        pos.x += this.patternPoints[index].x;
        pos.y += this.patternPoints[index].y;
        ele.stop().show().animate({
            left: pos.x,
            top: pos.y
        }, this.ele.duration, ()=>{
            this.bindElementEvents(index, ele, pos);
        }).addClass("open");
    }
    showNextElement(index, ele, pos) {
        var next = ele.next();
        if (next.length > 0) this.showElement(index + 1, next, pos);
    }
    showAllCascade(index, ele, pos) {
        var pre = ele.prev();
        var x = pre.position().left;
        var y = pre.position().top;
        ele.css({
            left: pos.x,
            top: pos.y,
            zIndex: pre.css("zIndex") - 1
        });
        pos.x += this.patternPoints[index].x;
        pos.y += this.patternPoints[index].y;
        ele.stop().show().animate({
            left: pos.x,
            top: pos.y
        }, this.ele.duration, ()=>{
            var next = ele.next();
            if (next.length > 0) this.showAllCascade(index + 1, next, pos);
        }).addClass("open");
    }
    createPatternPositions(index, pre) {
        switch(this.ele.pattern){
            case "zigzag":
                if (pre && index != 0 && index % this.ele.span == 0) {
                    this.patternPoints[index] = {
                        x: pre.width(),
                        y: 0
                    };
                    this.changeDirection = !this.changeDirection;
                } else if (pre) {
                    if (!this.changeDirection) this.patternPoints[index] = {
                        x: 0,
                        y: pre.height()
                    };
                    else this.patternPoints[index] = {
                        x: 0,
                        y: -pre.height()
                    };
                }
                break;
            case "square":
                if (index != 0) {
                    switch(this.dirCase){
                        case 1:
                            this.patternPoints[index] = {
                                x: pre.width(),
                                y: 0
                            };
                            break;
                        case 2:
                            this.patternPoints[index] = {
                                x: 0,
                                y: -pre.height()
                            };
                            break;
                        case 3:
                            this.patternPoints[index] = {
                                x: -pre.width(),
                                y: 0
                            };
                            break;
                        case 4:
                            this.patternPoints[index] = {
                                x: 0,
                                y: pre.height()
                            };
                            break;
                    }
                    if ((index + 1) % this.patternCount == 0) {
                        this.dirCase++;
                        if (this.dirCase == 2 || this.dirCase == 4) this.patternCount++;
                        if (this.dirCase > 4) this.dirCase = 1;
                    }
                } else this.patternPoints[index] = {
                    x: 0,
                    y: pre.height()
                };
                break;
        }
    }
    init() {
        let $ele = $(this.ele);
        $ele.children().each((index, element)=>{
            var listItem = $(element);
            var pos = {
                x: listItem.position().left,
                y: listItem.position().top + listItem.height() + 4
            };
            if (this.ele.pattern == "square" && !this.patternCount) this.patternCount = 1;
            listItem.children().first().css({
                position: "relative",
                zIndex: 100,
                width: this.ele.width,
                height: this.ele.height
            });
            listItem.children().slice(1).css({
                position: "absolute",
                width: this.ele.width,
                height: this.ele.height
            }).hide();
            listItem.children().slice(1).each((index, child)=>{
                this.createPatternPositions(index, $(child).prev());
            });
            listItem.bind("mouseenter", ()=>{
                if (listItem.children().slice(1).hasClass("open")) listItem.children().removeClass("open").slice(1).hide();
                else {
                    pos = {
                        x: listItem.offset().left,
                        y: listItem.offset().top
                    };
                    this.closeOpenSiblings(listItem);
                    this.closeOpenChildren(listItem);
                    if (this.ele.type == "all") listItem.children().slice(1).each((index, child)=>{
                        this.showElement(index, $(child), pos);
                    });
                    else if (this.ele.type == "all-cascade") listItem.children().first().each((index, child)=>{
                        var next = $(child).next();
                        if (next.length > 0) this.showAllCascade(index, next, pos);
                    });
                    else if (this.ele.type == "cascade") listItem.children().slice(1).each((index, child)=>{
                        if (index == 0) this.showElement(index, $(child), pos);
                    });
                    listItem.addClass("open");
                }
            });
            listItem.bind("mouseleave", function() {
                if (!listItem.children().slice(1).hasClass("open")) listItem.children().removeClass("open").slice(1).hide();
            });
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"bGUf5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelSpinner", ()=>JuelSpinner);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _arrayRange = require("../_Utils/ArrayRange");
var _spinnerLess = require("bundle-text:./Spinner.less");
var _spinnerLessDefault = parcelHelpers.interopDefault(_spinnerLess);
var _hammerjs = require("hammerjs");
var _hammerjsDefault = parcelHelpers.interopDefault(_hammerjs);
var _mathUtil = require("../_Utils/MathUtil");
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let JuelSpinner = class JuelSpinner extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.value = "0";
        this.min = 0;
        this.max = 10;
        this.step = 1;
        this.pos = 0;
        if (!("Hammer" in window)) window["Hammer"] = (0, _hammerjsDefault.default);
    }
    setTransition(el) {
        el.style.transition = "margin .73s";
    }
    firstUpdated() {
        let items = this.shadowRoot.getElementById("items");
        let mc = new (0, _hammerjsDefault.default)(this.shadowRoot.getElementById("container"));
        mc.get("pan").set({
            direction: (0, _hammerjsDefault.default).DIRECTION_VERTICAL
        });
        mc.on("pan", (e)=>{
            let margin = (0, _mathUtil.MathUtil).clamp(this.pos + e.deltaY * -1, -((items.childElementCount - 1) * 100 + 50), 50);
            items.style.marginTop = `${margin}px`;
            items.style.transition = null;
        });
        mc.on("panend", (e)=>{
            this.pos = (0, _mathUtil.MathUtil).clamp(this.pos + Math.round(e.deltaY * -1 / 100) * 100, -((items.childElementCount - 1) * 100), 0);
            items.style.marginTop = `${this.pos}px`;
            this.setTransition(items);
            let index = this.pos < 0 ? this.pos / -100 : 0;
            let ray = this.items ? this.items : (0, _arrayRange.ArrayRange)(this.min, this.max, this.step);
            this.value = ray[index];
        });
    }
    increase() {
        let items = this.shadowRoot.getElementById("items");
        this.pos = (0, _mathUtil.MathUtil).clamp(this.pos + 100, -((items.childElementCount - 1) * 100), 0);
        items.style.marginTop = `${this.pos}px`;
        this.setTransition(items);
    }
    decrease() {
        let items = this.shadowRoot.getElementById("items");
        this.pos = (0, _mathUtil.MathUtil).clamp(this.pos + -100, -((items.childElementCount - 1) * 100), 0);
        items.style.marginTop = `${this.pos}px`;
        this.setTransition(items);
    }
    render() {
        return (0, _lit.html)`
            <button id="increase" @click="${this.increase}"></button>
            <div id="container">
            <div id="items">
                ${(this.items ? this.items : (0, _arrayRange.ArrayRange)(this.min, this.max, this.step)).map((item, index)=>{
            return (0, _lit.html)`<h1>${item}</h1>`;
        })}
            </div>
            </div>
            <button id="decrease" @click="${this.decrease}"></button>
        `;
    }
};
JuelSpinner.styles = (0, _lit.unsafeCSS)((0, _spinnerLessDefault.default));
__decorate([
    (0, _decorators.property)({
        type: String
    })
], JuelSpinner.prototype, "value", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelSpinner.prototype, "min", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelSpinner.prototype, "max", void 0);
__decorate([
    (0, _decorators.property)({
        type: Number
    })
], JuelSpinner.prototype, "step", void 0);
__decorate([
    (0, _decorators.property)({
        type: Array
    })
], JuelSpinner.prototype, "items", void 0);
JuelSpinner = __decorate([
    (0, _decorators.customElement)("juel-spinner")
], JuelSpinner);

},{"lit":"l2dGb","lit/decorators":"04xNl","../_Utils/ArrayRange":"kuZLZ","bundle-text:./Spinner.less":"lgeLP","hammerjs":"doxZZ","../_Utils/MathUtil":"1s0zc","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"kuZLZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ArrayRange", ()=>ArrayRange);
function ArrayRange(start, stop, step) {
    return Array.from({
        length: (stop - start) / step + 1
    }, (_, i)=>start + i * step);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"lgeLP":[function(require,module,exports) {
module.exports = ":host {\n  display: inline-flex;\n}\n\n#container {\n  height: 100px;\n  overflow: hidden;\n}\n\n#items h1 {\n  height: 100px;\n  margin: 0;\n  font-size: 64px;\n}\n\n";

},{}],"1s0zc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MathUtil", ()=>MathUtil);
var MathUtil;
(function(MathUtil) {
    function clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }
    MathUtil.clamp = clamp;
})(MathUtil || (MathUtil = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"8wQqb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JuelReciteme", ()=>JuelReciteme);
var _lit = require("lit");
var _decorators = require("lit/decorators");
var _accessSvg = require("data-url:~/icons/access.svg");
var _accessSvgDefault = parcelHelpers.interopDefault(_accessSvg);
var __decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var JuelReciteme_1;
let JuelReciteme = JuelReciteme_1 = class JuelReciteme extends (0, _lit.LitElement) {
    constructor(){
        super();
        this.autoLoad = false;
        this.serviceUrl = "https://api.reciteme.com/asset/js?key=";
        this.options = {
            "autoEnable": 0,
            "Tracker": {
                "Ga": {
                    "enabled": true
                }
            },
            "Docreader": {
                "endpoint": "https://docreader.reciteme.com/doc/url?q="
            }
        };
    }
    render() {
        return (0, _lit.html)`<juel-button type="light" @button-clicked="${this.loadReciteServive}">
        <div slot="content" style="width: 32px; height: 32px;background-image: url(${0, _accessSvgDefault.default});""></div>
        </juel-button>`;
    }
    docReaderDownload() {
        var selector = "A.downloadlink[href*='docreader.reciteme.com']";
        var list = document.querySelectorAll(selector);
        for(var i = 0; i < list.length; i++){
            var href = list[i].getAttribute("href");
            if (href != "" && href != "undefined") {
                href = href.replace("https://docreader.reciteme.com/doc/url?q=", "");
                href = href.replace("http://docreader.reciteme.com/doc/url?q=", "");
                list[i].setAttribute("href", href);
            }
        }
    }
    loadReciteScript(src, callback) {
        console.log("Load script");
        let script = $(document.head.querySelector(`#${JuelReciteme_1.ReciteScriptID}`));
        console.log(!script || script.length <= 0);
        if (!script || script.length <= 0) {
            script = $(document.createElement("script"));
            $(document.head).append(script);
            script[0].id = JuelReciteme_1.ReciteScriptID;
            script[0].type = "text/javascript";
            script[0].onload = ()=>{
                console.log("script load");
                callback();
            };
            script[0].src = src;
        }
    }
    loadReciteServive(c) {
        this.loadReciteScript(this.serviceUrl + this.key, ()=>{
            "function" === typeof _reciteLoaded && _reciteLoaded();
            console.log("callback");
            "function" == typeof c && c();
            Recite.load(this.options);
            Recite.Event.subscribe("Recite:load", function() {
                console.log("Recite loaded");
                Recite.enable();
            });
        });
    }
};
JuelReciteme.ReciteScriptID = "juel-recite";
__decorate([
    (0, _decorators.property)()
], JuelReciteme.prototype, "key", void 0);
JuelReciteme = JuelReciteme_1 = __decorate([
    (0, _decorators.customElement)("juel-reciteme")
], JuelReciteme);

},{"lit":"l2dGb","lit/decorators":"04xNl","data-url:~/icons/access.svg":"1ovBn","@parcel/transformer-js/src/esmodule-helpers.js":"isk47"}],"1ovBn":[function(require,module,exports) {
module.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20d%3D%22M512%20256c0%20141.4-114.6%20256-256%20256S0%20397.4%200%20256S114.6%200%20256%200S512%20114.6%20512%20256zM161.5%20169.9c-12.2-5.2-26.3%20.4-31.5%2012.6s.4%2026.3%2012.6%2031.5l11.9%205.1c17.3%207.4%2035.2%2012.9%2053.6%2016.3v50.1c0%204.3-.7%208.6-2.1%2012.6l-28.7%2086.1c-4.2%2012.6%202.6%2026.2%2015.2%2030.4s26.2-2.6%2030.4-15.2l24.4-73.2c1.3-3.8%204.8-6.4%208.8-6.4s7.6%202.6%208.8%206.4l24.4%2073.2c4.2%2012.6%2017.8%2019.4%2030.4%2015.2s19.4-17.8%2015.2-30.4l-28.7-86.1c-1.4-4.1-2.1-8.3-2.1-12.6V235.5c18.4-3.5%2036.3-8.9%2053.6-16.3l11.9-5.1c12.2-5.2%2017.8-19.3%2012.6-31.5s-19.3-17.8-31.5-12.6L338.7%20175c-26.1%2011.2-54.2%2017-82.7%2017s-56.5-5.8-82.7-17l-11.9-5.1zM256%20160c22.1%200%2040-17.9%2040-40s-17.9-40-40-40s-40%2017.9-40%2040s17.9%2040%2040%2040z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";

},{}]},["5F6hf"], "5F6hf", "parcelRequire14b2")

