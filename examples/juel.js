function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire14b2"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire14b2"] = parcelRequire;
}
parcelRequire.register("kgJzb", function(module, exports) {

$parcel$export(module.exports, "default", () => $ec18a5cce38df2ef$export$2e2bcd8739ae039, (v) => $ec18a5cce38df2ef$export$2e2bcd8739ae039 = v);

var $9rF4q = parcelRequire("9rF4q");

var $iWfeL = parcelRequire("iWfeL");

var $7MFoH = parcelRequire("7MFoH");

var $1WRoq = parcelRequire("1WRoq");

var $hGM1Y = parcelRequire("hGM1Y");

var $cGkn6 = parcelRequire("cGkn6");

var $iAXdE = parcelRequire("iAXdE");

var $8P9Xs = parcelRequire("8P9Xs");

var $dPcav = parcelRequire("dPcav");

var $gPPRo = parcelRequire("gPPRo");

var $svDd8 = parcelRequire("svDd8");
(0, $iAXdE.default).use((0, $1WRoq.default));
(0, $iAXdE.default).use((0, $dPcav.default)); // pointerEvents
(0, $iAXdE.default).use((0, $gPPRo.default)); // inertia
(0, $iAXdE.default).use((0, $cGkn6.default)); // snap, resize, etc.
(0, $iAXdE.default).use((0, $8P9Xs.default)); // autoStart, hold
(0, $iAXdE.default).use((0, $7MFoH.default)); // drag and drop, resize, gesture
(0, $iAXdE.default).use((0, $9rF4q.default)); // autoScroll
(0, $iAXdE.default).use((0, $iWfeL.default)); // reflow
(0, $iAXdE.default).use((0, $svDd8.default)); // eslint-disable-next-line no-undef
(0, $iAXdE.default).use((0, $hGM1Y.default));
var $ec18a5cce38df2ef$export$2e2bcd8739ae039 = (0, $iAXdE.default);
if (!!module) try {
    module.exports = (0, $iAXdE.default);
} catch (_unused) {}
(0, $iAXdE.default).default = (0, $iAXdE.default);

});
parcelRequire.register("9rF4q", function(module, exports) {

$parcel$export(module.exports, "default", () => $6e067e67fb4a504e$export$2e2bcd8739ae039);

var $iBLLd = parcelRequire("iBLLd");

var $k04xU = parcelRequire("k04xU");

var $dz9GH = parcelRequire("dz9GH");

var $7Tceq = parcelRequire("7Tceq");
var $6e067e67fb4a504e$export$2e2bcd8739ae039 = {
    id: "actions",
    install (scope) {
        scope.usePlugin((0, $dz9GH.default));
        scope.usePlugin((0, $7Tceq.default));
        scope.usePlugin((0, $iBLLd.default));
        scope.usePlugin((0, $k04xU.default));
    }
};

});
parcelRequire.register("iBLLd", function(module, exports) {

$parcel$export(module.exports, "default", () => $d8c0baeb940b6c77$export$2e2bcd8739ae039);

var $4dw5o = parcelRequire("4dw5o");
function $d8c0baeb940b6c77$var$install(scope) {
    const { actions: actions , Interactable: Interactable , defaults: defaults  } = scope;
    Interactable.prototype.draggable = $d8c0baeb940b6c77$var$drag.draggable;
    actions.map.drag = $d8c0baeb940b6c77$var$drag;
    actions.methodDict.drag = "draggable";
    defaults.actions.drag = $d8c0baeb940b6c77$var$drag.defaults;
}
function $d8c0baeb940b6c77$var$beforeMove({ interaction: interaction  }) {
    if (interaction.prepared.name !== "drag") return;
    const axis = interaction.prepared.axis;
    if (axis === "x") {
        interaction.coords.cur.page.y = interaction.coords.start.page.y;
        interaction.coords.cur.client.y = interaction.coords.start.client.y;
        interaction.coords.velocity.client.y = 0;
        interaction.coords.velocity.page.y = 0;
    } else if (axis === "y") {
        interaction.coords.cur.page.x = interaction.coords.start.page.x;
        interaction.coords.cur.client.x = interaction.coords.start.client.x;
        interaction.coords.velocity.client.x = 0;
        interaction.coords.velocity.page.x = 0;
    }
}
function $d8c0baeb940b6c77$var$move({ iEvent: iEvent , interaction: interaction  }) {
    if (interaction.prepared.name !== "drag") return;
    const axis = interaction.prepared.axis;
    if (axis === "x" || axis === "y") {
        const opposite = axis === "x" ? "y" : "x";
        iEvent.page[opposite] = interaction.coords.start.page[opposite];
        iEvent.client[opposite] = interaction.coords.start.client[opposite];
        iEvent.delta[opposite] = 0;
    }
}
/**
 * ```js
 * interact(element).draggable({
 *     onstart: function (event) {},
 *     onmove : function (event) {},
 *     onend  : function (event) {},
 *
 *     // the axis in which the first movement must be
 *     // for the drag sequence to start
 *     // 'xy' by default - any direction
 *     startAxis: 'x' || 'y' || 'xy',
 *
 *     // 'xy' by default - don't restrict to one axis (move in any direction)
 *     // 'x' or 'y' to restrict movement to either axis
 *     // 'start' to restrict movement to the axis the drag started in
 *     lockAxis: 'x' || 'y' || 'xy' || 'start',
 *
 *     // max number of drags that can happen concurrently
 *     // with elements of this Interactable. Infinity by default
 *     max: Infinity,
 *
 *     // max number of drags that can target the same element+Interactable
 *     // 1 by default
 *     maxPerElement: 2
 * })
 *
 * var isDraggable = interact('element').draggable(); // true
 * ```
 *
 * Get or set whether drag actions can be performed on the target
 *
 * @alias Interactable.prototype.draggable
 *
 * @param {boolean | object} [options] true/false or An object with event
 * listeners to be fired on drag events (object makes the Interactable
 * draggable)
 * @return {boolean | Interactable} boolean indicating if this can be the
 * target of drag events, or this Interctable
 */ const $d8c0baeb940b6c77$var$draggable = function draggable(options) {
    if ((0, $4dw5o.default).object(options)) {
        this.options.drag.enabled = options.enabled !== false;
        this.setPerAction("drag", options);
        this.setOnEvents("drag", options);
        if (/^(xy|x|y|start)$/.test(options.lockAxis)) this.options.drag.lockAxis = options.lockAxis;
        if (/^(xy|x|y)$/.test(options.startAxis)) this.options.drag.startAxis = options.startAxis;
        return this;
    }
    if ((0, $4dw5o.default).bool(options)) {
        this.options.drag.enabled = options;
        return this;
    }
    return this.options.drag;
};
const $d8c0baeb940b6c77$var$drag = {
    id: "actions/drag",
    install: $d8c0baeb940b6c77$var$install,
    listeners: {
        "interactions:before-action-move": $d8c0baeb940b6c77$var$beforeMove,
        "interactions:action-resume": $d8c0baeb940b6c77$var$beforeMove,
        // dragmove
        "interactions:action-move": $d8c0baeb940b6c77$var$move,
        "auto-start:check": (arg)=>{
            const { interaction: interaction , interactable: interactable , buttons: buttons  } = arg;
            const dragOptions = interactable.options.drag;
            if (!(dragOptions && dragOptions.enabled) || interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options.drag.mouseButtons) === 0) return undefined;
            arg.action = {
                name: "drag",
                axis: dragOptions.lockAxis === "start" ? dragOptions.startAxis : dragOptions.lockAxis
            };
            return false;
        }
    },
    draggable: $d8c0baeb940b6c77$var$draggable,
    beforeMove: $d8c0baeb940b6c77$var$beforeMove,
    move: $d8c0baeb940b6c77$var$move,
    defaults: {
        startAxis: "xy",
        lockAxis: "xy"
    },
    getCursor () {
        return "move";
    }
};
var $d8c0baeb940b6c77$export$2e2bcd8739ae039 = $d8c0baeb940b6c77$var$drag;

});
parcelRequire.register("4dw5o", function(module, exports) {

$parcel$export(module.exports, "default", () => $312143ef9ed0eeca$export$2e2bcd8739ae039);

var $ii10E = parcelRequire("ii10E");

var $fhaz1 = parcelRequire("fhaz1");
const $312143ef9ed0eeca$var$window = (thing)=>thing === $fhaz1.window || (0, $ii10E.default)(thing);
const $312143ef9ed0eeca$var$docFrag = (thing)=>$312143ef9ed0eeca$var$object(thing) && thing.nodeType === 11;
const $312143ef9ed0eeca$var$object = (thing)=>!!thing && typeof thing === "object";
const $312143ef9ed0eeca$var$func = (thing)=>typeof thing === "function";
const $312143ef9ed0eeca$var$number = (thing)=>typeof thing === "number";
const $312143ef9ed0eeca$var$bool = (thing)=>typeof thing === "boolean";
const $312143ef9ed0eeca$var$string = (thing)=>typeof thing === "string";
const $312143ef9ed0eeca$var$element = (thing)=>{
    if (!thing || typeof thing !== "object") return false;
    const _window = $fhaz1.getWindow(thing) || $fhaz1.window;
    return /object|function/.test(typeof Element) ? thing instanceof Element || thing instanceof _window.Element : thing.nodeType === 1 && typeof thing.nodeName === "string";
};
const $312143ef9ed0eeca$var$plainObject = (thing)=>$312143ef9ed0eeca$var$object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());
const $312143ef9ed0eeca$var$array = (thing)=>$312143ef9ed0eeca$var$object(thing) && typeof thing.length !== "undefined" && $312143ef9ed0eeca$var$func(thing.splice);
var $312143ef9ed0eeca$export$2e2bcd8739ae039 = {
    window: $312143ef9ed0eeca$var$window,
    docFrag: $312143ef9ed0eeca$var$docFrag,
    object: $312143ef9ed0eeca$var$object,
    func: $312143ef9ed0eeca$var$func,
    number: $312143ef9ed0eeca$var$number,
    bool: $312143ef9ed0eeca$var$bool,
    string: $312143ef9ed0eeca$var$string,
    element: $312143ef9ed0eeca$var$element,
    plainObject: $312143ef9ed0eeca$var$plainObject,
    array: $312143ef9ed0eeca$var$array
};

});
parcelRequire.register("ii10E", function(module, exports) {

$parcel$export(module.exports, "default", () => $d50ab0e39300ae46$export$2e2bcd8739ae039);
var $d50ab0e39300ae46$export$2e2bcd8739ae039 = (thing)=>!!(thing && thing.Window) && thing instanceof thing.Window;

});

parcelRequire.register("fhaz1", function(module, exports) {

$parcel$export(module.exports, "realWindow", () => $b1f0a34af6cdc90d$export$c79472a81139de5e);
$parcel$export(module.exports, "window", () => $b1f0a34af6cdc90d$export$8291e5b88f90ce4);
$parcel$export(module.exports, "init", () => $b1f0a34af6cdc90d$export$2cd8252107eb640b);
$parcel$export(module.exports, "getWindow", () => $b1f0a34af6cdc90d$export$38b2d434cce3ea22);

var $ii10E = parcelRequire("ii10E");
let $b1f0a34af6cdc90d$export$c79472a81139de5e = undefined;
let $b1f0a34af6cdc90d$export$8291e5b88f90ce4 = undefined;
function $b1f0a34af6cdc90d$export$2cd8252107eb640b(window) {
    // get wrapped window if using Shadow DOM polyfill
    $b1f0a34af6cdc90d$export$c79472a81139de5e = window; // create a TextNode
    const el = window.document.createTextNode(""); // check if it's wrapped by a polyfill
    if (el.ownerDocument !== window.document && typeof window.wrap === "function" && window.wrap(el) === el) // use wrapped window
    window = window.wrap(window);
    $b1f0a34af6cdc90d$export$8291e5b88f90ce4 = window;
}
if (typeof window !== "undefined" && !!window) $b1f0a34af6cdc90d$export$2cd8252107eb640b(window);
function $b1f0a34af6cdc90d$export$38b2d434cce3ea22(node) {
    if ((0, $ii10E.default)(node)) return node;
    const rootNode = node.ownerDocument || node;
    return rootNode.defaultView || $b1f0a34af6cdc90d$export$8291e5b88f90ce4.window;
}

});



parcelRequire.register("k04xU", function(module, exports) {

$parcel$export(module.exports, "default", () => $e8f75574df1f6368$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $5bWyX = parcelRequire("5bWyX");

var $4dw5o = parcelRequire("4dw5o");

var $i7xl5 = parcelRequire("i7xl5");

var $hCEXH = parcelRequire("hCEXH");

var $iBLLd = parcelRequire("iBLLd");

var $JC3K7 = parcelRequire("JC3K7");
function $e8f75574df1f6368$var$install(scope) {
    const { actions: actions , /** @lends module:interact */ interactStatic: interact , Interactable: /** @lends Interactable */ Interactable , defaults: defaults  } = scope;
    scope.usePlugin((0, $iBLLd.default));
    /**
   *
   * ```js
   * interact('.drop').dropzone({
   *   accept: '.can-drop' || document.getElementById('single-drop'),
   *   overlap: 'pointer' || 'center' || zeroToOne
   * }
   * ```
   *
   * Returns or sets whether draggables can be dropped onto this target to
   * trigger drop events
   *
   * Dropzones can receive the following events:
   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends
   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone
   *  - `dragmove` when a draggable that has entered the dropzone is moved
   *  - `drop` when a draggable is dropped into this dropzone
   *
   * Use the `accept` option to allow only elements that match the given CSS
   * selector or element. The value can be:
   *
   *  - **an Element** - only that element can be dropped into this dropzone.
   *  - **a string**, - the element being dragged must match it as a CSS selector.
   *  - **`null`** - accept options is cleared - it accepts any element.
   *
   * Use the `overlap` option to set how drops are checked for. The allowed
   * values are:
   *
   *   - `'pointer'`, the pointer must be over the dropzone (default)
   *   - `'center'`, the draggable element's center must be over the dropzone
   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.
   *   e.g. `0.5` for drop to happen when half of the area of the draggable is
   *   over the dropzone
   *
   * Use the `checker` option to specify a function to check if a dragged element
   * is over this Interactable.
   *
   * @param {boolean | object | null} [options] The new options to be set.
   * @return {object | Interactable} The current setting or this Interactable
   */ Interactable.prototype.dropzone = function(options) {
        return $e8f75574df1f6368$var$dropzoneMethod(this, options);
    };
    /**
   * ```js
   * interact(target)
   * .dropChecker(function(dragEvent,         // related dragmove or dragend event
   *                       event,             // TouchEvent/PointerEvent/MouseEvent
   *                       dropped,           // bool result of the default checker
   *                       dropzone,          // dropzone Interactable
   *                       dropElement,       // dropzone elemnt
   *                       draggable,         // draggable Interactable
   *                       draggableElement) {// draggable element
   *
   *   return dropped && event.target.hasAttribute('allow-drop')
   * }
   * ```
   */ Interactable.prototype.dropCheck = function(dragEvent, event, draggable, draggableElement, dropElement, rect) {
        return $e8f75574df1f6368$var$dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect);
    };
    /**
   * Returns or sets whether the dimensions of dropzone elements are calculated
   * on every dragmove or only on dragstart for the default dropChecker
   *
   * @param {boolean} [newValue] True to check on each move. False to check only
   * before start
   * @return {boolean | interact} The current setting or interact
   */ interact.dynamicDrop = function(newValue) {
        if ((0, $4dw5o.default).bool(newValue)) {
            // if (dragging && scope.dynamicDrop !== newValue && !newValue) {
            //  calcRects(dropzones)
            // }
            scope.dynamicDrop = newValue;
            return interact;
        }
        return scope.dynamicDrop;
    };
    (0, $cT3g2.default)(actions.phaselessTypes, {
        dragenter: true,
        dragleave: true,
        dropactivate: true,
        dropdeactivate: true,
        dropmove: true,
        drop: true
    });
    actions.methodDict.drop = "dropzone";
    scope.dynamicDrop = false;
    defaults.actions.drop = $e8f75574df1f6368$var$drop.defaults;
}
function $e8f75574df1f6368$var$collectDrops({ interactables: interactables  }, draggableElement) {
    const drops = []; // collect all dropzones and their elements which qualify for a drop
    for (const dropzone of interactables.list){
        if (!dropzone.options.drop.enabled) continue;
        const accept = dropzone.options.drop.accept; // test the draggable draggableElement against the dropzone's accept setting
        if ((0, $4dw5o.default).element(accept) && accept !== draggableElement || (0, $4dw5o.default).string(accept) && !$jLvtZ.matchesSelector(draggableElement, accept) || (0, $4dw5o.default).func(accept) && !accept({
            dropzone: dropzone,
            draggableElement: draggableElement
        })) continue;
         // query for new elements if necessary
        const dropElements = (0, $4dw5o.default).string(dropzone.target) ? dropzone._context.querySelectorAll(dropzone.target) : (0, $4dw5o.default).array(dropzone.target) ? dropzone.target : [
            dropzone.target
        ];
        for (const dropzoneElement of dropElements)if (dropzoneElement !== draggableElement) drops.push({
            dropzone: dropzone,
            element: dropzoneElement,
            rect: dropzone.getRect(dropzoneElement)
        });
    }
    return drops;
}
function $e8f75574df1f6368$var$fireActivationEvents(activeDrops, event) {
    // loop through all active dropzones and trigger event
    for (const { dropzone: dropzone , element: element  } of activeDrops.slice()){
        event.dropzone = dropzone; // set current element as event target
        event.target = element;
        dropzone.fire(event);
        event.propagationStopped = event.immediatePropagationStopped = false;
    }
} // return a new array of possible drops. getActiveDrops should always be
// called when a drag has just started or a drag event happens while
// dynamicDrop is true
function $e8f75574df1f6368$var$getActiveDrops(scope, dragElement) {
    // get dropzones and their elements that could receive the draggable
    const activeDrops = $e8f75574df1f6368$var$collectDrops(scope, dragElement);
    for (const activeDrop of activeDrops)activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element);
    return activeDrops;
}
function $e8f75574df1f6368$var$getDrop({ dropState: dropState , interactable: draggable , element: dragElement  }, dragEvent, pointerEvent) {
    const validDrops = []; // collect all dropzones and their elements which qualify for a drop
    for (const { dropzone: dropzone , element: dropzoneElement , rect: rect  } of dropState.activeDrops)validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect) ? dropzoneElement : null);
     // get the most appropriate dropzone based on DOM depth and order
    const dropIndex = $jLvtZ.indexOfDeepestElement(validDrops);
    return dropState.activeDrops[dropIndex] || null;
}
function $e8f75574df1f6368$var$getDropEvents(interaction, _pointerEvent, dragEvent) {
    const { dropState: dropState  } = interaction;
    const dropEvents = {
        enter: null,
        leave: null,
        activate: null,
        deactivate: null,
        move: null,
        drop: null
    };
    if (dragEvent.type === "dragstart") {
        dropEvents.activate = new (0, $JC3K7.DropEvent)(dropState, dragEvent, "dropactivate");
        dropEvents.activate.target = null;
        dropEvents.activate.dropzone = null;
    }
    if (dragEvent.type === "dragend") {
        dropEvents.deactivate = new (0, $JC3K7.DropEvent)(dropState, dragEvent, "dropdeactivate");
        dropEvents.deactivate.target = null;
        dropEvents.deactivate.dropzone = null;
    }
    if (dropState.rejected) return dropEvents;
    if (dropState.cur.element !== dropState.prev.element) {
        // if there was a previous dropzone, create a dragleave event
        if (dropState.prev.dropzone) {
            dropEvents.leave = new (0, $JC3K7.DropEvent)(dropState, dragEvent, "dragleave");
            dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element;
            dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone;
        } // if dropzone is not null, create a dragenter event
        if (dropState.cur.dropzone) {
            dropEvents.enter = new (0, $JC3K7.DropEvent)(dropState, dragEvent, "dragenter");
            dragEvent.dragEnter = dropState.cur.element;
            dragEvent.dropzone = dropState.cur.dropzone;
        }
    }
    if (dragEvent.type === "dragend" && dropState.cur.dropzone) {
        dropEvents.drop = new (0, $JC3K7.DropEvent)(dropState, dragEvent, "drop");
        dragEvent.dropzone = dropState.cur.dropzone;
        dragEvent.relatedTarget = dropState.cur.element;
    }
    if (dragEvent.type === "dragmove" && dropState.cur.dropzone) {
        dropEvents.move = new (0, $JC3K7.DropEvent)(dropState, dragEvent, "dropmove");
        dropEvents.move.dragmove = dragEvent;
        dragEvent.dropzone = dropState.cur.dropzone;
    }
    return dropEvents;
}
function $e8f75574df1f6368$var$fireDropEvents(interaction, events) {
    const { dropState: dropState  } = interaction;
    const { activeDrops: activeDrops , cur: cur , prev: prev  } = dropState;
    if (events.leave) prev.dropzone.fire(events.leave);
    if (events.enter) cur.dropzone.fire(events.enter);
    if (events.move) cur.dropzone.fire(events.move);
    if (events.drop) cur.dropzone.fire(events.drop);
    if (events.deactivate) $e8f75574df1f6368$var$fireActivationEvents(activeDrops, events.deactivate);
    dropState.prev.dropzone = cur.dropzone;
    dropState.prev.element = cur.element;
}
function $e8f75574df1f6368$var$onEventCreated({ interaction: interaction , iEvent: iEvent , event: event  }, scope) {
    if (iEvent.type !== "dragmove" && iEvent.type !== "dragend") return;
    const { dropState: dropState  } = interaction;
    if (scope.dynamicDrop) dropState.activeDrops = $e8f75574df1f6368$var$getActiveDrops(scope, interaction.element);
    const dragEvent = iEvent;
    const dropResult = $e8f75574df1f6368$var$getDrop(interaction, dragEvent, event); // update rejected status
    dropState.rejected = dropState.rejected && !!dropResult && dropResult.dropzone === dropState.cur.dropzone && dropResult.element === dropState.cur.element;
    dropState.cur.dropzone = dropResult && dropResult.dropzone;
    dropState.cur.element = dropResult && dropResult.element;
    dropState.events = $e8f75574df1f6368$var$getDropEvents(interaction, event, dragEvent);
}
function $e8f75574df1f6368$var$dropzoneMethod(interactable, options) {
    if ((0, $4dw5o.default).object(options)) {
        interactable.options.drop.enabled = options.enabled !== false;
        if (options.listeners) {
            const normalized = (0, $i7xl5.default)(options.listeners); // rename 'drop' to '' as it will be prefixed with 'drop'
            const corrected = Object.keys(normalized).reduce((acc, type)=>{
                const correctedType = /^(enter|leave)/.test(type) ? `drag${type}` : /^(activate|deactivate|move)/.test(type) ? `drop${type}` : type;
                acc[correctedType] = normalized[type];
                return acc;
            }, {});
            interactable.off(interactable.options.drop.listeners);
            interactable.on(corrected);
            interactable.options.drop.listeners = corrected;
        }
        if ((0, $4dw5o.default).func(options.ondrop)) interactable.on("drop", options.ondrop);
        if ((0, $4dw5o.default).func(options.ondropactivate)) interactable.on("dropactivate", options.ondropactivate);
        if ((0, $4dw5o.default).func(options.ondropdeactivate)) interactable.on("dropdeactivate", options.ondropdeactivate);
        if ((0, $4dw5o.default).func(options.ondragenter)) interactable.on("dragenter", options.ondragenter);
        if ((0, $4dw5o.default).func(options.ondragleave)) interactable.on("dragleave", options.ondragleave);
        if ((0, $4dw5o.default).func(options.ondropmove)) interactable.on("dropmove", options.ondropmove);
        if (/^(pointer|center)$/.test(options.overlap)) interactable.options.drop.overlap = options.overlap;
        else if ((0, $4dw5o.default).number(options.overlap)) interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);
        if ("accept" in options) interactable.options.drop.accept = options.accept;
        if ("checker" in options) interactable.options.drop.checker = options.checker;
        return interactable;
    }
    if ((0, $4dw5o.default).bool(options)) {
        interactable.options.drop.enabled = options;
        return interactable;
    }
    return interactable.options.drop;
}
function $e8f75574df1f6368$var$dropCheckMethod(interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {
    let dropped = false; // if the dropzone has no rect (eg. display: none)
    // call the custom dropChecker or just return false
    if (!(rect = rect || interactable.getRect(dropElement))) return interactable.options.drop.checker ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement) : false;
    const dropOverlap = interactable.options.drop.overlap;
    if (dropOverlap === "pointer") {
        const origin = (0, $5bWyX.default)(draggable, draggableElement, "drag");
        const page = $hCEXH.getPageXY(dragEvent);
        page.x += origin.x;
        page.y += origin.y;
        const horizontal = page.x > rect.left && page.x < rect.right;
        const vertical = page.y > rect.top && page.y < rect.bottom;
        dropped = horizontal && vertical;
    }
    const dragRect = draggable.getRect(draggableElement);
    if (dragRect && dropOverlap === "center") {
        const cx = dragRect.left + dragRect.width / 2;
        const cy = dragRect.top + dragRect.height / 2;
        dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;
    }
    if (dragRect && (0, $4dw5o.default).number(dropOverlap)) {
        const overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));
        const overlapRatio = overlapArea / (dragRect.width * dragRect.height);
        dropped = overlapRatio >= dropOverlap;
    }
    if (interactable.options.drop.checker) dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement);
    return dropped;
}
const $e8f75574df1f6368$var$drop = {
    id: "actions/drop",
    install: $e8f75574df1f6368$var$install,
    listeners: {
        "interactions:before-action-start": ({ interaction: interaction  })=>{
            if (interaction.prepared.name !== "drag") return;
            interaction.dropState = {
                cur: {
                    dropzone: null,
                    element: null
                },
                prev: {
                    dropzone: null,
                    element: null
                },
                rejected: null,
                events: null,
                activeDrops: []
            };
        },
        "interactions:after-action-start": ({ interaction: interaction , event: event , iEvent: dragEvent  }, scope)=>{
            if (interaction.prepared.name !== "drag") return;
            const { dropState: dropState  } = interaction; // reset active dropzones
            dropState.activeDrops = null;
            dropState.events = null;
            dropState.activeDrops = $e8f75574df1f6368$var$getActiveDrops(scope, interaction.element);
            dropState.events = $e8f75574df1f6368$var$getDropEvents(interaction, event, dragEvent);
            if (dropState.events.activate) {
                $e8f75574df1f6368$var$fireActivationEvents(dropState.activeDrops, dropState.events.activate);
                scope.fire("actions/drop:start", {
                    interaction: interaction,
                    dragEvent: dragEvent
                });
            }
        },
        "interactions:action-move": $e8f75574df1f6368$var$onEventCreated,
        "interactions:after-action-move": ({ interaction: interaction , iEvent: dragEvent  }, scope)=>{
            if (interaction.prepared.name !== "drag") return;
            $e8f75574df1f6368$var$fireDropEvents(interaction, interaction.dropState.events);
            scope.fire("actions/drop:move", {
                interaction: interaction,
                dragEvent: dragEvent
            });
            interaction.dropState.events = {};
        },
        "interactions:action-end": (arg, scope)=>{
            if (arg.interaction.prepared.name !== "drag") return;
            const { interaction: interaction , iEvent: dragEvent  } = arg;
            $e8f75574df1f6368$var$onEventCreated(arg, scope);
            $e8f75574df1f6368$var$fireDropEvents(interaction, interaction.dropState.events);
            scope.fire("actions/drop:end", {
                interaction: interaction,
                dragEvent: dragEvent
            });
        },
        "interactions:stop": ({ interaction: interaction  })=>{
            if (interaction.prepared.name !== "drag") return;
            const { dropState: dropState  } = interaction;
            if (dropState) {
                dropState.activeDrops = null;
                dropState.events = null;
                dropState.cur.dropzone = null;
                dropState.cur.element = null;
                dropState.prev.dropzone = null;
                dropState.prev.element = null;
                dropState.rejected = false;
            }
        }
    },
    getActiveDrops: $e8f75574df1f6368$var$getActiveDrops,
    getDrop: $e8f75574df1f6368$var$getDrop,
    getDropEvents: $e8f75574df1f6368$var$getDropEvents,
    fireDropEvents: $e8f75574df1f6368$var$fireDropEvents,
    defaults: {
        enabled: false,
        accept: null,
        overlap: "pointer"
    }
};
var $e8f75574df1f6368$export$2e2bcd8739ae039 = $e8f75574df1f6368$var$drop;

});
parcelRequire.register("jLvtZ", function(module, exports) {

$parcel$export(module.exports, "nodeContains", () => $e63ad3e8cc1b7b83$export$4282f70798064fe0);
$parcel$export(module.exports, "closest", () => $e63ad3e8cc1b7b83$export$ff7f7c97cdce86e);
$parcel$export(module.exports, "matchesSelector", () => $e63ad3e8cc1b7b83$export$b06a2f5618961e1e);
$parcel$export(module.exports, "parentNode", () => $e63ad3e8cc1b7b83$export$b54be7ce267a037b);
$parcel$export(module.exports, "indexOfDeepestElement", () => $e63ad3e8cc1b7b83$export$9910d92212f1e85f);
$parcel$export(module.exports, "matchesUpTo", () => $e63ad3e8cc1b7b83$export$6e9a952c9206c895);
$parcel$export(module.exports, "getActualElement", () => $e63ad3e8cc1b7b83$export$aec6ba5d38648c09);
$parcel$export(module.exports, "getElementClientRect", () => $e63ad3e8cc1b7b83$export$b19d4a0be02b3a75);
$parcel$export(module.exports, "getElementRect", () => $e63ad3e8cc1b7b83$export$8746289dcd524249);
$parcel$export(module.exports, "getPath", () => $e63ad3e8cc1b7b83$export$2aa3fd96c49a84a8);
$parcel$export(module.exports, "trySelector", () => $e63ad3e8cc1b7b83$export$69d4261eb51b867c);

var $fIr2Q = parcelRequire("fIr2Q");

var $3Ilbz = parcelRequire("3Ilbz");

var $4dw5o = parcelRequire("4dw5o");

var $fhaz1 = parcelRequire("fhaz1");
function $e63ad3e8cc1b7b83$export$4282f70798064fe0(parent, child) {
    if (parent.contains) return parent.contains(child);
    while(child){
        if (child === parent) return true;
        child = child.parentNode;
    }
    return false;
}
function $e63ad3e8cc1b7b83$export$ff7f7c97cdce86e(element, selector) {
    while((0, $4dw5o.default).element(element)){
        if ($e63ad3e8cc1b7b83$export$b06a2f5618961e1e(element, selector)) return element;
        element = $e63ad3e8cc1b7b83$export$b54be7ce267a037b(element);
    }
    return null;
}
function $e63ad3e8cc1b7b83$export$b54be7ce267a037b(node) {
    let parent = node.parentNode;
    if ((0, $4dw5o.default).docFrag(parent)) {
        // skip past #shado-root fragments
        // tslint:disable-next-line
        while((parent = parent.host) && (0, $4dw5o.default).docFrag(parent))continue;
        return parent;
    }
    return parent;
}
function $e63ad3e8cc1b7b83$export$b06a2f5618961e1e(element, selector) {
    // remove /deep/ from selectors if shadowDOM polyfill is used
    if ($fhaz1.window !== $fhaz1.realWindow) selector = selector.replace(/\/deep\//g, " ");
    return element[(0, $fIr2Q.default).prefixedMatchesSelector](selector);
}
const $e63ad3e8cc1b7b83$var$getParent = (el)=>el.parentNode || el.host; // Test for the element that's "above" all other qualifiers
function $e63ad3e8cc1b7b83$export$9910d92212f1e85f(elements) {
    let deepestNodeParents = [];
    let deepestNodeIndex;
    for(let i = 0; i < elements.length; i++){
        const currentNode = elements[i];
        const deepestNode = elements[deepestNodeIndex]; // node may appear in elements array multiple times
        if (!currentNode || i === deepestNodeIndex) continue;
        if (!deepestNode) {
            deepestNodeIndex = i;
            continue;
        }
        const currentNodeParent = $e63ad3e8cc1b7b83$var$getParent(currentNode);
        const deepestNodeParent = $e63ad3e8cc1b7b83$var$getParent(deepestNode); // check if the deepest or current are document.documentElement/rootElement
        // - if the current node is, do nothing and continue
        if (currentNodeParent === currentNode.ownerDocument) continue;
        else if (deepestNodeParent === currentNode.ownerDocument) {
            deepestNodeIndex = i;
            continue;
        } // compare zIndex of siblings
        if (currentNodeParent === deepestNodeParent) {
            if ($e63ad3e8cc1b7b83$var$zIndexIsHigherThan(currentNode, deepestNode)) deepestNodeIndex = i;
            continue;
        } // populate the ancestry array for the latest deepest node
        deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : $e63ad3e8cc1b7b83$var$getNodeParents(deepestNode);
        let ancestryStart; // if the deepest node is an HTMLElement and the current node is a non root svg element
        if (deepestNode instanceof (0, $3Ilbz.default).HTMLElement && currentNode instanceof (0, $3Ilbz.default).SVGElement && !(currentNode instanceof (0, $3Ilbz.default).SVGSVGElement)) {
            // TODO: is this check necessary? Was this for HTML elements embedded in SVG?
            if (currentNode === deepestNodeParent) continue;
            ancestryStart = currentNode.ownerSVGElement;
        } else ancestryStart = currentNode;
        const currentNodeParents = $e63ad3e8cc1b7b83$var$getNodeParents(ancestryStart, deepestNode.ownerDocument);
        let commonIndex = 0; // get (position of closest common ancestor) + 1
        while(currentNodeParents[commonIndex] && currentNodeParents[commonIndex] === deepestNodeParents[commonIndex])commonIndex++;
        const parents = [
            currentNodeParents[commonIndex - 1],
            currentNodeParents[commonIndex],
            deepestNodeParents[commonIndex]
        ];
        if (parents[0]) {
            let child = parents[0].lastChild;
            while(child){
                if (child === parents[1]) {
                    deepestNodeIndex = i;
                    deepestNodeParents = currentNodeParents;
                    break;
                } else if (child === parents[2]) break;
                child = child.previousSibling;
            }
        }
    }
    return deepestNodeIndex;
}
function $e63ad3e8cc1b7b83$var$getNodeParents(node, limit) {
    const parents = [];
    let parent = node;
    let parentParent;
    while((parentParent = $e63ad3e8cc1b7b83$var$getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument){
        parents.unshift(parent);
        parent = parentParent;
    }
    return parents;
}
function $e63ad3e8cc1b7b83$var$zIndexIsHigherThan(higherNode, lowerNode) {
    const higherIndex = parseInt($fhaz1.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0;
    const lowerIndex = parseInt($fhaz1.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0;
    return higherIndex >= lowerIndex;
}
function $e63ad3e8cc1b7b83$export$6e9a952c9206c895(element, selector, limit) {
    while((0, $4dw5o.default).element(element)){
        if ($e63ad3e8cc1b7b83$export$b06a2f5618961e1e(element, selector)) return true;
        element = $e63ad3e8cc1b7b83$export$b54be7ce267a037b(element);
        if (element === limit) return $e63ad3e8cc1b7b83$export$b06a2f5618961e1e(element, selector);
    }
    return false;
}
function $e63ad3e8cc1b7b83$export$aec6ba5d38648c09(element) {
    return element.correspondingUseElement || element;
}
function $e63ad3e8cc1b7b83$export$a3082288c08c850c(relevantWindow) {
    relevantWindow = relevantWindow || $fhaz1.window;
    return {
        x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
        y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
    };
}
function $e63ad3e8cc1b7b83$export$b19d4a0be02b3a75(element) {
    const clientRect = element instanceof (0, $3Ilbz.default).SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];
    return clientRect && {
        left: clientRect.left,
        right: clientRect.right,
        top: clientRect.top,
        bottom: clientRect.bottom,
        width: clientRect.width || clientRect.right - clientRect.left,
        height: clientRect.height || clientRect.bottom - clientRect.top
    };
}
function $e63ad3e8cc1b7b83$export$8746289dcd524249(element) {
    const clientRect = $e63ad3e8cc1b7b83$export$b19d4a0be02b3a75(element);
    if (!(0, $fIr2Q.default).isIOS7 && clientRect) {
        const scroll = $e63ad3e8cc1b7b83$export$a3082288c08c850c($fhaz1.getWindow(element));
        clientRect.left += scroll.x;
        clientRect.right += scroll.x;
        clientRect.top += scroll.y;
        clientRect.bottom += scroll.y;
    }
    return clientRect;
}
function $e63ad3e8cc1b7b83$export$2aa3fd96c49a84a8(node) {
    const path = [];
    while(node){
        path.push(node);
        node = $e63ad3e8cc1b7b83$export$b54be7ce267a037b(node);
    }
    return path;
}
function $e63ad3e8cc1b7b83$export$69d4261eb51b867c(value) {
    if (!(0, $4dw5o.default).string(value)) return false;
     // an exception will be raised if it is invalid
    (0, $3Ilbz.default).document.querySelector(value);
    return true;
}

});
parcelRequire.register("fIr2Q", function(module, exports) {

$parcel$export(module.exports, "default", () => $b70ff1a094a470da$export$2e2bcd8739ae039);

var $3Ilbz = parcelRequire("3Ilbz");

var $4dw5o = parcelRequire("4dw5o");
const $b70ff1a094a470da$var$browser = {
    init: $b70ff1a094a470da$var$init,
    supportsTouch: null,
    supportsPointerEvent: null,
    isIOS7: null,
    isIOS: null,
    isIe9: null,
    isOperaMobile: null,
    prefixedMatchesSelector: null,
    pEventTypes: null,
    wheelEvent: null
};
function $b70ff1a094a470da$var$init(window) {
    const Element = (0, $3Ilbz.default).Element;
    const navigator = window.navigator || {}; // Does the browser support touch input?
    $b70ff1a094a470da$var$browser.supportsTouch = "ontouchstart" in window || (0, $4dw5o.default).func(window.DocumentTouch) && (0, $3Ilbz.default).document instanceof window.DocumentTouch; // Does the browser support PointerEvents
    // https://github.com/taye/interact.js/issues/703#issuecomment-471570492
    $b70ff1a094a470da$var$browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!(0, $3Ilbz.default).PointerEvent;
    $b70ff1a094a470da$var$browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform); // scrolling doesn't change the result of getClientRects on iOS 7
    $b70ff1a094a470da$var$browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\d]/.test(navigator.appVersion);
    $b70ff1a094a470da$var$browser.isIe9 = /MSIE 9/.test(navigator.userAgent); // Opera Mobile must be handled differently
    $b70ff1a094a470da$var$browser.isOperaMobile = navigator.appName === "Opera" && $b70ff1a094a470da$var$browser.supportsTouch && /Presto/.test(navigator.userAgent); // prefix matchesSelector
    $b70ff1a094a470da$var$browser.prefixedMatchesSelector = "matches" in Element.prototype ? "matches" : "webkitMatchesSelector" in Element.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in Element.prototype ? "mozMatchesSelector" : "oMatchesSelector" in Element.prototype ? "oMatchesSelector" : "msMatchesSelector";
    $b70ff1a094a470da$var$browser.pEventTypes = $b70ff1a094a470da$var$browser.supportsPointerEvent ? (0, $3Ilbz.default).PointerEvent === window.MSPointerEvent ? {
        up: "MSPointerUp",
        down: "MSPointerDown",
        over: "mouseover",
        out: "mouseout",
        move: "MSPointerMove",
        cancel: "MSPointerCancel"
    } : {
        up: "pointerup",
        down: "pointerdown",
        over: "pointerover",
        out: "pointerout",
        move: "pointermove",
        cancel: "pointercancel"
    } : null; // because Webkit and Opera still use 'mousewheel' event type
    $b70ff1a094a470da$var$browser.wheelEvent = (0, $3Ilbz.default).document && "onmousewheel" in (0, $3Ilbz.default).document ? "mousewheel" : "wheel";
}
var $b70ff1a094a470da$export$2e2bcd8739ae039 = $b70ff1a094a470da$var$browser;

});
parcelRequire.register("3Ilbz", function(module, exports) {

$parcel$export(module.exports, "default", () => $2b45ea330dbfb355$export$2e2bcd8739ae039);
const $2b45ea330dbfb355$var$domObjects = {
    init: $2b45ea330dbfb355$var$init,
    document: null,
    DocumentFragment: null,
    SVGElement: null,
    SVGSVGElement: null,
    SVGElementInstance: null,
    Element: null,
    HTMLElement: null,
    Event: null,
    Touch: null,
    PointerEvent: null
};
function $2b45ea330dbfb355$var$blank() {}
var $2b45ea330dbfb355$export$2e2bcd8739ae039 = $2b45ea330dbfb355$var$domObjects;
function $2b45ea330dbfb355$var$init(window) {
    const win = window;
    $2b45ea330dbfb355$var$domObjects.document = win.document;
    $2b45ea330dbfb355$var$domObjects.DocumentFragment = win.DocumentFragment || $2b45ea330dbfb355$var$blank;
    $2b45ea330dbfb355$var$domObjects.SVGElement = win.SVGElement || $2b45ea330dbfb355$var$blank;
    $2b45ea330dbfb355$var$domObjects.SVGSVGElement = win.SVGSVGElement || $2b45ea330dbfb355$var$blank;
    $2b45ea330dbfb355$var$domObjects.SVGElementInstance = win.SVGElementInstance || $2b45ea330dbfb355$var$blank;
    $2b45ea330dbfb355$var$domObjects.Element = win.Element || $2b45ea330dbfb355$var$blank;
    $2b45ea330dbfb355$var$domObjects.HTMLElement = win.HTMLElement || $2b45ea330dbfb355$var$domObjects.Element;
    $2b45ea330dbfb355$var$domObjects.Event = win.Event;
    $2b45ea330dbfb355$var$domObjects.Touch = win.Touch || $2b45ea330dbfb355$var$blank;
    $2b45ea330dbfb355$var$domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;
}

});



parcelRequire.register("cT3g2", function(module, exports) {

$parcel$export(module.exports, "default", () => $961d25fe0f02f08e$export$2e2bcd8739ae039);
function $961d25fe0f02f08e$export$2e2bcd8739ae039(dest, source) {
    for(const prop in source)dest[prop] = source[prop];
    const ret = dest;
    return ret;
}

});

parcelRequire.register("5bWyX", function(module, exports) {

$parcel$export(module.exports, "default", () => $3c7b682ba5760375$export$2e2bcd8739ae039);

var $5ZvQW = parcelRequire("5ZvQW");
function $3c7b682ba5760375$export$2e2bcd8739ae039(target, element, actionName) {
    const actionOptions = target.options[actionName];
    const actionOrigin = actionOptions && actionOptions.origin;
    const origin = actionOrigin || target.options.origin;
    const originRect = (0, $5ZvQW.resolveRectLike)(origin, target, element, [
        target && element
    ]);
    return (0, $5ZvQW.rectToXY)(originRect) || {
        x: 0,
        y: 0
    };
}

});
parcelRequire.register("5ZvQW", function(module, exports) {

$parcel$export(module.exports, "getStringOptionResult", () => $45cb5b907854351c$export$6a5ee63d73279d01);
$parcel$export(module.exports, "resolveRectLike", () => $45cb5b907854351c$export$d5c408bf15db2627);
$parcel$export(module.exports, "rectToXY", () => $45cb5b907854351c$export$10b8b6e8034137e5);
$parcel$export(module.exports, "xywhToTlbr", () => $45cb5b907854351c$export$c212b85b6a8fedeb);
$parcel$export(module.exports, "tlbrToXywh", () => $45cb5b907854351c$export$2de5d6992c8b19fa);
$parcel$export(module.exports, "addEdges", () => $45cb5b907854351c$export$f6077e672902b574);

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");
function $45cb5b907854351c$export$6a5ee63d73279d01(value, target, element) {
    if (value === "parent") return (0, $jLvtZ.parentNode)(element);
    if (value === "self") return target.getRect(element);
    return (0, $jLvtZ.closest)(element, value);
}
function $45cb5b907854351c$export$d5c408bf15db2627(value, target, element, functionArgs) {
    let returnValue = value;
    if ((0, $4dw5o.default).string(returnValue)) returnValue = $45cb5b907854351c$export$6a5ee63d73279d01(returnValue, target, element);
    else if ((0, $4dw5o.default).func(returnValue)) returnValue = returnValue(...functionArgs);
    if ((0, $4dw5o.default).element(returnValue)) returnValue = (0, $jLvtZ.getElementRect)(returnValue);
    return returnValue;
}
function $45cb5b907854351c$export$10b8b6e8034137e5(rect) {
    return rect && {
        x: "x" in rect ? rect.x : rect.left,
        y: "y" in rect ? rect.y : rect.top
    };
}
function $45cb5b907854351c$export$c212b85b6a8fedeb(rect) {
    if (rect && !("left" in rect && "top" in rect)) {
        rect = (0, $cT3g2.default)({}, rect);
        rect.left = rect.x || 0;
        rect.top = rect.y || 0;
        rect.right = rect.right || rect.left + rect.width;
        rect.bottom = rect.bottom || rect.top + rect.height;
    }
    return rect;
}
function $45cb5b907854351c$export$2de5d6992c8b19fa(rect) {
    if (rect && !("x" in rect && "y" in rect)) {
        rect = (0, $cT3g2.default)({}, rect);
        rect.x = rect.left || 0;
        rect.y = rect.top || 0;
        rect.width = rect.width || (rect.right || 0) - rect.x;
        rect.height = rect.height || (rect.bottom || 0) - rect.y;
    }
    return rect;
}
function $45cb5b907854351c$export$f6077e672902b574(edges, rect, delta) {
    if (edges.left) rect.left += delta.x;
    if (edges.right) rect.right += delta.x;
    if (edges.top) rect.top += delta.y;
    if (edges.bottom) rect.bottom += delta.y;
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
}

});


parcelRequire.register("i7xl5", function(module, exports) {

$parcel$export(module.exports, "default", () => $036787311787b37d$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");
function $036787311787b37d$export$2e2bcd8739ae039(type, listeners, result) {
    result = result || {};
    if ((0, $4dw5o.default).string(type) && type.search(" ") !== -1) type = $036787311787b37d$var$split(type);
    if ((0, $4dw5o.default).array(type)) return type.reduce((acc, t)=>(0, $cT3g2.default)(acc, $036787311787b37d$export$2e2bcd8739ae039(t, listeners, result)), result);
     // ({ type: fn }) -> ('', { type: fn })
    if ((0, $4dw5o.default).object(type)) {
        listeners = type;
        type = "";
    }
    if ((0, $4dw5o.default).func(listeners)) {
        result[type] = result[type] || [];
        result[type].push(listeners);
    } else if ((0, $4dw5o.default).array(listeners)) for (const l of listeners)$036787311787b37d$export$2e2bcd8739ae039(type, l, result);
    else if ((0, $4dw5o.default).object(listeners)) for(const prefix in listeners){
        const combinedTypes = $036787311787b37d$var$split(prefix).map((p)=>`${type}${p}`);
        $036787311787b37d$export$2e2bcd8739ae039(combinedTypes, listeners[prefix], result);
    }
    return result;
}
function $036787311787b37d$var$split(type) {
    return type.trim().split(/ +/);
}

});

parcelRequire.register("hCEXH", function(module, exports) {

$parcel$export(module.exports, "copyCoords", () => $cd45c26edda937b2$export$c4ca8776590e9a17);
$parcel$export(module.exports, "setCoordDeltas", () => $cd45c26edda937b2$export$77e6b1bc3a58f58f);
$parcel$export(module.exports, "setCoordVelocity", () => $cd45c26edda937b2$export$56387ecdbf594421);
$parcel$export(module.exports, "setZeroCoords", () => $cd45c26edda937b2$export$f8a6ebd01c8c99d9);
$parcel$export(module.exports, "getPageXY", () => $cd45c26edda937b2$export$dbd0143e191dc2e5);
$parcel$export(module.exports, "getPointerId", () => $cd45c26edda937b2$export$a845ff6c553b3014);
$parcel$export(module.exports, "setCoords", () => $cd45c26edda937b2$export$d03eafa2070fb6d7);
$parcel$export(module.exports, "pointerAverage", () => $cd45c26edda937b2$export$d217330ee963ee25);
$parcel$export(module.exports, "touchBBox", () => $cd45c26edda937b2$export$9f1ac7d38a46fb85);
$parcel$export(module.exports, "touchDistance", () => $cd45c26edda937b2$export$8654765437db7712);
$parcel$export(module.exports, "touchAngle", () => $cd45c26edda937b2$export$98c8e15a2ace5476);
$parcel$export(module.exports, "getPointerType", () => $cd45c26edda937b2$export$887a228355cf7d95);
$parcel$export(module.exports, "getEventTargets", () => $cd45c26edda937b2$export$fbb25f7a0ef5cd4b);
$parcel$export(module.exports, "newCoords", () => $cd45c26edda937b2$export$b12cd1669c59c59a);
$parcel$export(module.exports, "coordsToEvent", () => $cd45c26edda937b2$export$798f030fada725d2);
$parcel$export(module.exports, "pointerExtend", () => (parcelRequire("aLC5p")).default);

var $fIr2Q = parcelRequire("fIr2Q");

var $3Ilbz = parcelRequire("3Ilbz");

var $jLvtZ = parcelRequire("jLvtZ");

var $djSxD = parcelRequire("djSxD");

var $4dw5o = parcelRequire("4dw5o");

var $aLC5p = parcelRequire("aLC5p");
function $cd45c26edda937b2$export$c4ca8776590e9a17(dest, src) {
    dest.page = dest.page || {};
    dest.page.x = src.page.x;
    dest.page.y = src.page.y;
    dest.client = dest.client || {};
    dest.client.x = src.client.x;
    dest.client.y = src.client.y;
    dest.timeStamp = src.timeStamp;
}
function $cd45c26edda937b2$export$77e6b1bc3a58f58f(targetObj, prev, cur) {
    targetObj.page.x = cur.page.x - prev.page.x;
    targetObj.page.y = cur.page.y - prev.page.y;
    targetObj.client.x = cur.client.x - prev.client.x;
    targetObj.client.y = cur.client.y - prev.client.y;
    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
}
function $cd45c26edda937b2$export$56387ecdbf594421(targetObj, delta) {
    const dt = Math.max(delta.timeStamp / 1000, 0.001);
    targetObj.page.x = delta.page.x / dt;
    targetObj.page.y = delta.page.y / dt;
    targetObj.client.x = delta.client.x / dt;
    targetObj.client.y = delta.client.y / dt;
    targetObj.timeStamp = dt;
}
function $cd45c26edda937b2$export$f8a6ebd01c8c99d9(targetObj) {
    targetObj.page.x = 0;
    targetObj.page.y = 0;
    targetObj.client.x = 0;
    targetObj.client.y = 0;
}
function $cd45c26edda937b2$export$ca7cafa8dbed7d1d(pointer) {
    return pointer instanceof (0, $3Ilbz.default).Event || pointer instanceof (0, $3Ilbz.default).Touch;
} // Get specified X/Y coords for mouse or event.touches[0]
function $cd45c26edda937b2$export$884ea7d009edc3a2(type, pointer, xy) {
    xy = xy || {};
    type = type || "page";
    xy.x = pointer[type + "X"];
    xy.y = pointer[type + "Y"];
    return xy;
}
function $cd45c26edda937b2$export$dbd0143e191dc2e5(pointer, page) {
    page = page || {
        x: 0,
        y: 0
    }; // Opera Mobile handles the viewport and scrolling oddly
    if ((0, $fIr2Q.default).isOperaMobile && $cd45c26edda937b2$export$ca7cafa8dbed7d1d(pointer)) {
        $cd45c26edda937b2$export$884ea7d009edc3a2("screen", pointer, page);
        page.x += window.scrollX;
        page.y += window.scrollY;
    } else $cd45c26edda937b2$export$884ea7d009edc3a2("page", pointer, page);
    return page;
}
function $cd45c26edda937b2$export$1115a942b8cb48e1(pointer, client) {
    client = client || {};
    if ((0, $fIr2Q.default).isOperaMobile && $cd45c26edda937b2$export$ca7cafa8dbed7d1d(pointer)) // Opera Mobile handles the viewport and scrolling oddly
    $cd45c26edda937b2$export$884ea7d009edc3a2("screen", pointer, client);
    else $cd45c26edda937b2$export$884ea7d009edc3a2("client", pointer, client);
    return client;
}
function $cd45c26edda937b2$export$a845ff6c553b3014(pointer) {
    return (0, $4dw5o.default).number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
}
function $cd45c26edda937b2$export$d03eafa2070fb6d7(dest, pointers, timeStamp) {
    const pointer = pointers.length > 1 ? $cd45c26edda937b2$export$d217330ee963ee25(pointers) : pointers[0];
    $cd45c26edda937b2$export$dbd0143e191dc2e5(pointer, dest.page);
    $cd45c26edda937b2$export$1115a942b8cb48e1(pointer, dest.client);
    dest.timeStamp = timeStamp;
}
function $cd45c26edda937b2$export$c6af5711bcbd4cf0(event) {
    const touches = []; // array of touches is supplied
    if ((0, $4dw5o.default).array(event)) {
        touches[0] = event[0];
        touches[1] = event[1];
    } else if (event.type === "touchend") {
        if (event.touches.length === 1) {
            touches[0] = event.touches[0];
            touches[1] = event.changedTouches[0];
        } else if (event.touches.length === 0) {
            touches[0] = event.changedTouches[0];
            touches[1] = event.changedTouches[1];
        }
    } else {
        touches[0] = event.touches[0];
        touches[1] = event.touches[1];
    }
    return touches;
}
function $cd45c26edda937b2$export$d217330ee963ee25(pointers) {
    const average = {
        pageX: 0,
        pageY: 0,
        clientX: 0,
        clientY: 0,
        screenX: 0,
        screenY: 0
    };
    for (const pointer of pointers)for(const prop in average)average[prop] += pointer[prop];
    for(const prop1 in average)average[prop1] /= pointers.length;
    return average;
}
function $cd45c26edda937b2$export$9f1ac7d38a46fb85(event) {
    if (!event.length) return null;
    const touches = $cd45c26edda937b2$export$c6af5711bcbd4cf0(event);
    const minX = Math.min(touches[0].pageX, touches[1].pageX);
    const minY = Math.min(touches[0].pageY, touches[1].pageY);
    const maxX = Math.max(touches[0].pageX, touches[1].pageX);
    const maxY = Math.max(touches[0].pageY, touches[1].pageY);
    return {
        x: minX,
        y: minY,
        left: minX,
        top: minY,
        right: maxX,
        bottom: maxY,
        width: maxX - minX,
        height: maxY - minY
    };
}
function $cd45c26edda937b2$export$8654765437db7712(event, deltaSource) {
    const sourceX = deltaSource + "X";
    const sourceY = deltaSource + "Y";
    const touches = $cd45c26edda937b2$export$c6af5711bcbd4cf0(event);
    const dx = touches[0][sourceX] - touches[1][sourceX];
    const dy = touches[0][sourceY] - touches[1][sourceY];
    return (0, $djSxD.default)(dx, dy);
}
function $cd45c26edda937b2$export$98c8e15a2ace5476(event, deltaSource) {
    const sourceX = deltaSource + "X";
    const sourceY = deltaSource + "Y";
    const touches = $cd45c26edda937b2$export$c6af5711bcbd4cf0(event);
    const dx = touches[1][sourceX] - touches[0][sourceX];
    const dy = touches[1][sourceY] - touches[0][sourceY];
    const angle = 180 * Math.atan2(dy, dx) / Math.PI;
    return angle;
}
function $cd45c26edda937b2$export$887a228355cf7d95(pointer) {
    return (0, $4dw5o.default).string(pointer.pointerType) ? pointer.pointerType : (0, $4dw5o.default).number(pointer.pointerType) ? [
        undefined,
        undefined,
        "touch",
        "pen",
        "mouse"
    ][pointer.pointerType] : // be either a MouseEvent, TouchEvent, or Touch object
    /touch/.test(pointer.type || "") || pointer instanceof (0, $3Ilbz.default).Touch ? "touch" : "mouse";
} // [ event.target, event.currentTarget ]
function $cd45c26edda937b2$export$fbb25f7a0ef5cd4b(event) {
    const path = (0, $4dw5o.default).func(event.composedPath) ? event.composedPath() : event.path;
    return [
        $jLvtZ.getActualElement(path ? path[0] : event.target),
        $jLvtZ.getActualElement(event.currentTarget)
    ];
}
function $cd45c26edda937b2$export$b12cd1669c59c59a() {
    return {
        page: {
            x: 0,
            y: 0
        },
        client: {
            x: 0,
            y: 0
        },
        timeStamp: 0
    };
}
function $cd45c26edda937b2$export$798f030fada725d2(coords) {
    const event = {
        coords: coords,
        get page () {
            return this.coords.page;
        },
        get client () {
            return this.coords.client;
        },
        get timeStamp () {
            return this.coords.timeStamp;
        },
        get pageX () {
            return this.coords.page.x;
        },
        get pageY () {
            return this.coords.page.y;
        },
        get clientX () {
            return this.coords.client.x;
        },
        get clientY () {
            return this.coords.client.y;
        },
        get pointerId () {
            return this.coords.pointerId;
        },
        get target () {
            return this.coords.target;
        },
        get type () {
            return this.coords.type;
        },
        get pointerType () {
            return this.coords.pointerType;
        },
        get buttons () {
            return this.coords.buttons;
        },
        preventDefault () {}
    };
    return event;
}

});
parcelRequire.register("djSxD", function(module, exports) {

$parcel$export(module.exports, "default", () => $9b275b882b994c76$export$2e2bcd8739ae039);
var $9b275b882b994c76$export$2e2bcd8739ae039 = (x, y)=>Math.sqrt(x * x + y * y);

});

parcelRequire.register("aLC5p", function(module, exports) {

$parcel$export(module.exports, "default", () => $7d6bd64d975e6d63$export$2e2bcd8739ae039);
function $7d6bd64d975e6d63$export$2e2bcd8739ae039(dest, source) {
    dest.__set ||= {};
    for(const prop in source)if (typeof dest[prop] !== "function" && prop !== "__set") Object.defineProperty(dest, prop, {
        get () {
            if (prop in dest.__set) return dest.__set[prop];
            return dest.__set[prop] = source[prop];
        },
        set (value) {
            dest.__set[prop] = value;
        },
        configurable: true
    });
    return dest;
}

});


parcelRequire.register("JC3K7", function(module, exports) {

$parcel$export(module.exports, "DropEvent", () => $0891b9e1bb36ffe2$export$d72ac1b5c807f918);

var $iAJcJ = parcelRequire("iAJcJ");

var $kIfua = parcelRequire("kIfua");
class $0891b9e1bb36ffe2$export$d72ac1b5c807f918 extends (0, $iAJcJ.BaseEvent) {
    dropzone;
    dragEvent;
    relatedTarget;
    draggable;
    propagationStopped = false;
    immediatePropagationStopped = false;
    /**
   * Class of events fired on dropzones during drags with acceptable targets.
   */ constructor(dropState, dragEvent, type){
        super(dragEvent._interaction);
        const { element: element , dropzone: dropzone  } = type === "dragleave" ? dropState.prev : dropState.cur;
        this.type = type;
        this.target = element;
        this.currentTarget = element;
        this.dropzone = dropzone;
        this.dragEvent = dragEvent;
        this.relatedTarget = dragEvent.target;
        this.draggable = dragEvent.interactable;
        this.timeStamp = dragEvent.timeStamp;
    }
    /**
   * If this is a `dropactivate` event, the dropzone element will be
   * deactivated.
   *
   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the
   * dropzone element and more.
   */ reject() {
        const { dropState: dropState  } = this._interaction;
        if (this.type !== "dropactivate" && (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)) return;
        dropState.prev.dropzone = this.dropzone;
        dropState.prev.element = this.target;
        dropState.rejected = true;
        dropState.events.enter = null;
        this.stopImmediatePropagation();
        if (this.type === "dropactivate") {
            const activeDrops = dropState.activeDrops;
            const index = $kIfua.findIndex(activeDrops, ({ dropzone: dropzone , element: element  })=>dropzone === this.dropzone && element === this.target);
            dropState.activeDrops.splice(index, 1);
            const deactivateEvent = new $0891b9e1bb36ffe2$export$d72ac1b5c807f918(dropState, this.dragEvent, "dropdeactivate");
            deactivateEvent.dropzone = this.dropzone;
            deactivateEvent.target = this.target;
            this.dropzone.fire(deactivateEvent);
        } else this.dropzone.fire(new $0891b9e1bb36ffe2$export$d72ac1b5c807f918(dropState, this.dragEvent, "dragleave"));
    }
    preventDefault() {}
    stopPropagation() {
        this.propagationStopped = true;
    }
    stopImmediatePropagation() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    }
}

});
parcelRequire.register("iAJcJ", function(module, exports) {

$parcel$export(module.exports, "BaseEvent", () => $d88ea771f3994f7f$export$df414a03c2905461);
class $d88ea771f3994f7f$export$df414a03c2905461 {
    immediatePropagationStopped = false;
    propagationStopped = false;
    constructor(interaction){
        this._interaction = interaction;
    }
    preventDefault() {}
    /**
   * Don't call any other listeners (even on the current target)
   */ stopPropagation() {
        this.propagationStopped = true;
    }
    /**
   * Don't call listeners on the remaining targets
   */ stopImmediatePropagation() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    }
} // defined outside of class definition to avoid assignment of undefined during
// construction
// getters and setters defined here to support typescript 3.6 and below which
// don't support getter and setters in .d.ts files
Object.defineProperty($d88ea771f3994f7f$export$df414a03c2905461.prototype, "interaction", {
    get () {
        return this._interaction._proxy;
    },
    set () {}
});

});

parcelRequire.register("kIfua", function(module, exports) {

$parcel$export(module.exports, "contains", () => $f143edd7c0800ac8$export$2344b14b097df817);
$parcel$export(module.exports, "remove", () => $f143edd7c0800ac8$export$cd7f480d6b8286c3);
$parcel$export(module.exports, "merge", () => $f143edd7c0800ac8$export$4950aa0f605343fb);
$parcel$export(module.exports, "from", () => $f143edd7c0800ac8$export$6788812c4e6611e6);
$parcel$export(module.exports, "findIndex", () => $f143edd7c0800ac8$export$de3a4d4a0d731119);
$parcel$export(module.exports, "find", () => $f143edd7c0800ac8$export$71aa6c912b956294);
const $f143edd7c0800ac8$export$2344b14b097df817 = (array, target)=>array.indexOf(target) !== -1;
const $f143edd7c0800ac8$export$cd7f480d6b8286c3 = (array, target)=>array.splice(array.indexOf(target), 1);
const $f143edd7c0800ac8$export$4950aa0f605343fb = (target, source)=>{
    for (const item of source)target.push(item);
    return target;
};
const $f143edd7c0800ac8$export$6788812c4e6611e6 = (source)=>$f143edd7c0800ac8$export$4950aa0f605343fb([], source);
const $f143edd7c0800ac8$export$de3a4d4a0d731119 = (array, func)=>{
    for(let i = 0; i < array.length; i++){
        if (func(array[i], i, array)) return i;
    }
    return -1;
};
const $f143edd7c0800ac8$export$71aa6c912b956294 = (array, func)=>array[$f143edd7c0800ac8$export$de3a4d4a0d731119(array, func)];

});



parcelRequire.register("dz9GH", function(module, exports) {

$parcel$export(module.exports, "default", () => $9e060f08548255d8$export$2e2bcd8739ae039);

var $4dw5o = parcelRequire("4dw5o");

var $hCEXH = parcelRequire("hCEXH");
function $9e060f08548255d8$var$install(scope) {
    const { actions: actions , Interactable: Interactable , defaults: defaults  } = scope;
    /**
   * ```js
   * interact(element).gesturable({
   *     onstart: function (event) {},
   *     onmove : function (event) {},
   *     onend  : function (event) {},
   *
   *     // limit multiple gestures.
   *     // See the explanation in {@link Interactable.draggable} example
   *     max: Infinity,
   *     maxPerElement: 1,
   * })
   *
   * var isGestureable = interact(element).gesturable()
   * ```
   *
   * Gets or sets whether multitouch gestures can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on gesture events (makes the Interactable gesturable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of gesture events, or this Interactable
   */ Interactable.prototype.gesturable = function(options) {
        if ((0, $4dw5o.default).object(options)) {
            this.options.gesture.enabled = options.enabled !== false;
            this.setPerAction("gesture", options);
            this.setOnEvents("gesture", options);
            return this;
        }
        if ((0, $4dw5o.default).bool(options)) {
            this.options.gesture.enabled = options;
            return this;
        }
        return this.options.gesture;
    };
    actions.map.gesture = $9e060f08548255d8$var$gesture;
    actions.methodDict.gesture = "gesturable";
    defaults.actions.gesture = $9e060f08548255d8$var$gesture.defaults;
}
function $9e060f08548255d8$var$updateGestureProps({ interaction: interaction , iEvent: iEvent , phase: phase  }) {
    if (interaction.prepared.name !== "gesture") return;
    const pointers = interaction.pointers.map((p)=>p.pointer);
    const starting = phase === "start";
    const ending = phase === "end";
    const deltaSource = interaction.interactable.options.deltaSource;
    iEvent.touches = [
        pointers[0],
        pointers[1]
    ];
    if (starting) {
        iEvent.distance = $hCEXH.touchDistance(pointers, deltaSource);
        iEvent.box = $hCEXH.touchBBox(pointers);
        iEvent.scale = 1;
        iEvent.ds = 0;
        iEvent.angle = $hCEXH.touchAngle(pointers, deltaSource);
        iEvent.da = 0;
        interaction.gesture.startDistance = iEvent.distance;
        interaction.gesture.startAngle = iEvent.angle;
    } else if (ending) {
        const prevEvent = interaction.prevEvent;
        iEvent.distance = prevEvent.distance;
        iEvent.box = prevEvent.box;
        iEvent.scale = prevEvent.scale;
        iEvent.ds = 0;
        iEvent.angle = prevEvent.angle;
        iEvent.da = 0;
    } else {
        iEvent.distance = $hCEXH.touchDistance(pointers, deltaSource);
        iEvent.box = $hCEXH.touchBBox(pointers);
        iEvent.scale = iEvent.distance / interaction.gesture.startDistance;
        iEvent.angle = $hCEXH.touchAngle(pointers, deltaSource);
        iEvent.ds = iEvent.scale - interaction.gesture.scale;
        iEvent.da = iEvent.angle - interaction.gesture.angle;
    }
    interaction.gesture.distance = iEvent.distance;
    interaction.gesture.angle = iEvent.angle;
    if ((0, $4dw5o.default).number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) interaction.gesture.scale = iEvent.scale;
}
const $9e060f08548255d8$var$gesture = {
    id: "actions/gesture",
    before: [
        "actions/drag",
        "actions/resize"
    ],
    install: $9e060f08548255d8$var$install,
    listeners: {
        "interactions:action-start": $9e060f08548255d8$var$updateGestureProps,
        "interactions:action-move": $9e060f08548255d8$var$updateGestureProps,
        "interactions:action-end": $9e060f08548255d8$var$updateGestureProps,
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.gesture = {
                angle: 0,
                distance: 0,
                scale: 1,
                startAngle: 0,
                startDistance: 0
            };
        },
        "auto-start:check": (arg)=>{
            if (arg.interaction.pointers.length < 2) return undefined;
            const gestureOptions = arg.interactable.options.gesture;
            if (!(gestureOptions && gestureOptions.enabled)) return undefined;
            arg.action = {
                name: "gesture"
            };
            return false;
        }
    },
    defaults: {},
    getCursor () {
        return "";
    }
};
var $9e060f08548255d8$export$2e2bcd8739ae039 = $9e060f08548255d8$var$gesture;

});

parcelRequire.register("7Tceq", function(module, exports) {

$parcel$export(module.exports, "default", () => $5be72869979dcdf9$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");
function $5be72869979dcdf9$var$install(scope) {
    const { actions: actions , browser: browser , Interactable: /** @lends Interactable */ Interactable , defaults: // tslint:disable-line no-shadowed-variable
    defaults  } = scope; // Less Precision with touch input
    $5be72869979dcdf9$var$resize.cursors = $5be72869979dcdf9$var$initCursors(browser);
    $5be72869979dcdf9$var$resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;
    /**
   * ```js
   * interact(element).resizable({
   *   onstart: function (event) {},
   *   onmove : function (event) {},
   *   onend  : function (event) {},
   *
   *   edges: {
   *     top   : true,       // Use pointer coords to check for resize.
   *     left  : false,      // Disable resizing from left edge.
   *     bottom: '.resize-s',// Resize if pointer target matches selector
   *     right : handleEl    // Resize if pointer target is the given Element
   *   },
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height are adjusted at a 1:1 ratio.
   *     square: false,
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height maintain the aspect ratio they had when resizing started.
   *     preserveAspectRatio: false,
   *
   *   // a value of 'none' will limit the resize rect to a minimum of 0x0
   *   // 'negate' will allow the rect to have negative width/height
   *   // 'reposition' will keep the width/height positive by swapping
   *   // the top and bottom edges and/or swapping the left and right edges
   *   invert: 'none' || 'negate' || 'reposition'
   *
   *   // limit multiple resizes.
   *   // See the explanation in the {@link Interactable.draggable} example
   *   max: Infinity,
   *   maxPerElement: 1,
   * })
   *
   * var isResizeable = interact(element).resizable()
   * ```
   *
   * Gets or sets whether resize actions can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on resize events (object makes the Interactable
   * resizable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of resize elements, or this Interactable
   */ Interactable.prototype.resizable = function(options) {
        return $5be72869979dcdf9$var$resizable(this, options, scope);
    };
    actions.map.resize = $5be72869979dcdf9$var$resize;
    actions.methodDict.resize = "resizable";
    defaults.actions.resize = $5be72869979dcdf9$var$resize.defaults;
}
function $5be72869979dcdf9$var$resizeChecker(arg) {
    const { interaction: interaction , interactable: interactable , element: element , rect: rect , buttons: buttons  } = arg;
    if (!rect) return undefined;
    const page = (0, $cT3g2.default)({}, interaction.coords.cur.page);
    const resizeOptions = interactable.options.resize;
    if (!(resizeOptions && resizeOptions.enabled) || interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & resizeOptions.mouseButtons) === 0) return undefined;
     // if using resize.edges
    if ((0, $4dw5o.default).object(resizeOptions.edges)) {
        const resizeEdges = {
            left: false,
            right: false,
            top: false,
            bottom: false
        };
        for(const edge in resizeEdges)resizeEdges[edge] = $5be72869979dcdf9$var$checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || $5be72869979dcdf9$var$resize.defaultMargin);
        resizeEdges.left = resizeEdges.left && !resizeEdges.right;
        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;
        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) arg.action = {
            name: "resize",
            edges: resizeEdges
        };
    } else {
        const right = resizeOptions.axis !== "y" && page.x > rect.right - $5be72869979dcdf9$var$resize.defaultMargin;
        const bottom = resizeOptions.axis !== "x" && page.y > rect.bottom - $5be72869979dcdf9$var$resize.defaultMargin;
        if (right || bottom) arg.action = {
            name: "resize",
            axes: (right ? "x" : "") + (bottom ? "y" : "")
        };
    }
    return arg.action ? false : undefined;
}
function $5be72869979dcdf9$var$resizable(interactable, options, scope) {
    if ((0, $4dw5o.default).object(options)) {
        interactable.options.resize.enabled = options.enabled !== false;
        interactable.setPerAction("resize", options);
        interactable.setOnEvents("resize", options);
        if ((0, $4dw5o.default).string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) interactable.options.resize.axis = options.axis;
        else if (options.axis === null) interactable.options.resize.axis = scope.defaults.actions.resize.axis;
        if ((0, $4dw5o.default).bool(options.preserveAspectRatio)) interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
        else if ((0, $4dw5o.default).bool(options.square)) interactable.options.resize.square = options.square;
        return interactable;
    }
    if ((0, $4dw5o.default).bool(options)) {
        interactable.options.resize.enabled = options;
        return interactable;
    }
    return interactable.options.resize;
}
function $5be72869979dcdf9$var$checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
    // false, '', undefined, null
    if (!value) return false;
     // true value, use pointer coords and element rect
    if (value === true) {
        // if dimensions are negative, "switch" edges
        const width = (0, $4dw5o.default).number(rect.width) ? rect.width : rect.right - rect.left;
        const height = (0, $4dw5o.default).number(rect.height) ? rect.height : rect.bottom - rect.top; // don't use margin greater than half the relevent dimension
        margin = Math.min(margin, Math.abs((name === "left" || name === "right" ? width : height) / 2));
        if (width < 0) {
            if (name === "left") name = "right";
            else if (name === "right") name = "left";
        }
        if (height < 0) {
            if (name === "top") name = "bottom";
            else if (name === "bottom") name = "top";
        }
        if (name === "left") {
            const edge = width >= 0 ? rect.left : rect.right;
            return page.x < edge + margin;
        }
        if (name === "top") {
            const edge = height >= 0 ? rect.top : rect.bottom;
            return page.y < edge + margin;
        }
        if (name === "right") return page.x > (width >= 0 ? rect.right : rect.left) - margin;
        if (name === "bottom") return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
    } // the remaining checks require an element
    if (!(0, $4dw5o.default).element(element)) return false;
    return (0, $4dw5o.default).element(value) ? value === element : $jLvtZ.matchesUpTo(element, value, interactableElement);
}
/* eslint-disable multiline-ternary */ // eslint-disable-next-line @typescript-eslint/consistent-type-imports
function $5be72869979dcdf9$var$initCursors(browser) {
    return browser.isIe9 ? {
        x: "e-resize",
        y: "s-resize",
        xy: "se-resize",
        top: "n-resize",
        left: "w-resize",
        bottom: "s-resize",
        right: "e-resize",
        topleft: "se-resize",
        bottomright: "se-resize",
        topright: "ne-resize",
        bottomleft: "ne-resize"
    } : {
        x: "ew-resize",
        y: "ns-resize",
        xy: "nwse-resize",
        top: "ns-resize",
        left: "ew-resize",
        bottom: "ns-resize",
        right: "ew-resize",
        topleft: "nwse-resize",
        bottomright: "nwse-resize",
        topright: "nesw-resize",
        bottomleft: "nesw-resize"
    };
}
/* eslint-enable multiline-ternary */ function $5be72869979dcdf9$var$start({ iEvent: iEvent , interaction: interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
    const resizeEvent = iEvent;
    const rect = interaction.rect;
    interaction._rects = {
        start: (0, $cT3g2.default)({}, rect),
        corrected: (0, $cT3g2.default)({}, rect),
        previous: (0, $cT3g2.default)({}, rect),
        delta: {
            left: 0,
            right: 0,
            width: 0,
            top: 0,
            bottom: 0,
            height: 0
        }
    };
    resizeEvent.edges = interaction.prepared.edges;
    resizeEvent.rect = interaction._rects.corrected;
    resizeEvent.deltaRect = interaction._rects.delta;
}
function $5be72869979dcdf9$var$move({ iEvent: iEvent , interaction: interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
    const resizeEvent = iEvent;
    const resizeOptions = interaction.interactable.options.resize;
    const invert = resizeOptions.invert;
    const invertible = invert === "reposition" || invert === "negate";
    const current = interaction.rect;
    const { start: startRect , corrected: corrected , delta: deltaRect , previous: previous  } = interaction._rects;
    (0, $cT3g2.default)(previous, corrected);
    if (invertible) {
        // if invertible, copy the current rect
        (0, $cT3g2.default)(corrected, current);
        if (invert === "reposition") {
            // swap edge values if necessary to keep width/height positive
            if (corrected.top > corrected.bottom) {
                const swap = corrected.top;
                corrected.top = corrected.bottom;
                corrected.bottom = swap;
            }
            if (corrected.left > corrected.right) {
                const swap = corrected.left;
                corrected.left = corrected.right;
                corrected.right = swap;
            }
        }
    } else {
        // if not invertible, restrict to minimum of 0x0 rect
        corrected.top = Math.min(current.top, startRect.bottom);
        corrected.bottom = Math.max(current.bottom, startRect.top);
        corrected.left = Math.min(current.left, startRect.right);
        corrected.right = Math.max(current.right, startRect.left);
    }
    corrected.width = corrected.right - corrected.left;
    corrected.height = corrected.bottom - corrected.top;
    for(const edge in corrected)deltaRect[edge] = corrected[edge] - previous[edge];
    resizeEvent.edges = interaction.prepared.edges;
    resizeEvent.rect = corrected;
    resizeEvent.deltaRect = deltaRect;
}
function $5be72869979dcdf9$var$end({ iEvent: iEvent , interaction: interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
    const resizeEvent = iEvent;
    resizeEvent.edges = interaction.prepared.edges;
    resizeEvent.rect = interaction._rects.corrected;
    resizeEvent.deltaRect = interaction._rects.delta;
}
function $5be72869979dcdf9$var$updateEventAxes({ iEvent: iEvent , interaction: interaction  }) {
    if (interaction.prepared.name !== "resize" || !interaction.resizeAxes) return;
    const options = interaction.interactable.options;
    const resizeEvent = iEvent;
    if (options.resize.square) {
        if (interaction.resizeAxes === "y") resizeEvent.delta.x = resizeEvent.delta.y;
        else resizeEvent.delta.y = resizeEvent.delta.x;
        resizeEvent.axes = "xy";
    } else {
        resizeEvent.axes = interaction.resizeAxes;
        if (interaction.resizeAxes === "x") resizeEvent.delta.y = 0;
        else if (interaction.resizeAxes === "y") resizeEvent.delta.x = 0;
    }
}
const $5be72869979dcdf9$var$resize = {
    id: "actions/resize",
    before: [
        "actions/drag"
    ],
    install: $5be72869979dcdf9$var$install,
    listeners: {
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.resizeAxes = "xy";
        },
        "interactions:action-start": (arg)=>{
            $5be72869979dcdf9$var$start(arg);
            $5be72869979dcdf9$var$updateEventAxes(arg);
        },
        "interactions:action-move": (arg)=>{
            $5be72869979dcdf9$var$move(arg);
            $5be72869979dcdf9$var$updateEventAxes(arg);
        },
        "interactions:action-end": $5be72869979dcdf9$var$end,
        "auto-start:check": $5be72869979dcdf9$var$resizeChecker
    },
    defaults: {
        square: false,
        preserveAspectRatio: false,
        axis: "xy",
        // use default margin
        margin: NaN,
        // object with props left, right, top, bottom which are
        // true/false values to resize when the pointer is over that edge,
        // CSS selectors to match the handles for each direction
        // or the Elements for each handle
        edges: null,
        // a value of 'none' will limit the resize rect to a minimum of 0x0
        // 'negate' will alow the rect to have negative width/height
        // 'reposition' will keep the width/height positive by swapping
        // the top and bottom edges and/or swapping the left and right edges
        invert: "none"
    },
    cursors: null,
    getCursor ({ edges: edges , axis: axis , name: name  }) {
        const cursors = $5be72869979dcdf9$var$resize.cursors;
        let result = null;
        if (axis) result = cursors[name + axis];
        else if (edges) {
            let cursorKey = "";
            for (const edge of [
                "top",
                "bottom",
                "left",
                "right"
            ])if (edges[edge]) cursorKey += edge;
            result = cursors[cursorKey];
        }
        return result;
    },
    defaultMargin: null
};
var $5be72869979dcdf9$export$2e2bcd8739ae039 = $5be72869979dcdf9$var$resize;

});


parcelRequire.register("iWfeL", function(module, exports) {

$parcel$export(module.exports, "default", () => $dc99768a56ea626d$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $4dw5o = parcelRequire("4dw5o");

var $iL6qQ = parcelRequire("iL6qQ");

var $5ZvQW = parcelRequire("5ZvQW");

var $fhaz1 = parcelRequire("fhaz1");
function $dc99768a56ea626d$var$install(scope) {
    const { defaults: defaults , actions: actions  } = scope;
    scope.autoScroll = $dc99768a56ea626d$var$autoScroll;
    $dc99768a56ea626d$var$autoScroll.now = ()=>scope.now();
    actions.phaselessTypes.autoscroll = true;
    defaults.perAction.autoScroll = $dc99768a56ea626d$var$autoScroll.defaults;
}
const $dc99768a56ea626d$var$autoScroll = {
    defaults: {
        enabled: false,
        margin: 60,
        // the item that is scrolled (Window or HTMLElement)
        container: null,
        // the scroll speed in pixels per second
        speed: 300
    },
    now: Date.now,
    interaction: null,
    i: 0,
    // the handle returned by window.setInterval
    // Direction each pulse is to scroll in
    x: 0,
    y: 0,
    isScrolling: false,
    prevTime: 0,
    margin: 0,
    speed: 0,
    start (interaction) {
        $dc99768a56ea626d$var$autoScroll.isScrolling = true;
        (0, $iL6qQ.default).cancel($dc99768a56ea626d$var$autoScroll.i);
        interaction.autoScroll = $dc99768a56ea626d$var$autoScroll;
        $dc99768a56ea626d$var$autoScroll.interaction = interaction;
        $dc99768a56ea626d$var$autoScroll.prevTime = $dc99768a56ea626d$var$autoScroll.now();
        $dc99768a56ea626d$var$autoScroll.i = (0, $iL6qQ.default).request($dc99768a56ea626d$var$autoScroll.scroll);
    },
    stop () {
        $dc99768a56ea626d$var$autoScroll.isScrolling = false;
        if ($dc99768a56ea626d$var$autoScroll.interaction) $dc99768a56ea626d$var$autoScroll.interaction.autoScroll = null;
        (0, $iL6qQ.default).cancel($dc99768a56ea626d$var$autoScroll.i);
    },
    // scroll the window by the values in scroll.x/y
    scroll () {
        const { interaction: interaction  } = $dc99768a56ea626d$var$autoScroll;
        const { interactable: interactable , element: element  } = interaction;
        const actionName = interaction.prepared.name;
        const options = interactable.options[actionName].autoScroll;
        const container = $dc99768a56ea626d$export$49f5bf502122d4f7(options.container, interactable, element);
        const now = $dc99768a56ea626d$var$autoScroll.now(); // change in time in seconds
        const dt = (now - $dc99768a56ea626d$var$autoScroll.prevTime) / 1000; // displacement
        const s = options.speed * dt;
        if (s >= 1) {
            const scrollBy = {
                x: $dc99768a56ea626d$var$autoScroll.x * s,
                y: $dc99768a56ea626d$var$autoScroll.y * s
            };
            if (scrollBy.x || scrollBy.y) {
                const prevScroll = $dc99768a56ea626d$export$ff41c598de81c14a(container);
                if ((0, $4dw5o.default).window(container)) container.scrollBy(scrollBy.x, scrollBy.y);
                else if (container) {
                    container.scrollLeft += scrollBy.x;
                    container.scrollTop += scrollBy.y;
                }
                const curScroll = $dc99768a56ea626d$export$ff41c598de81c14a(container);
                const delta = {
                    x: curScroll.x - prevScroll.x,
                    y: curScroll.y - prevScroll.y
                };
                if (delta.x || delta.y) interactable.fire({
                    type: "autoscroll",
                    target: element,
                    interactable: interactable,
                    delta: delta,
                    interaction: interaction,
                    container: container
                });
            }
            $dc99768a56ea626d$var$autoScroll.prevTime = now;
        }
        if ($dc99768a56ea626d$var$autoScroll.isScrolling) {
            (0, $iL6qQ.default).cancel($dc99768a56ea626d$var$autoScroll.i);
            $dc99768a56ea626d$var$autoScroll.i = (0, $iL6qQ.default).request($dc99768a56ea626d$var$autoScroll.scroll);
        }
    },
    check (interactable, actionName) {
        var _options$actionName$a;
        const options = interactable.options;
        return (_options$actionName$a = options[actionName].autoScroll) == null ? void 0 : _options$actionName$a.enabled;
    },
    onInteractionMove ({ interaction: interaction , pointer: pointer  }) {
        if (!(interaction.interacting() && $dc99768a56ea626d$var$autoScroll.check(interaction.interactable, interaction.prepared.name))) return;
        if (interaction.simulation) {
            $dc99768a56ea626d$var$autoScroll.x = $dc99768a56ea626d$var$autoScroll.y = 0;
            return;
        }
        let top;
        let right;
        let bottom;
        let left;
        const { interactable: interactable , element: element  } = interaction;
        const actionName = interaction.prepared.name;
        const options = interactable.options[actionName].autoScroll;
        const container = $dc99768a56ea626d$export$49f5bf502122d4f7(options.container, interactable, element);
        if ((0, $4dw5o.default).window(container)) {
            left = pointer.clientX < $dc99768a56ea626d$var$autoScroll.margin;
            top = pointer.clientY < $dc99768a56ea626d$var$autoScroll.margin;
            right = pointer.clientX > container.innerWidth - $dc99768a56ea626d$var$autoScroll.margin;
            bottom = pointer.clientY > container.innerHeight - $dc99768a56ea626d$var$autoScroll.margin;
        } else {
            const rect = $jLvtZ.getElementClientRect(container);
            left = pointer.clientX < rect.left + $dc99768a56ea626d$var$autoScroll.margin;
            top = pointer.clientY < rect.top + $dc99768a56ea626d$var$autoScroll.margin;
            right = pointer.clientX > rect.right - $dc99768a56ea626d$var$autoScroll.margin;
            bottom = pointer.clientY > rect.bottom - $dc99768a56ea626d$var$autoScroll.margin;
        }
        $dc99768a56ea626d$var$autoScroll.x = right ? 1 : left ? -1 : 0;
        $dc99768a56ea626d$var$autoScroll.y = bottom ? 1 : top ? -1 : 0;
        if (!$dc99768a56ea626d$var$autoScroll.isScrolling) {
            // set the autoScroll properties to those of the target
            $dc99768a56ea626d$var$autoScroll.margin = options.margin;
            $dc99768a56ea626d$var$autoScroll.speed = options.speed;
            $dc99768a56ea626d$var$autoScroll.start(interaction);
        }
    }
};
function $dc99768a56ea626d$export$49f5bf502122d4f7(value, interactable, element) {
    return ((0, $4dw5o.default).string(value) ? (0, $5ZvQW.getStringOptionResult)(value, interactable, element) : value) || (0, $fhaz1.getWindow)(element);
}
function $dc99768a56ea626d$export$ff41c598de81c14a(container) {
    if ((0, $4dw5o.default).window(container)) container = window.document.body;
    return {
        x: container.scrollLeft,
        y: container.scrollTop
    };
}
function $dc99768a56ea626d$export$d9d87c520f59b2d3(container) {
    if ((0, $4dw5o.default).window(container)) container = window.document.body;
    return {
        x: container.scrollWidth,
        y: container.scrollHeight
    };
}
function $dc99768a56ea626d$export$c208835f3c1afd81({ interaction: interaction , element: element  }, func) {
    const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll;
    if (!scrollOptions || !scrollOptions.enabled) {
        func();
        return {
            x: 0,
            y: 0
        };
    }
    const scrollContainer = $dc99768a56ea626d$export$49f5bf502122d4f7(scrollOptions.container, interaction.interactable, element);
    const prevSize = $dc99768a56ea626d$export$ff41c598de81c14a(scrollContainer);
    func();
    const curSize = $dc99768a56ea626d$export$ff41c598de81c14a(scrollContainer);
    return {
        x: curSize.x - prevSize.x,
        y: curSize.y - prevSize.y
    };
}
const $dc99768a56ea626d$var$autoScrollPlugin = {
    id: "auto-scroll",
    install: $dc99768a56ea626d$var$install,
    listeners: {
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.autoScroll = null;
        },
        "interactions:destroy": ({ interaction: interaction  })=>{
            interaction.autoScroll = null;
            $dc99768a56ea626d$var$autoScroll.stop();
            if ($dc99768a56ea626d$var$autoScroll.interaction) $dc99768a56ea626d$var$autoScroll.interaction = null;
        },
        "interactions:stop": $dc99768a56ea626d$var$autoScroll.stop,
        "interactions:action-move": (arg)=>$dc99768a56ea626d$var$autoScroll.onInteractionMove(arg)
    }
};
var $dc99768a56ea626d$export$2e2bcd8739ae039 = $dc99768a56ea626d$var$autoScrollPlugin;

});
parcelRequire.register("iL6qQ", function(module, exports) {

$parcel$export(module.exports, "default", () => $da819b0483d8fb3a$export$2e2bcd8739ae039);
let $da819b0483d8fb3a$var$lastTime = 0;
let $da819b0483d8fb3a$var$request;
let $da819b0483d8fb3a$var$cancel;
function $da819b0483d8fb3a$var$init(global) {
    $da819b0483d8fb3a$var$request = global.requestAnimationFrame;
    $da819b0483d8fb3a$var$cancel = global.cancelAnimationFrame;
    if (!$da819b0483d8fb3a$var$request) {
        const vendors = [
            "ms",
            "moz",
            "webkit",
            "o"
        ];
        for (const vendor of vendors){
            $da819b0483d8fb3a$var$request = global[`${vendor}RequestAnimationFrame`];
            $da819b0483d8fb3a$var$cancel = global[`${vendor}CancelAnimationFrame`] || global[`${vendor}CancelRequestAnimationFrame`];
        }
    }
    $da819b0483d8fb3a$var$request = $da819b0483d8fb3a$var$request && $da819b0483d8fb3a$var$request.bind(global);
    $da819b0483d8fb3a$var$cancel = $da819b0483d8fb3a$var$cancel && $da819b0483d8fb3a$var$cancel.bind(global);
    if (!$da819b0483d8fb3a$var$request) {
        $da819b0483d8fb3a$var$request = (callback)=>{
            const currTime = Date.now();
            const timeToCall = Math.max(0, 16 - (currTime - $da819b0483d8fb3a$var$lastTime));
            const token = global.setTimeout(()=>{
                // eslint-disable-next-line n/no-callback-literal
                callback(currTime + timeToCall);
            }, timeToCall);
            $da819b0483d8fb3a$var$lastTime = currTime + timeToCall;
            return token;
        };
        $da819b0483d8fb3a$var$cancel = (token)=>clearTimeout(token);
    }
}
var $da819b0483d8fb3a$export$2e2bcd8739ae039 = {
    request: (callback)=>$da819b0483d8fb3a$var$request(callback),
    cancel: (token)=>$da819b0483d8fb3a$var$cancel(token),
    init: $da819b0483d8fb3a$var$init
};

});


parcelRequire.register("7MFoH", function(module, exports) {

$parcel$export(module.exports, "default", () => $5aad20c7baefb884$export$2e2bcd8739ae039);

var $kcGDL = parcelRequire("kcGDL");

var $1YvBE = parcelRequire("1YvBE");

var $dTvSc = parcelRequire("dTvSc");
var $5aad20c7baefb884$export$2e2bcd8739ae039 = {
    id: "auto-start",
    install (scope) {
        scope.usePlugin((0, $kcGDL.default));
        scope.usePlugin((0, $dTvSc.default));
        scope.usePlugin((0, $1YvBE.default));
    }
};

});
parcelRequire.register("kcGDL", function(module, exports) {

$parcel$export(module.exports, "default", () => $eb56012256cdd380$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $8uh4b = parcelRequire("8uh4b");

var $jXHID = parcelRequire("jXHID");
function $eb56012256cdd380$var$install(scope) {
    const { interactStatic: interact , defaults: defaults  } = scope;
    scope.usePlugin((0, $jXHID.default));
    defaults.base.actionChecker = null;
    defaults.base.styleCursor = true;
    (0, $cT3g2.default)(defaults.perAction, {
        manualStart: false,
        max: Infinity,
        maxPerElement: 1,
        allowFrom: null,
        ignoreFrom: null,
        // only allow left button by default
        // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value
        mouseButtons: 1
    });
    /**
   * Returns or sets the maximum number of concurrent interactions allowed.  By
   * default only 1 interaction is allowed at a time (for backwards
   * compatibility). To allow multiple interactions on the same Interactables and
   * elements, you need to enable it in the draggable, resizable and gesturable
   * `'max'` and `'maxPerElement'` options.
   *
   * @alias module:interact.maxInteractions
   *
   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.
   */ interact.maxInteractions = (newValue)=>$eb56012256cdd380$var$maxInteractions(newValue, scope);
    scope.autoStart = {
        // Allow this many interactions to happen simultaneously
        maxInteractions: Infinity,
        withinInteractionLimit: $eb56012256cdd380$var$withinInteractionLimit,
        cursorElement: null
    };
}
function $eb56012256cdd380$var$prepareOnDown({ interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget  }, scope) {
    if (interaction.interacting()) return;
    const actionInfo = $eb56012256cdd380$var$getActionInfo(interaction, pointer, event, eventTarget, scope);
    $eb56012256cdd380$var$prepare(interaction, actionInfo, scope);
}
function $eb56012256cdd380$var$prepareOnMove({ interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget  }, scope) {
    if (interaction.pointerType !== "mouse" || interaction.pointerIsDown || interaction.interacting()) return;
    const actionInfo = $eb56012256cdd380$var$getActionInfo(interaction, pointer, event, eventTarget, scope);
    $eb56012256cdd380$var$prepare(interaction, actionInfo, scope);
}
function $eb56012256cdd380$var$startOnMove(arg, scope) {
    const { interaction: interaction  } = arg;
    if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) return;
    scope.fire("autoStart:before-start", arg);
    const { interactable: interactable  } = interaction;
    const actionName = interaction.prepared.name;
    if (actionName && interactable) {
        // check manualStart and interaction limit
        if (interactable.options[actionName].manualStart || !$eb56012256cdd380$var$withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) interaction.stop();
        else {
            interaction.start(interaction.prepared, interactable, interaction.element);
            $eb56012256cdd380$var$setInteractionCursor(interaction, scope);
        }
    }
}
function $eb56012256cdd380$var$clearCursorOnStop({ interaction: interaction  }, scope) {
    const { interactable: interactable  } = interaction;
    if (interactable && interactable.options.styleCursor) $eb56012256cdd380$var$setCursor(interaction.element, "", scope);
} // Check if the current interactable supports the action.
// If so, return the validated action. Otherwise, return null
function $eb56012256cdd380$var$validateAction(action, interactable, element, eventTarget, scope) {
    if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && $eb56012256cdd380$var$withinInteractionLimit(interactable, element, action, scope)) return action;
    return null;
}
function $eb56012256cdd380$var$validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope) {
    for(let i = 0, len = matches.length; i < len; i++){
        const match = matches[i];
        const matchElement = matchElements[i];
        const matchAction = match.getAction(pointer, event, interaction, matchElement);
        if (!matchAction) continue;
        const action = $eb56012256cdd380$var$validateAction(matchAction, match, matchElement, eventTarget, scope);
        if (action) return {
            action: action,
            interactable: match,
            element: matchElement
        };
    }
    return {
        action: null,
        interactable: null,
        element: null
    };
}
function $eb56012256cdd380$var$getActionInfo(interaction, pointer, event, eventTarget, scope) {
    let matches = [];
    let matchElements = [];
    let element = eventTarget;
    function pushMatches(interactable) {
        matches.push(interactable);
        matchElements.push(element);
    }
    while((0, $4dw5o.default).element(element)){
        matches = [];
        matchElements = [];
        scope.interactables.forEachMatch(element, pushMatches);
        const actionInfo = $eb56012256cdd380$var$validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope);
        if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) return actionInfo;
        element = $jLvtZ.parentNode(element);
    }
    return {
        action: null,
        interactable: null,
        element: null
    };
}
function $eb56012256cdd380$var$prepare(interaction, { action: action , interactable: interactable , element: element  }, scope) {
    action = action || {
        name: null
    };
    interaction.interactable = interactable;
    interaction.element = element;
    (0, $8uh4b.copyAction)(interaction.prepared, action);
    interaction.rect = interactable && action.name ? interactable.getRect(element) : null;
    $eb56012256cdd380$var$setInteractionCursor(interaction, scope);
    scope.fire("autoStart:prepared", {
        interaction: interaction
    });
}
function $eb56012256cdd380$var$withinInteractionLimit(interactable, element, action, scope) {
    const options = interactable.options;
    const maxActions = options[action.name].max;
    const maxPerElement = options[action.name].maxPerElement;
    const autoStartMax = scope.autoStart.maxInteractions;
    let activeInteractions = 0;
    let interactableCount = 0;
    let elementCount = 0; // no actions if any of these values == 0
    if (!(maxActions && maxPerElement && autoStartMax)) return false;
    for (const interaction of scope.interactions.list){
        const otherAction = interaction.prepared.name;
        if (!interaction.interacting()) continue;
        activeInteractions++;
        if (activeInteractions >= autoStartMax) return false;
        if (interaction.interactable !== interactable) continue;
        interactableCount += otherAction === action.name ? 1 : 0;
        if (interactableCount >= maxActions) return false;
        if (interaction.element === element) {
            elementCount++;
            if (otherAction === action.name && elementCount >= maxPerElement) return false;
        }
    }
    return autoStartMax > 0;
}
function $eb56012256cdd380$var$maxInteractions(newValue, scope) {
    if ((0, $4dw5o.default).number(newValue)) {
        scope.autoStart.maxInteractions = newValue;
        return this;
    }
    return scope.autoStart.maxInteractions;
}
function $eb56012256cdd380$var$setCursor(element, cursor, scope) {
    const { cursorElement: prevCursorElement  } = scope.autoStart;
    if (prevCursorElement && prevCursorElement !== element) prevCursorElement.style.cursor = "";
    element.ownerDocument.documentElement.style.cursor = cursor;
    element.style.cursor = cursor;
    scope.autoStart.cursorElement = cursor ? element : null;
}
function $eb56012256cdd380$var$setInteractionCursor(interaction, scope) {
    const { interactable: interactable , element: element , prepared: prepared  } = interaction;
    if (!(interaction.pointerType === "mouse" && interactable && interactable.options.styleCursor)) {
        // clear previous target element cursor
        if (scope.autoStart.cursorElement) $eb56012256cdd380$var$setCursor(scope.autoStart.cursorElement, "", scope);
        return;
    }
    let cursor = "";
    if (prepared.name) {
        const cursorChecker = interactable.options[prepared.name].cursorChecker;
        if ((0, $4dw5o.default).func(cursorChecker)) cursor = cursorChecker(prepared, interactable, element, interaction._interacting);
        else cursor = scope.actions.map[prepared.name].getCursor(prepared);
    }
    $eb56012256cdd380$var$setCursor(interaction.element, cursor || "", scope);
}
const $eb56012256cdd380$var$autoStart = {
    id: "auto-start/base",
    before: [
        "actions"
    ],
    install: $eb56012256cdd380$var$install,
    listeners: {
        "interactions:down": $eb56012256cdd380$var$prepareOnDown,
        "interactions:move": (arg, scope)=>{
            $eb56012256cdd380$var$prepareOnMove(arg, scope);
            $eb56012256cdd380$var$startOnMove(arg, scope);
        },
        "interactions:stop": $eb56012256cdd380$var$clearCursorOnStop
    },
    maxInteractions: $eb56012256cdd380$var$maxInteractions,
    withinInteractionLimit: $eb56012256cdd380$var$withinInteractionLimit,
    validateAction: $eb56012256cdd380$var$validateAction
};
var $eb56012256cdd380$export$2e2bcd8739ae039 = $eb56012256cdd380$var$autoStart;

});
parcelRequire.register("8uh4b", function(module, exports) {

$parcel$export(module.exports, "warnOnce", () => $62de5d1eb6684c94$export$5b28268982f175ba);
$parcel$export(module.exports, "copyAction", () => $62de5d1eb6684c94$export$a077e9cfcba10d95);

var $fhaz1 = parcelRequire("fhaz1");
function $62de5d1eb6684c94$export$5b28268982f175ba(method, message) {
    let warned = false;
    return function() {
        if (!warned) {
            (0, $fhaz1.window).console.warn(message);
            warned = true;
        }
        return method.apply(this, arguments);
    };
}
function $62de5d1eb6684c94$export$a077e9cfcba10d95(dest, src) {
    dest.name = src.name;
    dest.axis = src.axis;
    dest.edges = src.edges;
    return dest;
}
const $62de5d1eb6684c94$export$c5552dfdbc7cec71 = (n)=>n >= 0 ? 1 : -1;

});

parcelRequire.register("jXHID", function(module, exports) {

$parcel$export(module.exports, "default", () => $e88570a7d9f05999$export$2e2bcd8739ae039);

var $4dw5o = parcelRequire("4dw5o");

var $8uh4b = parcelRequire("8uh4b");
function $e88570a7d9f05999$var$install(scope) {
    const { Interactable: /** @lends Interactable */ Interactable // tslint:disable-line no-shadowed-variable
      } = scope;
    Interactable.prototype.getAction = function getAction(pointer, event, interaction, element) {
        const action = $e88570a7d9f05999$var$defaultActionChecker(this, event, interaction, element, scope);
        if (this.options.actionChecker) return this.options.actionChecker(pointer, event, action, this, element, interaction);
        return action;
    };
    /**
   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any
   * of it's parents match the given CSS selector or Element, no
   * drag/resize/gesture is started.
   *
   * @deprecated
   * Don't use this method. Instead set the `ignoreFrom` option for each action
   * or for `pointerEvents`
   *
   * ```js
   * interact(targett)
   *   .draggable({
   *     ignoreFrom: 'input, textarea, a[href]'',
   *   })
   *   .pointerEvents({
   *     ignoreFrom: '[no-pointer]',
   *   })
   * ```
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to not ignore any elements
   * @return {string | Element | object} The current ignoreFrom value or this
   * Interactable
   */ Interactable.prototype.ignoreFrom = (0, $8uh4b.warnOnce)(function(newValue) {
        return this._backCompatOption("ignoreFrom", newValue);
    }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).");
    /**
   *
   * A drag/resize/gesture is started only If the target of the `mousedown`,
   * `pointerdown` or `touchstart` event or any of it's parents match the given
   * CSS selector or Element.
   *
   * @deprecated
   * Don't use this method. Instead set the `allowFrom` option for each action
   * or for `pointerEvents`
   *
   * ```js
   * interact(targett)
   *   .resizable({
   *     allowFrom: '.resize-handle',
   *   .pointerEvents({
   *     allowFrom: '.handle',,
   *   })
   * ```
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to allow from any element
   * @return {string | Element | object} The current allowFrom value or this
   * Interactable
   */ Interactable.prototype.allowFrom = (0, $8uh4b.warnOnce)(function(newValue) {
        return this._backCompatOption("allowFrom", newValue);
    }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).");
    /**
   * ```js
   * interact('.resize-drag')
   *   .resizable(true)
   *   .draggable(true)
   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {
   *
   *     if (interact.matchesSelector(event.target, '.drag-handle')) {
   *       // force drag with handle target
   *       action.name = drag
   *     }
   *     else {
   *       // resize from the top and right edges
   *       action.name  = 'resize'
   *       action.edges = { top: true, right: true }
   *     }
   *
   *     return action
   * })
   * ```
   *
   * Returns or sets the function used to check action to be performed on
   * pointerDown
   *
   * @param {function | null} [checker] A function which takes a pointer event,
   * defaultAction string, interactable, element and interaction as parameters
   * and returns an object with name property 'drag' 'resize' or 'gesture' and
   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right
   * props.
   * @return {Function | Interactable} The checker function or this Interactable
   */ Interactable.prototype.actionChecker = $e88570a7d9f05999$var$actionChecker;
    /**
   * Returns or sets whether the the cursor should be changed depending on the
   * action that would be performed if the mouse were pressed and dragged.
   *
   * @param {boolean} [newValue]
   * @return {boolean | Interactable} The current setting or this Interactable
   */ Interactable.prototype.styleCursor = $e88570a7d9f05999$var$styleCursor;
}
function $e88570a7d9f05999$var$defaultActionChecker(interactable, event, interaction, element, scope) {
    const rect = interactable.getRect(element);
    const buttons = event.buttons || ({
        0: 1,
        1: 4,
        3: 8,
        4: 16
    })[event.button];
    const arg = {
        action: null,
        interactable: interactable,
        interaction: interaction,
        element: element,
        rect: rect,
        buttons: buttons
    };
    scope.fire("auto-start:check", arg);
    return arg.action;
}
function $e88570a7d9f05999$var$styleCursor(newValue) {
    if ((0, $4dw5o.default).bool(newValue)) {
        this.options.styleCursor = newValue;
        return this;
    }
    if (newValue === null) {
        delete this.options.styleCursor;
        return this;
    }
    return this.options.styleCursor;
}
function $e88570a7d9f05999$var$actionChecker(checker) {
    if ((0, $4dw5o.default).func(checker)) {
        this.options.actionChecker = checker;
        return this;
    }
    if (checker === null) {
        delete this.options.actionChecker;
        return this;
    }
    return this.options.actionChecker;
}
var $e88570a7d9f05999$export$2e2bcd8739ae039 = {
    id: "auto-start/interactableMethods",
    install: $e88570a7d9f05999$var$install
};

});


parcelRequire.register("1YvBE", function(module, exports) {

$parcel$export(module.exports, "default", () => $1703e95f7dc25484$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $4dw5o = parcelRequire("4dw5o");

var $kcGDL = parcelRequire("kcGDL");
function $1703e95f7dc25484$var$beforeStart({ interaction: interaction , eventTarget: eventTarget , dx: dx , dy: dy  }, scope) {
    if (interaction.prepared.name !== "drag") return; // check if a drag is in the correct axis
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const targetOptions = interaction.interactable.options.drag;
    const startAxis = targetOptions.startAxis;
    const currentAxis = absX > absY ? "x" : absX < absY ? "y" : "xy";
    interaction.prepared.axis = targetOptions.lockAxis === "start" ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'
     : targetOptions.lockAxis; // if the movement isn't in the startAxis of the interactable
    if (currentAxis !== "xy" && startAxis !== "xy" && startAxis !== currentAxis) {
        interaction.prepared.name = null; // then try to get a drag from another ineractable
        let element = eventTarget;
        const getDraggable = function(interactable) {
            if (interactable === interaction.interactable) return;
            const options = interaction.interactable.options.drag;
            if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {
                const action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);
                if (action && action.name === "drag" && $1703e95f7dc25484$var$checkStartAxis(currentAxis, interactable) && (0, $kcGDL.default).validateAction(action, interactable, element, eventTarget, scope)) return interactable;
            }
        }; // check all interactables
        while((0, $4dw5o.default).element(element)){
            const interactable = scope.interactables.forEachMatch(element, getDraggable);
            if (interactable) {
                interaction.prepared.name = "drag";
                interaction.interactable = interactable;
                interaction.element = element;
                break;
            }
            element = (0, $jLvtZ.parentNode)(element);
        }
    }
}
function $1703e95f7dc25484$var$checkStartAxis(startAxis, interactable) {
    if (!interactable) return false;
    const thisAxis = interactable.options.drag.startAxis;
    return startAxis === "xy" || thisAxis === "xy" || thisAxis === startAxis;
}
var $1703e95f7dc25484$export$2e2bcd8739ae039 = {
    id: "auto-start/dragAxis",
    listeners: {
        "autoStart:before-start": $1703e95f7dc25484$var$beforeStart
    }
};

});

parcelRequire.register("dTvSc", function(module, exports) {

$parcel$export(module.exports, "default", () => $a1d922be48ff76d4$export$2e2bcd8739ae039);

var $kcGDL = parcelRequire("kcGDL");
function $a1d922be48ff76d4$var$install(scope) {
    const { defaults: defaults  } = scope;
    scope.usePlugin((0, $kcGDL.default));
    defaults.perAction.hold = 0;
    defaults.perAction.delay = 0;
}
function $a1d922be48ff76d4$var$getHoldDuration(interaction) {
    const actionName = interaction.prepared && interaction.prepared.name;
    if (!actionName) return null;
    const options = interaction.interactable.options;
    return options[actionName].hold || options[actionName].delay;
}
const $a1d922be48ff76d4$var$hold = {
    id: "auto-start/hold",
    install: $a1d922be48ff76d4$var$install,
    listeners: {
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.autoStartHoldTimer = null;
        },
        "autoStart:prepared": ({ interaction: interaction  })=>{
            const hold1 = $a1d922be48ff76d4$var$getHoldDuration(interaction);
            if (hold1 > 0) interaction.autoStartHoldTimer = setTimeout(()=>{
                interaction.start(interaction.prepared, interaction.interactable, interaction.element);
            }, hold1);
        },
        "interactions:move": ({ interaction: interaction , duplicate: duplicate  })=>{
            if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {
                clearTimeout(interaction.autoStartHoldTimer);
                interaction.autoStartHoldTimer = null;
            }
        },
        // prevent regular down->move autoStart
        "autoStart:before-start": ({ interaction: interaction  })=>{
            const holdDuration = $a1d922be48ff76d4$var$getHoldDuration(interaction);
            if (holdDuration > 0) interaction.prepared.name = null;
        }
    },
    getHoldDuration: $a1d922be48ff76d4$var$getHoldDuration
};
var $a1d922be48ff76d4$export$2e2bcd8739ae039 = $a1d922be48ff76d4$var$hold;

});


parcelRequire.register("1WRoq", function(module, exports) {

$parcel$export(module.exports, "default", () => $16b49ff006a71503$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $4dw5o = parcelRequire("4dw5o");

var $fhaz1 = parcelRequire("fhaz1");
function $16b49ff006a71503$var$preventDefault(newValue) {
    if (/^(always|never|auto)$/.test(newValue)) {
        this.options.preventDefault = newValue;
        return this;
    }
    if ((0, $4dw5o.default).bool(newValue)) {
        this.options.preventDefault = newValue ? "always" : "never";
        return this;
    }
    return this.options.preventDefault;
}
function $16b49ff006a71503$var$checkAndPreventDefault(interactable, scope, event) {
    const setting = interactable.options.preventDefault;
    if (setting === "never") return;
    if (setting === "always") {
        event.preventDefault();
        return;
    } // setting === 'auto'
    // if the browser supports passive event listeners and isn't running on iOS,
    // don't preventDefault of touch{start,move} events. CSS touch-action and
    // user-select should be used instead of calling event.preventDefault().
    if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {
        const doc = (0, $fhaz1.getWindow)(event.target).document;
        const docOptions = scope.getDocOptions(doc);
        if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) return;
    } // don't preventDefault of pointerdown events
    if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) return;
     // don't preventDefault on editable elements
    if ((0, $4dw5o.default).element(event.target) && (0, $jLvtZ.matchesSelector)(event.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *")) return;
    event.preventDefault();
}
function $16b49ff006a71503$var$onInteractionEvent({ interaction: interaction , event: event  }) {
    if (interaction.interactable) interaction.interactable.checkAndPreventDefault(event);
}
function $16b49ff006a71503$export$4b3e715f166fdd78(scope) {
    /** @lends Interactable */ const { Interactable: Interactable  } = scope;
    /**
   * Returns or sets whether to prevent the browser's default behaviour in
   * response to pointer events. Can be set to:
   *  - `'always'` to always prevent
   *  - `'never'` to never prevent
   *  - `'auto'` to let interact.js try to determine what would be best
   *
   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`
   * @return {string | Interactable} The current setting or this Interactable
   */ Interactable.prototype.preventDefault = $16b49ff006a71503$var$preventDefault;
    Interactable.prototype.checkAndPreventDefault = function(event) {
        return $16b49ff006a71503$var$checkAndPreventDefault(this, scope, event);
    }; // prevent native HTML5 drag on interact.js target elements
    scope.interactions.docEvents.push({
        type: "dragstart",
        listener (event) {
            for (const interaction of scope.interactions.list)if (interaction.element && (interaction.element === event.target || (0, $jLvtZ.nodeContains)(interaction.element, event.target))) {
                interaction.interactable.checkAndPreventDefault(event);
                return;
            }
        }
    });
}
var $16b49ff006a71503$export$2e2bcd8739ae039 = {
    id: "core/interactablePreventDefault",
    install: $16b49ff006a71503$export$4b3e715f166fdd78,
    listeners: [
        "down",
        "move",
        "up",
        "cancel"
    ].reduce((acc, eventType)=>{
        acc[`interactions:${eventType}`] = $16b49ff006a71503$var$onInteractionEvent;
        return acc;
    }, {})
};

});

parcelRequire.register("hGM1Y", function(module, exports) {

$parcel$export(module.exports, "default", () => $ce0b9dd2440d004d$export$2e2bcd8739ae039);

var $8FUfl = parcelRequire("8FUfl");

var $3Ilbz = parcelRequire("3Ilbz");

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $fhaz1 = parcelRequire("fhaz1");
var $ce0b9dd2440d004d$var$CheckName;
(function(CheckName1) {
    CheckName1["touchAction"] = "touchAction";
    CheckName1["boxSizing"] = "boxSizing";
    CheckName1["noListeners"] = "noListeners";
})($ce0b9dd2440d004d$var$CheckName || ($ce0b9dd2440d004d$var$CheckName = {}));
const $ce0b9dd2440d004d$var$prefix = "[interact.js] ";
const $ce0b9dd2440d004d$var$links = {
    touchAction: "https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",
    boxSizing: "https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"
}; // eslint-disable-next-line no-undef
const $ce0b9dd2440d004d$var$isProduction = false;
function $ce0b9dd2440d004d$var$install(scope, { logger: logger  } = {}) {
    const { Interactable: Interactable , defaults: defaults  } = scope;
    scope.logger = logger || console;
    defaults.base.devTools = {
        ignore: {}
    };
    Interactable.prototype.devTools = function(options) {
        if (options) {
            (0, $cT3g2.default)(this.options.devTools, options);
            return this;
        }
        return this.options.devTools;
    };
    scope.usePlugin((0, $8FUfl.default));
}
const $ce0b9dd2440d004d$var$checks = [
    {
        name: $ce0b9dd2440d004d$var$CheckName.touchAction,
        perform ({ element: element  }) {
            return !$ce0b9dd2440d004d$var$parentHasStyle(element, "touchAction", /pan-|pinch|none/);
        },
        getInfo ({ element: element  }) {
            return [
                element,
                $ce0b9dd2440d004d$var$links.touchAction
            ];
        },
        text: 'Consider adding CSS "touch-action: none" to this element\n'
    },
    {
        name: $ce0b9dd2440d004d$var$CheckName.boxSizing,
        perform (interaction) {
            const { element: element  } = interaction;
            return interaction.prepared.name === "resize" && element instanceof (0, $3Ilbz.default).HTMLElement && !$ce0b9dd2440d004d$var$hasStyle(element, "boxSizing", /border-box/);
        },
        text: 'Consider adding CSS "box-sizing: border-box" to this resizable element',
        getInfo ({ element: element  }) {
            return [
                element,
                $ce0b9dd2440d004d$var$links.boxSizing
            ];
        }
    },
    {
        name: $ce0b9dd2440d004d$var$CheckName.noListeners,
        perform (interaction) {
            const actionName = interaction.prepared.name;
            const moveListeners = interaction.interactable.events.types[`${actionName}move`] || [];
            return !moveListeners.length;
        },
        getInfo (interaction) {
            return [
                interaction.prepared.name,
                interaction.interactable
            ];
        },
        text: "There are no listeners set for this action"
    }
];
function $ce0b9dd2440d004d$var$hasStyle(element, prop, styleRe) {
    const value = element.style[prop] || $fhaz1.window.getComputedStyle(element)[prop];
    return styleRe.test((value || "").toString());
}
function $ce0b9dd2440d004d$var$parentHasStyle(element, prop, styleRe) {
    let parent = element;
    while((0, $4dw5o.default).element(parent)){
        if ($ce0b9dd2440d004d$var$hasStyle(parent, prop, styleRe)) return true;
        parent = (0, $jLvtZ.parentNode)(parent);
    }
    return false;
}
const $ce0b9dd2440d004d$var$id = "dev-tools";
const $ce0b9dd2440d004d$var$defaultExport = $ce0b9dd2440d004d$var$isProduction ? {
    id: $ce0b9dd2440d004d$var$id,
    install: ()=>{}
} : {
    id: $ce0b9dd2440d004d$var$id,
    install: $ce0b9dd2440d004d$var$install,
    listeners: {
        "interactions:action-start": ({ interaction: interaction  }, scope)=>{
            for (const check of $ce0b9dd2440d004d$var$checks){
                const options = interaction.interactable && interaction.interactable.options;
                if (!(options && options.devTools && options.devTools.ignore[check.name]) && check.perform(interaction)) scope.logger.warn($ce0b9dd2440d004d$var$prefix + check.text, ...check.getInfo(interaction));
            }
        }
    },
    checks: $ce0b9dd2440d004d$var$checks,
    CheckName: $ce0b9dd2440d004d$var$CheckName,
    links: $ce0b9dd2440d004d$var$links,
    prefix: $ce0b9dd2440d004d$var$prefix
};
var $ce0b9dd2440d004d$export$2e2bcd8739ae039 = $ce0b9dd2440d004d$var$defaultExport;

});
parcelRequire.register("8FUfl", function(module, exports) {

$parcel$export(module.exports, "default", () => $650dc8765e71da97$export$2e2bcd8739ae039);
var $650dc8765e71da97$export$2e2bcd8739ae039 = {};

});


parcelRequire.register("cGkn6", function(module, exports) {

$parcel$export(module.exports, "default", () => $93b935a9c9ff83ae$export$2e2bcd8739ae039);

var $l77dP = parcelRequire("l77dP");

var $htFb1 = parcelRequire("htFb1");

var $dPcav = parcelRequire("dPcav");

var $jLvtZ = parcelRequire("jLvtZ");

var $djSxD = parcelRequire("djSxD");

var $4dw5o = parcelRequire("4dw5o");

var $hCEXH = parcelRequire("hCEXH");

var $iL6qQ = parcelRequire("iL6qQ");
function $93b935a9c9ff83ae$var$install(scope) {
    const { defaults: defaults  } = scope;
    scope.usePlugin((0, $dPcav.default));
    scope.usePlugin($htFb1.default);
    scope.actions.phases.inertiastart = true;
    scope.actions.phases.resume = true;
    defaults.perAction.inertia = {
        enabled: false,
        resistance: 10,
        // the lambda in exponential decay
        minSpeed: 100,
        // target speed must be above this for inertia to start
        endSpeed: 10,
        // the speed at which inertia is slow enough to stop
        allowResume: true,
        // allow resuming an action in inertia phase
        smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia
    };
}
class $93b935a9c9ff83ae$export$18e24b76c59f4f26 {
    active = false;
    isModified = false;
    smoothEnd = false;
    allowResume = false;
    modification;
    modifierCount = 0;
    modifierArg;
    startCoords;
    t0 = 0;
    v0 = 0;
    te = 0;
    targetOffset;
    modifiedOffset;
    currentOffset;
    lambda_v0 = 0;
    one_ve_v0 = 0;
    timeout;
    interaction;
    constructor(interaction){
        this.interaction = interaction;
    }
    start(event) {
        const { interaction: interaction  } = this;
        const options = $93b935a9c9ff83ae$var$getOptions(interaction);
        if (!options || !options.enabled) return false;
        const { client: velocityClient  } = interaction.coords.velocity;
        const pointerSpeed = (0, $djSxD.default)(velocityClient.x, velocityClient.y);
        const modification = this.modification || (this.modification = new (0, $l77dP.default)(interaction));
        modification.copyFrom(interaction.modification);
        this.t0 = interaction._now();
        this.allowResume = options.allowResume;
        this.v0 = pointerSpeed;
        this.currentOffset = {
            x: 0,
            y: 0
        };
        this.startCoords = interaction.coords.cur.page;
        this.modifierArg = modification.fillArg({
            pageCoords: this.startCoords,
            preEnd: true,
            phase: "inertiastart"
        });
        const thrown = this.t0 - interaction.coords.cur.timeStamp < 50 && pointerSpeed > options.minSpeed && pointerSpeed > options.endSpeed;
        if (thrown) this.startInertia();
        else {
            modification.result = modification.setAll(this.modifierArg);
            if (!modification.result.changed) return false;
            this.startSmoothEnd();
        } // force modification change
        interaction.modification.result.rect = null; // bring inertiastart event to the target coords
        interaction.offsetBy(this.targetOffset);
        interaction._doPhase({
            interaction: interaction,
            event: event,
            phase: "inertiastart"
        });
        interaction.offsetBy({
            x: -this.targetOffset.x,
            y: -this.targetOffset.y
        }); // force modification change
        interaction.modification.result.rect = null;
        this.active = true;
        interaction.simulation = this;
        return true;
    }
    startInertia() {
        const startVelocity = this.interaction.coords.velocity.client;
        const options = $93b935a9c9ff83ae$var$getOptions(this.interaction);
        const lambda = options.resistance;
        const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda;
        this.targetOffset = {
            x: (startVelocity.x - inertiaDur) / lambda,
            y: (startVelocity.y - inertiaDur) / lambda
        };
        this.te = inertiaDur;
        this.lambda_v0 = lambda / this.v0;
        this.one_ve_v0 = 1 - options.endSpeed / this.v0;
        const { modification: modification , modifierArg: modifierArg  } = this;
        modifierArg.pageCoords = {
            x: this.startCoords.x + this.targetOffset.x,
            y: this.startCoords.y + this.targetOffset.y
        };
        modification.result = modification.setAll(modifierArg);
        if (modification.result.changed) {
            this.isModified = true;
            this.modifiedOffset = {
                x: this.targetOffset.x + modification.result.delta.x,
                y: this.targetOffset.y + modification.result.delta.y
            };
        }
        this.onNextFrame(()=>this.inertiaTick());
    }
    startSmoothEnd() {
        this.smoothEnd = true;
        this.isModified = true;
        this.targetOffset = {
            x: this.modification.result.delta.x,
            y: this.modification.result.delta.y
        };
        this.onNextFrame(()=>this.smoothEndTick());
    }
    onNextFrame(tickFn) {
        this.timeout = (0, $iL6qQ.default).request(()=>{
            if (this.active) tickFn();
        });
    }
    inertiaTick() {
        const { interaction: interaction  } = this;
        const options = $93b935a9c9ff83ae$var$getOptions(interaction);
        const lambda = options.resistance;
        const t = (interaction._now() - this.t0) / 1000;
        if (t < this.te) {
            const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0;
            let newOffset;
            if (this.isModified) newOffset = $93b935a9c9ff83ae$var$getQuadraticCurvePoint(0, 0, this.targetOffset.x, this.targetOffset.y, this.modifiedOffset.x, this.modifiedOffset.y, progress);
            else newOffset = {
                x: this.targetOffset.x * progress,
                y: this.targetOffset.y * progress
            };
            const delta = {
                x: newOffset.x - this.currentOffset.x,
                y: newOffset.y - this.currentOffset.y
            };
            this.currentOffset.x += delta.x;
            this.currentOffset.y += delta.y;
            interaction.offsetBy(delta);
            interaction.move();
            this.onNextFrame(()=>this.inertiaTick());
        } else {
            interaction.offsetBy({
                x: this.modifiedOffset.x - this.currentOffset.x,
                y: this.modifiedOffset.y - this.currentOffset.y
            });
            this.end();
        }
    }
    smoothEndTick() {
        const { interaction: interaction  } = this;
        const t = interaction._now() - this.t0;
        const { smoothEndDuration: duration  } = $93b935a9c9ff83ae$var$getOptions(interaction);
        if (t < duration) {
            const newOffset = {
                x: $93b935a9c9ff83ae$var$easeOutQuad(t, 0, this.targetOffset.x, duration),
                y: $93b935a9c9ff83ae$var$easeOutQuad(t, 0, this.targetOffset.y, duration)
            };
            const delta = {
                x: newOffset.x - this.currentOffset.x,
                y: newOffset.y - this.currentOffset.y
            };
            this.currentOffset.x += delta.x;
            this.currentOffset.y += delta.y;
            interaction.offsetBy(delta);
            interaction.move({
                skipModifiers: this.modifierCount
            });
            this.onNextFrame(()=>this.smoothEndTick());
        } else {
            interaction.offsetBy({
                x: this.targetOffset.x - this.currentOffset.x,
                y: this.targetOffset.y - this.currentOffset.y
            });
            this.end();
        }
    }
    resume({ pointer: pointer , event: event , eventTarget: eventTarget  }) {
        const { interaction: interaction  } = this; // undo inertia changes to interaction coords
        interaction.offsetBy({
            x: -this.currentOffset.x,
            y: -this.currentOffset.y
        }); // update pointer at pointer down position
        interaction.updatePointer(pointer, event, eventTarget, true); // fire resume signals and event
        interaction._doPhase({
            interaction: interaction,
            event: event,
            phase: "resume"
        });
        (0, $hCEXH.copyCoords)(interaction.coords.prev, interaction.coords.cur);
        this.stop();
    }
    end() {
        this.interaction.move();
        this.interaction.end();
        this.stop();
    }
    stop() {
        this.active = this.smoothEnd = false;
        this.interaction.simulation = null;
        (0, $iL6qQ.default).cancel(this.timeout);
    }
}
function $93b935a9c9ff83ae$var$start({ interaction: interaction , event: event  }) {
    if (!interaction._interacting || interaction.simulation) return null;
    const started = interaction.inertia.start(event); // prevent action end if inertia or smoothEnd
    return started ? false : null;
} // Check if the down event hits the current inertia target
// control should be return to the user
function $93b935a9c9ff83ae$var$resume(arg) {
    const { interaction: interaction , eventTarget: eventTarget  } = arg;
    const state = interaction.inertia;
    if (!state.active) return;
    let element = eventTarget; // climb up the DOM tree from the event target
    while((0, $4dw5o.default).element(element)){
        // if interaction element is the current inertia target element
        if (element === interaction.element) {
            state.resume(arg);
            break;
        }
        element = $jLvtZ.parentNode(element);
    }
}
function $93b935a9c9ff83ae$var$stop({ interaction: interaction  }) {
    const state = interaction.inertia;
    if (state.active) state.stop();
}
function $93b935a9c9ff83ae$var$getOptions({ interactable: interactable , prepared: prepared  }) {
    return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia;
}
const $93b935a9c9ff83ae$var$inertia = {
    id: "inertia",
    before: [
        "modifiers",
        "actions"
    ],
    install: $93b935a9c9ff83ae$var$install,
    listeners: {
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.inertia = new $93b935a9c9ff83ae$export$18e24b76c59f4f26(interaction);
        },
        "interactions:before-action-end": $93b935a9c9ff83ae$var$start,
        "interactions:down": $93b935a9c9ff83ae$var$resume,
        "interactions:stop": $93b935a9c9ff83ae$var$stop,
        "interactions:before-action-resume": (arg)=>{
            const { modification: modification  } = arg.interaction;
            modification.stop(arg);
            modification.start(arg, arg.interaction.coords.cur.page);
            modification.applyToInteraction(arg);
        },
        "interactions:before-action-inertiastart": (arg)=>arg.interaction.modification.setAndApply(arg),
        "interactions:action-resume": $htFb1.addEventModifiers,
        "interactions:action-inertiastart": $htFb1.addEventModifiers,
        "interactions:after-action-inertiastart": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg),
        "interactions:after-action-resume": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg)
    }
}; // http://stackoverflow.com/a/5634528/2280888
function $93b935a9c9ff83ae$var$_getQBezierValue(t, p1, p2, p3) {
    const iT = 1 - t;
    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;
}
function $93b935a9c9ff83ae$var$getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {
    return {
        x: $93b935a9c9ff83ae$var$_getQBezierValue(position, startX, cpX, endX),
        y: $93b935a9c9ff83ae$var$_getQBezierValue(position, startY, cpY, endY)
    };
} // http://gizma.com/easing/
function $93b935a9c9ff83ae$var$easeOutQuad(t, b, c, d) {
    t /= d;
    return -c * t * (t - 2) + b;
}
var $93b935a9c9ff83ae$export$2e2bcd8739ae039 = $93b935a9c9ff83ae$var$inertia;

});
parcelRequire.register("l77dP", function(module, exports) {

$parcel$export(module.exports, "default", () => $f5efda9700682291$export$2e2bcd8739ae039);

var $2ySEv = parcelRequire("2ySEv");

var $cT3g2 = parcelRequire("cT3g2");

var $5ZvQW = parcelRequire("5ZvQW");
class $f5efda9700682291$export$2e2bcd8739ae039 {
    states = [];
    startOffset = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    startDelta;
    result;
    endResult;
    edges;
    interaction;
    constructor(interaction){
        this.interaction = interaction;
        this.result = $f5efda9700682291$var$createResult();
    }
    start({ phase: phase  }, pageCoords) {
        const { interaction: interaction  } = this;
        const modifierList = $f5efda9700682291$var$getModifierList(interaction);
        this.prepareStates(modifierList);
        this.edges = (0, $cT3g2.default)({}, interaction.edges);
        this.startOffset = $f5efda9700682291$export$1f3b4a546d4a6096(interaction.rect, pageCoords);
        this.startDelta = {
            x: 0,
            y: 0
        };
        const arg = this.fillArg({
            phase: phase,
            pageCoords: pageCoords,
            preEnd: false
        });
        this.result = $f5efda9700682291$var$createResult();
        this.startAll(arg);
        const result = this.result = this.setAll(arg);
        return result;
    }
    fillArg(arg) {
        const { interaction: interaction  } = this;
        arg.interaction = interaction;
        arg.interactable = interaction.interactable;
        arg.element = interaction.element;
        arg.rect = arg.rect || interaction.rect;
        arg.edges = this.edges;
        arg.startOffset = this.startOffset;
        return arg;
    }
    startAll(arg) {
        for (const state of this.states)if (state.methods.start) {
            arg.state = state;
            state.methods.start(arg);
        }
    }
    setAll(arg) {
        const { phase: phase , preEnd: preEnd , skipModifiers: skipModifiers , rect: unmodifiedRect  } = arg;
        arg.coords = (0, $cT3g2.default)({}, arg.pageCoords);
        arg.rect = (0, $cT3g2.default)({}, unmodifiedRect);
        const states = skipModifiers ? this.states.slice(skipModifiers) : this.states;
        const newResult = $f5efda9700682291$var$createResult(arg.coords, arg.rect);
        for (const state of states){
            var _state$methods;
            const { options: options  } = state;
            const lastModifierCoords = (0, $cT3g2.default)({}, arg.coords);
            let returnValue = null;
            if ((_state$methods = state.methods) != null && _state$methods.set && this.shouldDo(options, preEnd, phase)) {
                arg.state = state;
                returnValue = state.methods.set(arg);
                $5ZvQW.addEdges(this.interaction.edges, arg.rect, {
                    x: arg.coords.x - lastModifierCoords.x,
                    y: arg.coords.y - lastModifierCoords.y
                });
            }
            newResult.eventProps.push(returnValue);
        }
        newResult.delta.x = arg.coords.x - arg.pageCoords.x;
        newResult.delta.y = arg.coords.y - arg.pageCoords.y;
        newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left;
        newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right;
        newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top;
        newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom;
        const prevCoords = this.result.coords;
        const prevRect = this.result.rect;
        if (prevCoords && prevRect) {
            const rectChanged = newResult.rect.left !== prevRect.left || newResult.rect.right !== prevRect.right || newResult.rect.top !== prevRect.top || newResult.rect.bottom !== prevRect.bottom;
            newResult.changed = rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y;
        }
        return newResult;
    }
    applyToInteraction(arg) {
        const { interaction: interaction  } = this;
        const { phase: phase  } = arg;
        const curCoords = interaction.coords.cur;
        const startCoords = interaction.coords.start;
        const { result: result , startDelta: startDelta  } = this;
        const curDelta = result.delta;
        if (phase === "start") (0, $cT3g2.default)(this.startDelta, result.delta);
        for (const [coordsSet, delta] of [
            [
                startCoords,
                startDelta
            ],
            [
                curCoords,
                curDelta
            ]
        ]){
            coordsSet.page.x += delta.x;
            coordsSet.page.y += delta.y;
            coordsSet.client.x += delta.x;
            coordsSet.client.y += delta.y;
        }
        const { rectDelta: rectDelta  } = this.result;
        const rect = arg.rect || interaction.rect;
        rect.left += rectDelta.left;
        rect.right += rectDelta.right;
        rect.top += rectDelta.top;
        rect.bottom += rectDelta.bottom;
        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
    }
    setAndApply(arg) {
        const { interaction: interaction  } = this;
        const { phase: phase , preEnd: preEnd , skipModifiers: skipModifiers  } = arg;
        const result = this.setAll(this.fillArg({
            preEnd: preEnd,
            phase: phase,
            pageCoords: arg.modifiedCoords || interaction.coords.cur.page
        }));
        this.result = result; // don't fire an action move if a modifier would keep the event in the same
        // cordinates as before
        if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) return false;
        if (arg.modifiedCoords) {
            const { page: page  } = interaction.coords.cur;
            const adjustment = {
                x: arg.modifiedCoords.x - page.x,
                y: arg.modifiedCoords.y - page.y
            };
            result.coords.x += adjustment.x;
            result.coords.y += adjustment.y;
            result.delta.x += adjustment.x;
            result.delta.y += adjustment.y;
        }
        this.applyToInteraction(arg);
    }
    beforeEnd(arg) {
        const { interaction: interaction , event: event  } = arg;
        const states = this.states;
        if (!states || !states.length) return;
        let doPreend = false;
        for (const state of states){
            arg.state = state;
            const { options: options , methods: methods  } = state;
            const endPosition = methods.beforeEnd && methods.beforeEnd(arg);
            if (endPosition) {
                this.endResult = endPosition;
                return false;
            }
            doPreend = doPreend || !doPreend && this.shouldDo(options, true, arg.phase, true);
        }
        if (doPreend) // trigger a final modified move before ending
        interaction.move({
            event: event,
            preEnd: true
        });
    }
    stop(arg) {
        const { interaction: interaction  } = arg;
        if (!this.states || !this.states.length) return;
        const modifierArg = (0, $cT3g2.default)({
            states: this.states,
            interactable: interaction.interactable,
            element: interaction.element,
            rect: null
        }, arg);
        this.fillArg(modifierArg);
        for (const state of this.states){
            modifierArg.state = state;
            if (state.methods.stop) state.methods.stop(modifierArg);
        }
        this.states = null;
        this.endResult = null;
    }
    prepareStates(modifierList) {
        this.states = [];
        for(let index = 0; index < modifierList.length; index++){
            const { options: options , methods: methods , name: name  } = modifierList[index];
            this.states.push({
                options: options,
                methods: methods,
                index: index,
                name: name
            });
        }
        return this.states;
    }
    restoreInteractionCoords({ interaction: { coords: coords , rect: rect , modification: modification  }  }) {
        if (!modification.result) return;
        const { startDelta: startDelta  } = modification;
        const { delta: curDelta , rectDelta: rectDelta  } = modification.result;
        const coordsAndDeltas = [
            [
                coords.start,
                startDelta
            ],
            [
                coords.cur,
                curDelta
            ]
        ];
        for (const [coordsSet, delta] of coordsAndDeltas){
            coordsSet.page.x -= delta.x;
            coordsSet.page.y -= delta.y;
            coordsSet.client.x -= delta.x;
            coordsSet.client.y -= delta.y;
        }
        rect.left -= rectDelta.left;
        rect.right -= rectDelta.right;
        rect.top -= rectDelta.top;
        rect.bottom -= rectDelta.bottom;
    }
    shouldDo(options, preEnd, phase, requireEndOnly) {
        if (!options || options.enabled === false || requireEndOnly && !options.endOnly || options.endOnly && !preEnd || phase === "start" && !options.setStart) return false;
        return true;
    }
    copyFrom(other) {
        this.startOffset = other.startOffset;
        this.startDelta = other.startDelta;
        this.edges = other.edges;
        this.states = other.states.map((s)=>(0, $2ySEv.default)(s));
        this.result = $f5efda9700682291$var$createResult((0, $cT3g2.default)({}, other.result.coords), (0, $cT3g2.default)({}, other.result.rect));
    }
    destroy() {
        for(const prop in this)this[prop] = null;
    }
}
function $f5efda9700682291$var$createResult(coords, rect) {
    return {
        rect: rect,
        coords: coords,
        delta: {
            x: 0,
            y: 0
        },
        rectDelta: {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        eventProps: [],
        changed: true
    };
}
function $f5efda9700682291$var$getModifierList(interaction) {
    const actionOptions = interaction.interactable.options[interaction.prepared.name];
    const actionModifiers = actionOptions.modifiers;
    if (actionModifiers && actionModifiers.length) return actionModifiers;
    return [
        "snap",
        "snapSize",
        "snapEdges",
        "restrict",
        "restrictEdges",
        "restrictSize"
    ].map((type)=>{
        const options = actionOptions[type];
        return options && options.enabled && {
            options: options,
            methods: options._methods
        };
    }).filter((m)=>!!m);
}
function $f5efda9700682291$export$1f3b4a546d4a6096(rect, coords) {
    return rect ? {
        left: coords.x - rect.left,
        top: coords.y - rect.top,
        right: rect.right - coords.x,
        bottom: rect.bottom - coords.y
    } : {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
    };
}

});
parcelRequire.register("2ySEv", function(module, exports) {

$parcel$export(module.exports, "default", () => $1dd92692f26aab79$export$2e2bcd8739ae039);

var $kIfua = parcelRequire("kIfua");

var $4dw5o = parcelRequire("4dw5o");
function $1dd92692f26aab79$export$2e2bcd8739ae039(source) {
    const dest = {};
    for(const prop in source){
        const value = source[prop];
        if ((0, $4dw5o.default).plainObject(value)) dest[prop] = $1dd92692f26aab79$export$2e2bcd8739ae039(value);
        else if ((0, $4dw5o.default).array(value)) dest[prop] = $kIfua.from(value);
        else dest[prop] = value;
    }
    return dest;
}

});


parcelRequire.register("htFb1", function(module, exports) {

$parcel$export(module.exports, "makeModifier", () => $cb9515f75c3bcefa$export$f637c73b65c8249);
$parcel$export(module.exports, "addEventModifiers", () => $cb9515f75c3bcefa$export$f1ea306de90fd7ac);
$parcel$export(module.exports, "default", () => $cb9515f75c3bcefa$export$2e2bcd8739ae039);

var $l77dP = parcelRequire("l77dP");
function $cb9515f75c3bcefa$export$f637c73b65c8249(module, name) {
    const { defaults: defaults  } = module;
    const methods = {
        start: module.start,
        set: module.set,
        beforeEnd: module.beforeEnd,
        stop: module.stop
    };
    const modifier = (_options)=>{
        const options = _options || {};
        options.enabled = options.enabled !== false; // add missing defaults to options
        for(const prop in defaults)if (!(prop in options)) options[prop] = defaults[prop];
        const m = {
            options: options,
            methods: methods,
            name: name,
            enable: ()=>{
                options.enabled = true;
                return m;
            },
            disable: ()=>{
                options.enabled = false;
                return m;
            }
        };
        return m;
    };
    if (name && typeof name === "string") {
        // for backwrads compatibility
        modifier._defaults = defaults;
        modifier._methods = methods;
    }
    return modifier;
}
function $cb9515f75c3bcefa$export$f1ea306de90fd7ac({ iEvent: iEvent , interaction: interaction  }) {
    const result = interaction.modification.result;
    if (result) iEvent.modifiers = result.eventProps;
}
const $cb9515f75c3bcefa$var$modifiersBase = {
    id: "modifiers/base",
    before: [
        "actions"
    ],
    install: (scope)=>{
        scope.defaults.perAction.modifiers = [];
    },
    listeners: {
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.modification = new (0, $l77dP.default)(interaction);
        },
        "interactions:before-action-start": (arg)=>{
            const modification = arg.interaction.modification;
            modification.start(arg, arg.interaction.coords.start.page);
            arg.interaction.edges = modification.edges;
            modification.applyToInteraction(arg);
        },
        "interactions:before-action-move": (arg)=>arg.interaction.modification.setAndApply(arg),
        "interactions:before-action-end": (arg)=>arg.interaction.modification.beforeEnd(arg),
        "interactions:action-start": $cb9515f75c3bcefa$export$f1ea306de90fd7ac,
        "interactions:action-move": $cb9515f75c3bcefa$export$f1ea306de90fd7ac,
        "interactions:action-end": $cb9515f75c3bcefa$export$f1ea306de90fd7ac,
        "interactions:after-action-start": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg),
        "interactions:after-action-move": (arg)=>arg.interaction.modification.restoreInteractionCoords(arg),
        "interactions:stop": (arg)=>arg.interaction.modification.stop(arg)
    }
};
var $cb9515f75c3bcefa$export$2e2bcd8739ae039 = $cb9515f75c3bcefa$var$modifiersBase;

});

parcelRequire.register("dPcav", function(module, exports) {

$parcel$export(module.exports, "default", () => $a1097a2879d8d703$export$2e2bcd8739ae039);

var $fVJnv = parcelRequire("fVJnv");

var $5ZvQW = parcelRequire("5ZvQW");
(0, $fVJnv._ProxyMethods).offsetBy = "";
function $a1097a2879d8d703$export$43830a426aa3d636(interaction) {
    if (!interaction.pointerIsDown) return;
    $a1097a2879d8d703$var$addToCoords(interaction.coords.cur, interaction.offset.total);
    interaction.offset.pending.x = 0;
    interaction.offset.pending.y = 0;
}
function $a1097a2879d8d703$var$beforeAction({ interaction: interaction  }) {
    $a1097a2879d8d703$export$abf923b47efe1910(interaction);
}
function $a1097a2879d8d703$var$beforeEnd({ interaction: interaction  }) {
    const hadPending = $a1097a2879d8d703$export$abf923b47efe1910(interaction);
    if (!hadPending) return;
    interaction.move({
        offset: true
    });
    interaction.end();
    return false;
}
function $a1097a2879d8d703$var$end({ interaction: interaction  }) {
    interaction.offset.total.x = 0;
    interaction.offset.total.y = 0;
    interaction.offset.pending.x = 0;
    interaction.offset.pending.y = 0;
}
function $a1097a2879d8d703$export$abf923b47efe1910(interaction) {
    if (!$a1097a2879d8d703$var$hasPending(interaction)) return false;
    const { pending: pending  } = interaction.offset;
    $a1097a2879d8d703$var$addToCoords(interaction.coords.cur, pending);
    $a1097a2879d8d703$var$addToCoords(interaction.coords.delta, pending);
    $5ZvQW.addEdges(interaction.edges, interaction.rect, pending);
    pending.x = 0;
    pending.y = 0;
    return true;
}
function $a1097a2879d8d703$var$offsetBy({ x: x , y: y  }) {
    this.offset.pending.x += x;
    this.offset.pending.y += y;
    this.offset.total.x += x;
    this.offset.total.y += y;
}
function $a1097a2879d8d703$var$addToCoords({ page: page , client: client  }, { x: x , y: y  }) {
    page.x += x;
    page.y += y;
    client.x += x;
    client.y += y;
}
function $a1097a2879d8d703$var$hasPending(interaction) {
    return !!(interaction.offset.pending.x || interaction.offset.pending.y);
}
const $a1097a2879d8d703$var$offset = {
    id: "offset",
    before: [
        "modifiers",
        "pointer-events",
        "actions",
        "inertia"
    ],
    install (scope) {
        scope.Interaction.prototype.offsetBy = $a1097a2879d8d703$var$offsetBy;
    },
    listeners: {
        "interactions:new": ({ interaction: interaction  })=>{
            interaction.offset = {
                total: {
                    x: 0,
                    y: 0
                },
                pending: {
                    x: 0,
                    y: 0
                }
            };
        },
        "interactions:update-pointer": ({ interaction: interaction  })=>$a1097a2879d8d703$export$43830a426aa3d636(interaction),
        "interactions:before-action-start": $a1097a2879d8d703$var$beforeAction,
        "interactions:before-action-move": $a1097a2879d8d703$var$beforeAction,
        "interactions:before-action-end": $a1097a2879d8d703$var$beforeEnd,
        "interactions:stop": $a1097a2879d8d703$var$end
    }
};
var $a1097a2879d8d703$export$2e2bcd8739ae039 = $a1097a2879d8d703$var$offset;

});
parcelRequire.register("fVJnv", function(module, exports) {

$parcel$export(module.exports, "_ProxyMethods", () => $b98f610d6b1005c3$export$4d2ff6a73c1f4097);
$parcel$export(module.exports, "default", () => $b98f610d6b1005c3$export$2e2bcd8739ae039);

var $kIfua = parcelRequire("kIfua");

var $cT3g2 = parcelRequire("cT3g2");

var $djSxD = parcelRequire("djSxD");

var $8uh4b = parcelRequire("8uh4b");

var $hCEXH = parcelRequire("hCEXH");
var $aLC5p = parcelRequire("aLC5p");

var $5ZvQW = parcelRequire("5ZvQW");

var $aRV67 = parcelRequire("aRV67");

var $jPWvY = parcelRequire("jPWvY");
let $b98f610d6b1005c3$export$32c038ccdbc0c29a;
(function(_ProxyValues1) {
    _ProxyValues1["interactable"] = "";
    _ProxyValues1["element"] = "";
    _ProxyValues1["prepared"] = "";
    _ProxyValues1["pointerIsDown"] = "";
    _ProxyValues1["pointerWasMoved"] = "";
    _ProxyValues1["_proxy"] = "";
})($b98f610d6b1005c3$export$32c038ccdbc0c29a || ($b98f610d6b1005c3$export$32c038ccdbc0c29a = {}));
let $b98f610d6b1005c3$export$4d2ff6a73c1f4097;
(function(_ProxyMethods1) {
    _ProxyMethods1["start"] = "";
    _ProxyMethods1["move"] = "";
    _ProxyMethods1["end"] = "";
    _ProxyMethods1["stop"] = "";
    _ProxyMethods1["interacting"] = "";
})($b98f610d6b1005c3$export$4d2ff6a73c1f4097 || ($b98f610d6b1005c3$export$4d2ff6a73c1f4097 = {}));
let $b98f610d6b1005c3$var$idCounter = 0;
class $b98f610d6b1005c3$export$a13296960cae0384 {
    // current interactable being interacted with
    interactable = null;
    element = null;
    rect = null;
    _rects;
    edges = null;
    _scopeFire;
    prepared = {
        name: null,
        axis: null,
        edges: null
    };
    pointerType;
    pointers = [];
    downEvent = null;
    downPointer = {};
    _latestPointer = {
        pointer: null,
        event: null,
        eventTarget: null
    };
    prevEvent = null;
    pointerIsDown = false;
    pointerWasMoved = false;
    _interacting = false;
    _ending = false;
    _stopped = true;
    _proxy = null;
    simulation = null;
    /** @internal */ get pointerMoveTolerance() {
        return 1;
    }
    /**
   * @alias Interaction.prototype.move
   */ doMove = (0, $8uh4b.warnOnce)(function(signalArg) {
        this.move(signalArg);
    }, "The interaction.doMove() method has been renamed to interaction.move()");
    coords = {
        // Starting InteractEvent pointer coordinates
        start: $hCEXH.newCoords(),
        // Previous native pointer move event coordinates
        prev: $hCEXH.newCoords(),
        // current native pointer move event coordinates
        cur: $hCEXH.newCoords(),
        // Change in coordinates and time of the pointer
        delta: $hCEXH.newCoords(),
        // pointer velocity
        velocity: $hCEXH.newCoords()
    };
    _id = $b98f610d6b1005c3$var$idCounter++;
    /** */ constructor({ pointerType: pointerType , scopeFire: scopeFire  }){
        this._scopeFire = scopeFire;
        this.pointerType = pointerType;
        const that = this;
        this._proxy = {};
        for(const key in $b98f610d6b1005c3$export$32c038ccdbc0c29a)Object.defineProperty(this._proxy, key, {
            get () {
                return that[key];
            }
        });
        for(const key1 in $b98f610d6b1005c3$export$4d2ff6a73c1f4097)Object.defineProperty(this._proxy, key1, {
            value: (...args)=>that[key1](...args)
        });
        this._scopeFire("interactions:new", {
            interaction: this
        });
    }
    pointerDown(pointer, event, eventTarget) {
        const pointerIndex = this.updatePointer(pointer, event, eventTarget, true);
        const pointerInfo = this.pointers[pointerIndex];
        this._scopeFire("interactions:down", {
            pointer: pointer,
            event: event,
            eventTarget: eventTarget,
            pointerIndex: pointerIndex,
            pointerInfo: pointerInfo,
            type: "down",
            interaction: this
        });
    }
    /**
   * ```js
   * interact(target)
   *   .draggable({
   *     // disable the default drag start by down->move
   *     manualStart: true
   *   })
   *   // start dragging after the user holds the pointer down
   *   .on('hold', function (event) {
   *     var interaction = event.interaction
   *
   *     if (!interaction.interacting()) {
   *       interaction.start({ name: 'drag' },
   *                         event.interactable,
   *                         event.currentTarget)
   *     }
   * })
   * ```
   *
   * Start an action with the given Interactable and Element as tartgets. The
   * action must be enabled for the target Interactable and an appropriate
   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.
   *
   * Use it with `interactable.<action>able({ manualStart: false })` to always
   * [start actions manually](https://github.com/taye/interact.js/issues/114)
   *
   * @param {object} action   The action to be performed - drag, resize, etc.
   * @param {Interactable} target  The Interactable to target
   * @param {Element} element The DOM Element to target
   * @return {Boolean} Whether the interaction was successfully started
   */ start(action, interactable, element) {
        if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === "gesture" ? 2 : 1) || !interactable.options[action.name].enabled) return false;
        (0, $8uh4b.copyAction)(this.prepared, action);
        this.interactable = interactable;
        this.element = element;
        this.rect = interactable.getRect(element);
        this.edges = this.prepared.edges ? (0, $cT3g2.default)({}, this.prepared.edges) : {
            left: true,
            right: true,
            top: true,
            bottom: true
        };
        this._stopped = false;
        this._interacting = this._doPhase({
            interaction: this,
            event: this.downEvent,
            phase: "start"
        }) && !this._stopped;
        return this._interacting;
    }
    pointerMove(pointer, event, eventTarget) {
        if (!this.simulation && !(this.modification && this.modification.endResult)) this.updatePointer(pointer, event, eventTarget, false);
        const duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        let dx;
        let dy; // register movement greater than pointerMoveTolerance
        if (this.pointerIsDown && !this.pointerWasMoved) {
            dx = this.coords.cur.client.x - this.coords.start.client.x;
            dy = this.coords.cur.client.y - this.coords.start.client.y;
            this.pointerWasMoved = (0, $djSxD.default)(dx, dy) > this.pointerMoveTolerance;
        }
        const pointerIndex = this.getPointerIndex(pointer);
        const signalArg = {
            pointer: pointer,
            pointerIndex: pointerIndex,
            pointerInfo: this.pointers[pointerIndex],
            event: event,
            type: "move",
            eventTarget: eventTarget,
            dx: dx,
            dy: dy,
            duplicate: duplicateMove,
            interaction: this
        };
        if (!duplicateMove) // set pointer coordinate, time changes and velocity
        $hCEXH.setCoordVelocity(this.coords.velocity, this.coords.delta);
        this._scopeFire("interactions:move", signalArg);
        if (!duplicateMove && !this.simulation) {
            // if interacting, fire an 'action-move' signal etc
            if (this.interacting()) {
                signalArg.type = null;
                this.move(signalArg);
            }
            if (this.pointerWasMoved) $hCEXH.copyCoords(this.coords.prev, this.coords.cur);
        }
    }
    /**
   * ```js
   * interact(target)
   *   .draggable(true)
   *   .on('dragmove', function (event) {
   *     if (someCondition) {
   *       // change the snap settings
   *       event.interactable.draggable({ snap: { targets: [] }})
   *       // fire another move event with re-calculated snap
   *       event.interaction.move()
   *     }
   *   })
   * ```
   *
   * Force a move of the current action at the same coordinates. Useful if
   * snap/restrict has been changed and you want a movement with the new
   * settings.
   */ move(signalArg) {
        if (!signalArg || !signalArg.event) $hCEXH.setZeroCoords(this.coords.delta);
        signalArg = (0, $cT3g2.default)({
            pointer: this._latestPointer.pointer,
            event: this._latestPointer.event,
            eventTarget: this._latestPointer.eventTarget,
            interaction: this
        }, signalArg || {});
        signalArg.phase = "move";
        this._doPhase(signalArg);
    }
    pointerUp(pointer, event, eventTarget, curEventTarget) {
        let pointerIndex = this.getPointerIndex(pointer);
        if (pointerIndex === -1) pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
        const type = /cancel$/i.test(event.type) ? "cancel" : "up";
        this._scopeFire(`interactions:${type}`, {
            pointer: pointer,
            pointerIndex: pointerIndex,
            pointerInfo: this.pointers[pointerIndex],
            event: event,
            eventTarget: eventTarget,
            type: type,
            curEventTarget: curEventTarget,
            interaction: this
        });
        if (!this.simulation) this.end(event);
        this.removePointer(pointer, event);
    }
    documentBlur(event) {
        this.end(event);
        this._scopeFire("interactions:blur", {
            event: event,
            type: "blur",
            interaction: this
        });
    }
    /**
   * ```js
   * interact(target)
   *   .draggable(true)
   *   .on('move', function (event) {
   *     if (event.pageX > 1000) {
   *       // end the current action
   *       event.interaction.end()
   *       // stop all further listeners from being called
   *       event.stopImmediatePropagation()
   *     }
   *   })
   * ```
   *
   * @param {PointerEvent} [event]
   */ end(event) {
        this._ending = true;
        event = event || this._latestPointer.event;
        let endPhaseResult;
        if (this.interacting()) endPhaseResult = this._doPhase({
            event: event,
            interaction: this,
            phase: "end"
        });
        this._ending = false;
        if (endPhaseResult === true) this.stop();
    }
    currentAction() {
        return this._interacting ? this.prepared.name : null;
    }
    interacting() {
        return this._interacting;
    }
    /** */ stop() {
        this._scopeFire("interactions:stop", {
            interaction: this
        });
        this.interactable = this.element = null;
        this._interacting = false;
        this._stopped = true;
        this.prepared.name = this.prevEvent = null;
    }
    getPointerIndex(pointer) {
        const pointerId = $hCEXH.getPointerId(pointer); // mouse and pen interactions may have only one pointer
        return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : $kIfua.findIndex(this.pointers, (curPointer)=>curPointer.id === pointerId);
    }
    getPointerInfo(pointer) {
        return this.pointers[this.getPointerIndex(pointer)];
    }
    updatePointer(pointer, event, eventTarget, down) {
        const id = $hCEXH.getPointerId(pointer);
        let pointerIndex = this.getPointerIndex(pointer);
        let pointerInfo = this.pointers[pointerIndex];
        down = down === false ? false : down || /(down|start)$/i.test(event.type);
        if (!pointerInfo) {
            pointerInfo = new (0, $jPWvY.PointerInfo)(id, pointer, event, null, null);
            pointerIndex = this.pointers.length;
            this.pointers.push(pointerInfo);
        } else pointerInfo.pointer = pointer;
        $hCEXH.setCoords(this.coords.cur, this.pointers.map((p)=>p.pointer), this._now());
        $hCEXH.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);
        if (down) {
            this.pointerIsDown = true;
            pointerInfo.downTime = this.coords.cur.timeStamp;
            pointerInfo.downTarget = eventTarget;
            $aLC5p.default(this.downPointer, pointer);
            if (!this.interacting()) {
                $hCEXH.copyCoords(this.coords.start, this.coords.cur);
                $hCEXH.copyCoords(this.coords.prev, this.coords.cur);
                this.downEvent = event;
                this.pointerWasMoved = false;
            }
        }
        this._updateLatestPointer(pointer, event, eventTarget);
        this._scopeFire("interactions:update-pointer", {
            pointer: pointer,
            event: event,
            eventTarget: eventTarget,
            down: down,
            pointerInfo: pointerInfo,
            pointerIndex: pointerIndex,
            interaction: this
        });
        return pointerIndex;
    }
    removePointer(pointer, event) {
        const pointerIndex = this.getPointerIndex(pointer);
        if (pointerIndex === -1) return;
        const pointerInfo = this.pointers[pointerIndex];
        this._scopeFire("interactions:remove-pointer", {
            pointer: pointer,
            event: event,
            eventTarget: null,
            pointerIndex: pointerIndex,
            pointerInfo: pointerInfo,
            interaction: this
        });
        this.pointers.splice(pointerIndex, 1);
        this.pointerIsDown = false;
    }
    _updateLatestPointer(pointer, event, eventTarget) {
        this._latestPointer.pointer = pointer;
        this._latestPointer.event = event;
        this._latestPointer.eventTarget = eventTarget;
    }
    destroy() {
        this._latestPointer.pointer = null;
        this._latestPointer.event = null;
        this._latestPointer.eventTarget = null;
    }
    _createPreparedEvent(event, phase, preEnd, type) {
        return new (0, $aRV67.InteractEvent)(this, event, this.prepared.name, phase, this.element, preEnd, type);
    }
    _fireEvent(iEvent) {
        var _this$interactable;
        (_this$interactable = this.interactable) == null || _this$interactable.fire(iEvent);
        if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) this.prevEvent = iEvent;
    }
    _doPhase(signalArg) {
        const { event: event , phase: phase , preEnd: preEnd , type: type  } = signalArg;
        const { rect: rect  } = this;
        if (rect && phase === "move") {
            // update the rect changes due to pointer move
            $5ZvQW.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource]);
            rect.width = rect.right - rect.left;
            rect.height = rect.bottom - rect.top;
        }
        const beforeResult = this._scopeFire(`interactions:before-action-${phase}`, signalArg);
        if (beforeResult === false) return false;
        const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);
        this._scopeFire(`interactions:action-${phase}`, signalArg);
        if (phase === "start") this.prevEvent = iEvent;
        this._fireEvent(iEvent);
        this._scopeFire(`interactions:after-action-${phase}`, signalArg);
        return true;
    }
    _now() {
        return Date.now();
    }
}
var $b98f610d6b1005c3$export$2e2bcd8739ae039 = $b98f610d6b1005c3$export$a13296960cae0384;

});
parcelRequire.register("aRV67", function(module, exports) {

$parcel$export(module.exports, "InteractEvent", () => $7e9b25035775f3fc$export$60bef1b1d94fef92);

var $cT3g2 = parcelRequire("cT3g2");

var $5bWyX = parcelRequire("5bWyX");

var $djSxD = parcelRequire("djSxD");

var $iAJcJ = parcelRequire("iAJcJ");

var $8xhML = parcelRequire("8xhML");
class $7e9b25035775f3fc$export$60bef1b1d94fef92 extends (0, $iAJcJ.BaseEvent) {
    relatedTarget = null;
    screenX;
    screenY;
    button;
    buttons;
    ctrlKey;
    shiftKey;
    altKey;
    metaKey;
    page;
    client;
    delta;
    rect;
    x0;
    y0;
    t0;
    dt;
    duration;
    clientX0;
    clientY0;
    velocity;
    speed;
    swipe;
    axes;
    preEnd;
    /** */ constructor(interaction, event, actionName, phase, element, preEnd, type){
        super(interaction);
        element = element || interaction.element;
        const target = interaction.interactable;
        const deltaSource = (target && target.options || (0, $8xhML.defaults)).deltaSource;
        const origin = (0, $5bWyX.default)(target, element, actionName);
        const starting = phase === "start";
        const ending = phase === "end";
        const prevEvent = starting ? this : interaction.prevEvent;
        const coords = starting ? interaction.coords.start : ending ? {
            page: prevEvent.page,
            client: prevEvent.client,
            timeStamp: interaction.coords.cur.timeStamp
        } : interaction.coords.cur;
        this.page = (0, $cT3g2.default)({}, coords.page);
        this.client = (0, $cT3g2.default)({}, coords.client);
        this.rect = (0, $cT3g2.default)({}, interaction.rect);
        this.timeStamp = coords.timeStamp;
        if (!ending) {
            this.page.x -= origin.x;
            this.page.y -= origin.y;
            this.client.x -= origin.x;
            this.client.y -= origin.y;
        }
        this.ctrlKey = event.ctrlKey;
        this.altKey = event.altKey;
        this.shiftKey = event.shiftKey;
        this.metaKey = event.metaKey;
        this.button = event.button;
        this.buttons = event.buttons;
        this.target = element;
        this.currentTarget = element;
        this.preEnd = preEnd;
        this.type = type || actionName + (phase || "");
        this.interactable = target;
        this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
        this.x0 = interaction.coords.start.page.x - origin.x;
        this.y0 = interaction.coords.start.page.y - origin.y;
        this.clientX0 = interaction.coords.start.client.x - origin.x;
        this.clientY0 = interaction.coords.start.client.y - origin.y;
        if (starting || ending) this.delta = {
            x: 0,
            y: 0
        };
        else this.delta = {
            x: this[deltaSource].x - prevEvent[deltaSource].x,
            y: this[deltaSource].y - prevEvent[deltaSource].y
        };
        this.dt = interaction.coords.delta.timeStamp;
        this.duration = this.timeStamp - this.t0; // velocity and speed in pixels per second
        this.velocity = (0, $cT3g2.default)({}, interaction.coords.velocity[deltaSource]);
        this.speed = (0, $djSxD.default)(this.velocity.x, this.velocity.y);
        this.swipe = ending || phase === "inertiastart" ? this.getSwipe() : null;
    }
    getSwipe() {
        const interaction = this._interaction;
        if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) return null;
        let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
        const overlap = 22.5;
        if (angle < 0) angle += 360;
        const left = 135 - overlap <= angle && angle < 225 + overlap;
        const up = 225 - overlap <= angle && angle < 315 + overlap;
        const right = !left && (315 - overlap <= angle || angle < 45 + overlap);
        const down = !up && 45 - overlap <= angle && angle < 135 + overlap;
        return {
            up: up,
            down: down,
            left: left,
            right: right,
            angle: angle,
            speed: interaction.prevEvent.speed,
            velocity: {
                x: interaction.prevEvent.velocityX,
                y: interaction.prevEvent.velocityY
            }
        };
    }
    preventDefault() {}
    /**
   * Don't call listeners on the remaining targets
   */ stopImmediatePropagation() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    }
    /**
   * Don't call any other listeners (even on the current target)
   */ stopPropagation() {
        this.propagationStopped = true;
    }
} // getters and setters defined here to support typescript 3.6 and below which
// don't support getter and setters in .d.ts files
Object.defineProperties($7e9b25035775f3fc$export$60bef1b1d94fef92.prototype, {
    pageX: {
        get () {
            return this.page.x;
        },
        set (value) {
            this.page.x = value;
        }
    },
    pageY: {
        get () {
            return this.page.y;
        },
        set (value) {
            this.page.y = value;
        }
    },
    clientX: {
        get () {
            return this.client.x;
        },
        set (value) {
            this.client.x = value;
        }
    },
    clientY: {
        get () {
            return this.client.y;
        },
        set (value) {
            this.client.y = value;
        }
    },
    dx: {
        get () {
            return this.delta.x;
        },
        set (value) {
            this.delta.x = value;
        }
    },
    dy: {
        get () {
            return this.delta.y;
        },
        set (value) {
            this.delta.y = value;
        }
    },
    velocityX: {
        get () {
            return this.velocity.x;
        },
        set (value) {
            this.velocity.x = value;
        }
    },
    velocityY: {
        get () {
            return this.velocity.y;
        },
        set (value) {
            this.velocity.y = value;
        }
    }
});

});
parcelRequire.register("8xhML", function(module, exports) {

$parcel$export(module.exports, "defaults", () => $636f33a39b9b54ba$export$ebe90cb607ad99e);
const $636f33a39b9b54ba$export$ebe90cb607ad99e = {
    base: {
        preventDefault: "auto",
        deltaSource: "page"
    },
    perAction: {
        enabled: false,
        origin: {
            x: 0,
            y: 0
        }
    },
    actions: {}
};

});


parcelRequire.register("jPWvY", function(module, exports) {

$parcel$export(module.exports, "PointerInfo", () => $e7102b893219ffee$export$3d32e0a6dc61f70c);
class $e7102b893219ffee$export$3d32e0a6dc61f70c {
    id;
    pointer;
    event;
    downTime;
    downTarget;
    constructor(id, pointer, event, downTime, downTarget){
        this.id = id;
        this.pointer = pointer;
        this.event = event;
        this.downTime = downTime;
        this.downTarget = downTarget;
    }
}

});




parcelRequire.register("iAXdE", function(module, exports) {

$parcel$export(module.exports, "default", () => $d89986799d1689ef$export$2e2bcd8739ae039, (v) => $d89986799d1689ef$export$2e2bcd8739ae039 = v);

var $h4KhJ = parcelRequire("h4KhJ");

const $d89986799d1689ef$var$scope = new (0, $h4KhJ.Scope)();
const $d89986799d1689ef$var$interact = $d89986799d1689ef$var$scope.interactStatic;
var $d89986799d1689ef$export$2e2bcd8739ae039 = $d89986799d1689ef$var$interact;
const $d89986799d1689ef$var$_global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
$d89986799d1689ef$var$scope.init($d89986799d1689ef$var$_global);

});
parcelRequire.register("h4KhJ", function(module, exports) {

$parcel$export(module.exports, "Scope", () => $c6e6b6a351153760$export$775b6bb06e53a214);

var $fIr2Q = parcelRequire("fIr2Q");

var $2ySEv = parcelRequire("2ySEv");

var $3Ilbz = parcelRequire("3Ilbz");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $iL6qQ = parcelRequire("iL6qQ");

var $fhaz1 = parcelRequire("fhaz1");

var $2yrWV = parcelRequire("2yrWV");

var $aRV67 = parcelRequire("aRV67");

var $8Wqig = parcelRequire("8Wqig");

var $3uLN1 = parcelRequire("3uLN1");

var $l1dlL = parcelRequire("l1dlL");

var $dzyo8 = parcelRequire("dzyo8");

var $hpOUN = parcelRequire("hpOUN");

var $8xhML = parcelRequire("8xhML");
class $c6e6b6a351153760$export$775b6bb06e53a214 {
    id = `__interact_scope_${Math.floor(Math.random() * 100)}`;
    isInitialized = false;
    listenerMaps = [];
    browser = (0, $fIr2Q.default);
    defaults = (0, $2ySEv.default)((0, $8xhML.defaults));
    Eventable = (0, $2yrWV.Eventable);
    actions = {
        map: {},
        phases: {
            start: true,
            move: true,
            end: true
        },
        methodDict: {},
        phaselessTypes: {}
    };
    interactStatic = (0, $8Wqig.createInteractStatic)(this);
    InteractEvent = (0, $aRV67.InteractEvent);
    Interactable;
    interactables = new (0, $l1dlL.InteractableSet)(this);
    _win;
    document;
    window;
    documents = [];
    _plugins = {
        list: [],
        map: {}
    };
    constructor(){
        const scope = this;
        this.Interactable = class extends (0, $3uLN1.Interactable) {
            get _defaults() {
                return scope.defaults;
            }
            set(options) {
                super.set(options);
                scope.fire("interactable:set", {
                    options: options,
                    interactable: this
                });
                return this;
            }
            unset() {
                super.unset();
                const index = scope.interactables.list.indexOf(this);
                if (index < 0) return;
                super.unset();
                scope.interactables.list.splice(index, 1);
                scope.fire("interactable:unset", {
                    interactable: this
                });
            }
        };
    }
    addListeners(map, id) {
        this.listenerMaps.push({
            id: id,
            map: map
        });
    }
    fire(name, arg) {
        for (const { map: { [name]: listener  }  } of this.listenerMaps){
            if (!!listener && listener(arg, this, name) === false) return false;
        }
    }
    onWindowUnload = (event)=>this.removeDocument(event.target);
    init(window) {
        return this.isInitialized ? this : $c6e6b6a351153760$export$c7d2dc180948706b(this, window);
    }
    pluginIsInstalled(plugin) {
        return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1;
    }
    usePlugin(plugin, options) {
        if (!this.isInitialized) return this;
        if (this.pluginIsInstalled(plugin)) return this;
        if (plugin.id) this._plugins.map[plugin.id] = plugin;
        this._plugins.list.push(plugin);
        if (plugin.install) plugin.install(this, options);
        if (plugin.listeners && plugin.before) {
            let index = 0;
            const len = this.listenerMaps.length;
            const before = plugin.before.reduce((acc, id)=>{
                acc[id] = true;
                acc[$c6e6b6a351153760$var$pluginIdRoot(id)] = true;
                return acc;
            }, {});
            for(; index < len; index++){
                const otherId = this.listenerMaps[index].id;
                if (before[otherId] || before[$c6e6b6a351153760$var$pluginIdRoot(otherId)]) break;
            }
            this.listenerMaps.splice(index, 0, {
                id: plugin.id,
                map: plugin.listeners
            });
        } else if (plugin.listeners) this.listenerMaps.push({
            id: plugin.id,
            map: plugin.listeners
        });
        return this;
    }
    addDocument(doc, options) {
        // do nothing if document is already known
        if (this.getDocIndex(doc) !== -1) return false;
        const window = $fhaz1.getWindow(doc);
        options = options ? (0, $cT3g2.default)({}, options) : {};
        this.documents.push({
            doc: doc,
            options: options
        });
        this.events.documents.push(doc); // don't add an unload event for the main document
        // so that the page may be cached in browser history
        if (doc !== this.document) this.events.add(window, "unload", this.onWindowUnload);
        this.fire("scope:add-document", {
            doc: doc,
            window: window,
            scope: this,
            options: options
        });
    }
    removeDocument(doc) {
        const index = this.getDocIndex(doc);
        const window = $fhaz1.getWindow(doc);
        const options = this.documents[index].options;
        this.events.remove(window, "unload", this.onWindowUnload);
        this.documents.splice(index, 1);
        this.events.documents.splice(index, 1);
        this.fire("scope:remove-document", {
            doc: doc,
            window: window,
            scope: this,
            options: options
        });
    }
    getDocIndex(doc) {
        for(let i = 0; i < this.documents.length; i++){
            if (this.documents[i].doc === doc) return i;
        }
        return -1;
    }
    getDocOptions(doc) {
        const docIndex = this.getDocIndex(doc);
        return docIndex === -1 ? null : this.documents[docIndex].options;
    }
    now() {
        return (this.window.Date || Date).now();
    }
}
function $c6e6b6a351153760$export$c7d2dc180948706b(scope, window) {
    scope.isInitialized = true;
    if ((0, $4dw5o.default).window(window)) $fhaz1.init(window);
    (0, $3Ilbz.default).init(window);
    (0, $fIr2Q.default).init(window);
    (0, $iL6qQ.default).init(window); // @ts-expect-error
    scope.window = window;
    scope.document = window.document;
    scope.usePlugin((0, $hpOUN.default));
    scope.usePlugin((0, $dzyo8.default));
    return scope;
}
function $c6e6b6a351153760$var$pluginIdRoot(id) {
    return id && id.replace(/\/.*$/, "");
}

});
parcelRequire.register("2yrWV", function(module, exports) {

$parcel$export(module.exports, "Eventable", () => $1dc46ff07ad0e23a$export$50a24153a2b87d25);

var $kIfua = parcelRequire("kIfua");

var $cT3g2 = parcelRequire("cT3g2");

var $i7xl5 = parcelRequire("i7xl5");
function $1dc46ff07ad0e23a$var$fireUntilImmediateStopped(event, listeners) {
    for (const listener of listeners){
        if (event.immediatePropagationStopped) break;
        listener(event);
    }
}
class $1dc46ff07ad0e23a$export$50a24153a2b87d25 {
    options;
    types = {};
    propagationStopped = false;
    immediatePropagationStopped = false;
    global;
    constructor(options){
        this.options = (0, $cT3g2.default)({}, options || {});
    }
    fire(event) {
        let listeners;
        const global = this.global; // Interactable#on() listeners
        // tslint:disable no-conditional-assignment
        if (listeners = this.types[event.type]) $1dc46ff07ad0e23a$var$fireUntilImmediateStopped(event, listeners);
         // interact.on() listeners
        if (!event.propagationStopped && global && (listeners = global[event.type])) $1dc46ff07ad0e23a$var$fireUntilImmediateStopped(event, listeners);
    }
    on(type, listener) {
        const listeners = (0, $i7xl5.default)(type, listener);
        for(type in listeners)this.types[type] = $kIfua.merge(this.types[type] || [], listeners[type]);
    }
    off(type, listener) {
        const listeners = (0, $i7xl5.default)(type, listener);
        for(type in listeners){
            const eventList = this.types[type];
            if (!eventList || !eventList.length) continue;
            for (const subListener of listeners[type]){
                const index = eventList.indexOf(subListener);
                if (index !== -1) eventList.splice(index, 1);
            }
        }
    }
    getRect(_element) {
        return null;
    }
}

});

parcelRequire.register("8Wqig", function(module, exports) {

$parcel$export(module.exports, "createInteractStatic", () => $682822dda7c73b16$export$825f48faa4033331);

var $fIr2Q = parcelRequire("fIr2Q");

var $jLvtZ = parcelRequire("jLvtZ");

var $4dw5o = parcelRequire("4dw5o");

var $8uh4b = parcelRequire("8uh4b");

var $hCEXH = parcelRequire("hCEXH");

var $1PTyB = parcelRequire("1PTyB");
function $682822dda7c73b16$export$825f48faa4033331(scope) {
    /**
   * ```js
   * interact('#draggable').draggable(true)
   *
   * var rectables = interact('rect')
   * rectables
   *   .gesturable(true)
   *   .on('gesturemove', function (event) {
   *       // ...
   *   })
   * ```
   *
   * The methods of this variable can be used to set elements as interactables
   * and also to change various default settings.
   *
   * Calling it as a function and passing an element or a valid CSS selector
   * string returns an Interactable object which has various methods to configure
   * it.
   *
   * @global
   *
   * @param {Element | string} target The HTML or SVG Element to interact with
   * or CSS selector
   * @return {Interactable}
   */ const interact = (target, options)=>{
        let interactable = scope.interactables.get(target, options);
        if (!interactable) {
            interactable = scope.interactables.new(target, options);
            interactable.events.global = interact.globalEvents;
        }
        return interactable;
    }; // expose the functions used to calculate multi-touch properties
    interact.getPointerAverage = $hCEXH.pointerAverage;
    interact.getTouchBBox = $hCEXH.touchBBox;
    interact.getTouchDistance = $hCEXH.touchDistance;
    interact.getTouchAngle = $hCEXH.touchAngle;
    interact.getElementRect = $jLvtZ.getElementRect;
    interact.getElementClientRect = $jLvtZ.getElementClientRect;
    interact.matchesSelector = $jLvtZ.matchesSelector;
    interact.closest = $jLvtZ.closest;
    interact.globalEvents = {}; // eslint-disable-next-line no-undef
    interact.version = "1.10.14";
    interact.scope = scope;
    /**
   * Use a plugin
   *
   * @alias module:interact.use
   *
   */ interact.use = function(plugin, options) {
        this.scope.usePlugin(plugin, options);
        return this;
    };
    /**
   * Check if an element or selector has been set with the {@link interact}
   * function
   *
   * @alias module:interact.isSet
   *
   * @param {Target} target The Element or string being searched for
   * @param {object} options
   * @return {boolean} Indicates if the element or CSS selector was previously
   * passed to interact
   */ interact.isSet = function(target, options) {
        return !!this.scope.interactables.get(target, options && options.context);
    };
    /**
   * @deprecated
   * Add a global listener for an InteractEvent or adds a DOM event to `document`
   *
   * @alias module:interact.on
   *
   * @param {string | array | object} type The types of events to listen for
   * @param {function} listener The function event (s)
   * @param {object | boolean} [options] object or useCapture flag for
   * addEventListener
   * @return {object} interact
   */ interact.on = (0, $8uh4b.warnOnce)(function on(type, listener, options) {
        if ((0, $4dw5o.default).string(type) && type.search(" ") !== -1) type = type.trim().split(/ +/);
        if ((0, $4dw5o.default).array(type)) {
            for (const eventType of type)this.on(eventType, listener, options);
            return this;
        }
        if ((0, $4dw5o.default).object(type)) {
            for(const prop in type)this.on(prop, type[prop], listener);
            return this;
        } // if it is an InteractEvent type, add listener to globalEvents
        if ((0, $1PTyB.default)(type, this.scope.actions)) {
            // if this type of event was never bound
            if (!this.globalEvents[type]) this.globalEvents[type] = [
                listener
            ];
            else this.globalEvents[type].push(listener);
        } else this.scope.events.add(this.scope.document, type, listener, {
            options: options
        });
        return this;
    }, "The interact.on() method is being deprecated");
    /**
   * @deprecated
   * Removes a global InteractEvent listener or DOM event from `document`
   *
   * @alias module:interact.off
   *
   * @param {string | array | object} type The types of events that were listened
   * for
   * @param {function} listener The listener function to be removed
   * @param {object | boolean} options [options] object or useCapture flag for
   * removeEventListener
   * @return {object} interact
   */ interact.off = (0, $8uh4b.warnOnce)(function off(type, listener, options) {
        if ((0, $4dw5o.default).string(type) && type.search(" ") !== -1) type = type.trim().split(/ +/);
        if ((0, $4dw5o.default).array(type)) {
            for (const eventType of type)this.off(eventType, listener, options);
            return this;
        }
        if ((0, $4dw5o.default).object(type)) {
            for(const prop in type)this.off(prop, type[prop], listener);
            return this;
        }
        if ((0, $1PTyB.default)(type, this.scope.actions)) {
            let index;
            if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) this.globalEvents[type].splice(index, 1);
        } else this.scope.events.remove(this.scope.document, type, listener, options);
        return this;
    }, "The interact.off() method is being deprecated");
    interact.debug = function() {
        return this.scope;
    };
    /**
   * @alias module:interact.supportsTouch
   *
   * @return {boolean} Whether or not the browser supports touch input
   */ interact.supportsTouch = function() {
        return (0, $fIr2Q.default).supportsTouch;
    };
    /**
   * @alias module:interact.supportsPointerEvent
   *
   * @return {boolean} Whether or not the browser supports PointerEvents
   */ interact.supportsPointerEvent = function() {
        return (0, $fIr2Q.default).supportsPointerEvent;
    };
    /**
   * Cancels all interactions (end events are not fired)
   *
   * @alias module:interact.stop
   *
   * @return {object} interact
   */ interact.stop = function() {
        for (const interaction of this.scope.interactions.list)interaction.stop();
        return this;
    };
    /**
   * Returns or sets the distance the pointer must be moved before an action
   * sequence occurs. This also affects tolerance for tap events.
   *
   * @alias module:interact.pointerMoveTolerance
   *
   * @param {number} [newValue] The movement from the start position must be greater than this value
   * @return {interact | number}
   */ interact.pointerMoveTolerance = function(newValue) {
        if ((0, $4dw5o.default).number(newValue)) {
            this.scope.interactions.pointerMoveTolerance = newValue;
            return this;
        }
        return this.scope.interactions.pointerMoveTolerance;
    };
    interact.addDocument = function(doc, options) {
        this.scope.addDocument(doc, options);
    };
    interact.removeDocument = function(doc) {
        this.scope.removeDocument(doc);
    };
    return interact;
}

});
parcelRequire.register("1PTyB", function(module, exports) {

$parcel$export(module.exports, "default", () => $1565a65d1ff879d3$export$2e2bcd8739ae039);
function $1565a65d1ff879d3$export$2e2bcd8739ae039(type, actions) {
    if (actions.phaselessTypes[type]) return true;
    for(const name in actions.map){
        if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) return true;
    }
    return false;
}

});


parcelRequire.register("3uLN1", function(module, exports) {

$parcel$export(module.exports, "Interactable", () => $28b93e7a897fcaf2$export$79bcc792e09118e6);

var $kIfua = parcelRequire("kIfua");

var $fIr2Q = parcelRequire("fIr2Q");

var $2ySEv = parcelRequire("2ySEv");

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $i7xl5 = parcelRequire("i7xl5");

var $fhaz1 = parcelRequire("fhaz1");

var $2yrWV = parcelRequire("2yrWV");

var $1PTyB = parcelRequire("1PTyB");
class $28b93e7a897fcaf2$export$79bcc792e09118e6 {
    /** @internal */ get _defaults() {
        return {
            base: {},
            perAction: {},
            actions: {}
        };
    }
    options;
    _actions;
    target;
    events = new (0, $2yrWV.Eventable)();
    _context;
    _win;
    _doc;
    _scopeEvents;
    /** @internal */ _rectChecker;
    /** */ constructor(target, options, defaultContext, scopeEvents){
        this._actions = options.actions;
        this.target = target;
        this._context = options.context || defaultContext;
        this._win = (0, $fhaz1.getWindow)((0, $jLvtZ.trySelector)(target) ? this._context : target);
        this._doc = this._win.document;
        this._scopeEvents = scopeEvents;
        this.set(options);
    }
    setOnEvents(actionName, phases) {
        if ((0, $4dw5o.default).func(phases.onstart)) this.on(`${actionName}start`, phases.onstart);
        if ((0, $4dw5o.default).func(phases.onmove)) this.on(`${actionName}move`, phases.onmove);
        if ((0, $4dw5o.default).func(phases.onend)) this.on(`${actionName}end`, phases.onend);
        if ((0, $4dw5o.default).func(phases.oninertiastart)) this.on(`${actionName}inertiastart`, phases.oninertiastart);
        return this;
    }
    updatePerActionListeners(actionName, prev, cur) {
        if ((0, $4dw5o.default).array(prev) || (0, $4dw5o.default).object(prev)) this.off(actionName, prev);
        if ((0, $4dw5o.default).array(cur) || (0, $4dw5o.default).object(cur)) this.on(actionName, cur);
    }
    setPerAction(actionName, options) {
        const defaults = this._defaults; // for all the default per-action options
        for(const optionName_ in options){
            const optionName = optionName_;
            const actionOptions = this.options[actionName];
            const optionValue = options[optionName]; // remove old event listeners and add new ones
            if (optionName === "listeners") this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
             // if the option value is an array
            if ((0, $4dw5o.default).array(optionValue)) actionOptions[optionName] = $kIfua.from(optionValue);
            else if ((0, $4dw5o.default).plainObject(optionValue)) {
                actionOptions[optionName] = (0, $cT3g2.default)(actionOptions[optionName] || {}, (0, $2ySEv.default)(optionValue)); // set anabled field to true if it exists in the defaults
                if ((0, $4dw5o.default).object(defaults.perAction[optionName]) && "enabled" in defaults.perAction[optionName]) actionOptions[optionName].enabled = optionValue.enabled !== false;
            } else if ((0, $4dw5o.default).bool(optionValue) && (0, $4dw5o.default).object(defaults.perAction[optionName])) actionOptions[optionName].enabled = optionValue;
            else actionOptions[optionName] = optionValue;
        }
    }
    /**
   * The default function to get an Interactables bounding rect. Can be
   * overridden using {@link Interactable.rectChecker}.
   *
   * @param {Element} [element] The element to measure.
   * @return {Rect} The object's bounding rectangle.
   */ getRect(element) {
        element = element || ((0, $4dw5o.default).element(this.target) ? this.target : null);
        if ((0, $4dw5o.default).string(this.target)) element = element || this._context.querySelector(this.target);
        return (0, $jLvtZ.getElementRect)(element);
    }
    /**
   * Returns or sets the function used to calculate the interactable's
   * element's rectangle
   *
   * @param {function} [checker] A function which returns this Interactable's
   * bounding rectangle. See {@link Interactable.getRect}
   * @return {function | object} The checker function or this Interactable
   */ rectChecker(checker) {
        if ((0, $4dw5o.default).func(checker)) {
            this._rectChecker = checker;
            this.getRect = (element)=>{
                const rect = (0, $cT3g2.default)({}, this._rectChecker(element));
                if (!("width" in rect)) {
                    rect.width = rect.right - rect.left;
                    rect.height = rect.bottom - rect.top;
                }
                return rect;
            };
            return this;
        }
        if (checker === null) {
            delete this.getRect;
            delete this._rectChecker;
            return this;
        }
        return this.getRect;
    }
    _backCompatOption(optionName, newValue) {
        if ((0, $jLvtZ.trySelector)(newValue) || (0, $4dw5o.default).object(newValue)) {
            this.options[optionName] = newValue;
            for(const action in this._actions.map)this.options[action][optionName] = newValue;
            return this;
        }
        return this.options[optionName];
    }
    /**
   * Gets or sets the origin of the Interactable's element.  The x and y
   * of the origin will be subtracted from action event coordinates.
   *
   * @param {Element | object | string} [origin] An HTML or SVG Element whose
   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'
   * or any CSS selector
   *
   * @return {object} The current origin or this Interactable
   */ origin(newValue) {
        return this._backCompatOption("origin", newValue);
    }
    /**
   * Returns or sets the mouse coordinate types used to calculate the
   * movement of the pointer.
   *
   * @param {string} [newValue] Use 'client' if you will be scrolling while
   * interacting; Use 'page' if you want autoScroll to work
   * @return {string | object} The current deltaSource or this Interactable
   */ deltaSource(newValue) {
        if (newValue === "page" || newValue === "client") {
            this.options.deltaSource = newValue;
            return this;
        }
        return this.options.deltaSource;
    }
    /**
   * Gets the selector context Node of the Interactable. The default is
   * `window.document`.
   *
   * @return {Node} The context Node of this Interactable
   */ context() {
        return this._context;
    }
    inContext(element) {
        return this._context === element.ownerDocument || (0, $jLvtZ.nodeContains)(this._context, element);
    }
    testIgnoreAllow(options, targetNode, eventTarget) {
        return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
    }
    testAllow(allowFrom, targetNode, element) {
        if (!allowFrom) return true;
        if (!(0, $4dw5o.default).element(element)) return false;
        if ((0, $4dw5o.default).string(allowFrom)) return (0, $jLvtZ.matchesUpTo)(element, allowFrom, targetNode);
        else if ((0, $4dw5o.default).element(allowFrom)) return (0, $jLvtZ.nodeContains)(allowFrom, element);
        return false;
    }
    testIgnore(ignoreFrom, targetNode, element) {
        if (!ignoreFrom || !(0, $4dw5o.default).element(element)) return false;
        if ((0, $4dw5o.default).string(ignoreFrom)) return (0, $jLvtZ.matchesUpTo)(element, ignoreFrom, targetNode);
        else if ((0, $4dw5o.default).element(ignoreFrom)) return (0, $jLvtZ.nodeContains)(ignoreFrom, element);
        return false;
    }
    /**
   * Calls listeners for the given InteractEvent type bound globally
   * and directly to this Interactable
   *
   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this
   * Interactable
   * @return {Interactable} this Interactable
   */ fire(iEvent) {
        this.events.fire(iEvent);
        return this;
    }
    _onOff(method, typeArg, listenerArg, options) {
        if ((0, $4dw5o.default).object(typeArg) && !(0, $4dw5o.default).array(typeArg)) {
            options = listenerArg;
            listenerArg = null;
        }
        const addRemove = method === "on" ? "add" : "remove";
        const listeners = (0, $i7xl5.default)(typeArg, listenerArg);
        for(let type in listeners){
            if (type === "wheel") type = (0, $fIr2Q.default).wheelEvent;
            for (const listener of listeners[type]){
                // if it is an action event type
                if ((0, $1PTyB.default)(type, this._actions)) this.events[method](type, listener);
                else if ((0, $4dw5o.default).string(this.target)) this._scopeEvents[`${addRemove}Delegate`](this.target, this._context, type, listener, options);
                else this._scopeEvents[addRemove](this.target, type, listener, options);
            }
        }
        return this;
    }
    /**
   * Binds a listener for an InteractEvent, pointerEvent or DOM event.
   *
   * @param {string | array | object} types The types of events to listen
   * for
   * @param {function | array | object} [listener] The event listener function(s)
   * @param {object | boolean} [options] options object or useCapture flag for
   * addEventListener
   * @return {Interactable} This Interactable
   */ on(types, listener, options) {
        return this._onOff("on", types, listener, options);
    }
    /**
   * Removes an InteractEvent, pointerEvent or DOM event listener.
   *
   * @param {string | array | object} types The types of events that were
   * listened for
   * @param {function | array | object} [listener] The event listener function(s)
   * @param {object | boolean} [options] options object or useCapture flag for
   * removeEventListener
   * @return {Interactable} This Interactable
   */ off(types, listener, options) {
        return this._onOff("off", types, listener, options);
    }
    /**
   * Reset the options of this Interactable
   *
   * @param {object} options The new settings to apply
   * @return {object} This Interactable
   */ set(options) {
        const defaults = this._defaults;
        if (!(0, $4dw5o.default).object(options)) options = {};
        this.options = (0, $2ySEv.default)(defaults.base);
        for(const actionName_ in this._actions.methodDict){
            const actionName = actionName_;
            const methodName = this._actions.methodDict[actionName];
            this.options[actionName] = {};
            this.setPerAction(actionName, (0, $cT3g2.default)((0, $cT3g2.default)({}, defaults.perAction), defaults.actions[actionName]));
            this[methodName](options[actionName]);
        }
        for(const setting in options)if ((0, $4dw5o.default).func(this[setting])) this[setting](options[setting]);
        return this;
    }
    /**
   * Remove this interactable from the list of interactables and remove it's
   * action capabilities and event listeners
   */ unset() {
        if ((0, $4dw5o.default).string(this.target)) // remove delegated events
        for(const type in this._scopeEvents.delegatedEvents){
            const delegated = this._scopeEvents.delegatedEvents[type];
            for(let i = delegated.length - 1; i >= 0; i--){
                const { selector: selector , context: context , listeners: listeners  } = delegated[i];
                if (selector === this.target && context === this._context) delegated.splice(i, 1);
                for(let l = listeners.length - 1; l >= 0; l--)this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1]);
            }
        }
        else this._scopeEvents.remove(this.target, "all");
    }
}

});

parcelRequire.register("l1dlL", function(module, exports) {

$parcel$export(module.exports, "InteractableSet", () => $f4d40bff54394d9c$export$2f1c2a7730ae6bab);

var $kIfua = parcelRequire("kIfua");

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");
class $f4d40bff54394d9c$export$2f1c2a7730ae6bab {
    // all set interactables
    list = [];
    selectorMap = {};
    scope;
    constructor(scope){
        this.scope = scope;
        scope.addListeners({
            "interactable:unset": ({ interactable: interactable  })=>{
                const { target: target , _context: context  } = interactable;
                const targetMappings = (0, $4dw5o.default).string(target) ? this.selectorMap[target] : target[this.scope.id];
                const targetIndex = $kIfua.findIndex(targetMappings, (m)=>m.context === context);
                if (targetMappings[targetIndex]) {
                    // Destroying mappingInfo's context and interactable
                    targetMappings[targetIndex].context = null;
                    targetMappings[targetIndex].interactable = null;
                }
                targetMappings.splice(targetIndex, 1);
            }
        });
    }
    new(target, options) {
        options = (0, $cT3g2.default)(options || {}, {
            actions: this.scope.actions
        });
        const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events);
        const mappingInfo = {
            context: interactable._context,
            interactable: interactable
        };
        this.scope.addDocument(interactable._doc);
        this.list.push(interactable);
        if ((0, $4dw5o.default).string(target)) {
            if (!this.selectorMap[target]) this.selectorMap[target] = [];
            this.selectorMap[target].push(mappingInfo);
        } else {
            if (!interactable.target[this.scope.id]) Object.defineProperty(target, this.scope.id, {
                value: [],
                configurable: true
            });
            target[this.scope.id].push(mappingInfo);
        }
        this.scope.fire("interactable:new", {
            target: target,
            options: options,
            interactable: interactable,
            win: this.scope._win
        });
        return interactable;
    }
    get(target, options) {
        const context = options && options.context || this.scope.document;
        const isSelector = (0, $4dw5o.default).string(target);
        const targetMappings = isSelector ? this.selectorMap[target] : target[this.scope.id];
        if (!targetMappings) return null;
        const found = $kIfua.find(targetMappings, (m)=>m.context === context && (isSelector || m.interactable.inContext(target)));
        return found && found.interactable;
    }
    forEachMatch(node, callback) {
        for (const interactable of this.list){
            let ret;
            if (((0, $4dw5o.default).string(interactable.target) ? (0, $4dw5o.default).element(node) && $jLvtZ.matchesSelector(node, interactable.target) : node === interactable.target) && interactable.inContext(node)) ret = callback(interactable);
            if (ret !== undefined) return ret;
        }
    }
}

});

parcelRequire.register("dzyo8", function(module, exports) {

$parcel$export(module.exports, "default", () => $9e19380eba6f5078$export$2e2bcd8739ae039);

var $kIfua = parcelRequire("kIfua");

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $aLC5p = parcelRequire("aLC5p");

var $hCEXH = parcelRequire("hCEXH");
function $9e19380eba6f5078$var$install(scope) {
    var _scope$document;
    const targets = [];
    const delegatedEvents = {};
    const documents = [];
    const eventsMethods = {
        add: add,
        remove: remove,
        addDelegate: addDelegate,
        removeDelegate: removeDelegate,
        delegateListener: delegateListener,
        delegateUseCapture: delegateUseCapture,
        delegatedEvents: delegatedEvents,
        documents: documents,
        targets: targets,
        supportsOptions: false,
        supportsPassive: false
    }; // check if browser supports passive events and options arg
    (_scope$document = scope.document) == null || _scope$document.createElement("div").addEventListener("test", null, {
        get capture () {
            return eventsMethods.supportsOptions = true;
        },
        get passive () {
            return eventsMethods.supportsPassive = true;
        }
    });
    scope.events = eventsMethods;
    function add(eventTarget, type, listener, optionalArg) {
        const options = $9e19380eba6f5078$var$getOptions(optionalArg);
        let target = $kIfua.find(targets, (t)=>t.eventTarget === eventTarget);
        if (!target) {
            target = {
                eventTarget: eventTarget,
                events: {}
            };
            targets.push(target);
        }
        if (!target.events[type]) target.events[type] = [];
        if (eventTarget.addEventListener && !$kIfua.contains(target.events[type], listener)) {
            eventTarget.addEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
            target.events[type].push(listener);
        }
    }
    function remove(eventTarget, type, listener, optionalArg) {
        const options = $9e19380eba6f5078$var$getOptions(optionalArg);
        const targetIndex = $kIfua.findIndex(targets, (t)=>t.eventTarget === eventTarget);
        const target = targets[targetIndex];
        if (!target || !target.events) return;
        if (type === "all") {
            for(type in target.events)if (target.events.hasOwnProperty(type)) remove(eventTarget, type, "all");
            return;
        }
        let typeIsEmpty = false;
        const typeListeners = target.events[type];
        if (typeListeners) {
            if (listener === "all") {
                for(let i = typeListeners.length - 1; i >= 0; i--)remove(eventTarget, type, typeListeners[i], options);
                return;
            } else {
                for(let i = 0; i < typeListeners.length; i++)if (typeListeners[i] === listener) {
                    eventTarget.removeEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
                    typeListeners.splice(i, 1);
                    if (typeListeners.length === 0) {
                        delete target.events[type];
                        typeIsEmpty = true;
                    }
                    break;
                }
            }
        }
        if (typeIsEmpty && !Object.keys(target.events).length) targets.splice(targetIndex, 1);
    }
    function addDelegate(selector, context, type, listener, optionalArg) {
        const options = $9e19380eba6f5078$var$getOptions(optionalArg);
        if (!delegatedEvents[type]) {
            delegatedEvents[type] = []; // add delegate listener functions
            for (const doc of documents){
                add(doc, type, delegateListener);
                add(doc, type, delegateUseCapture, true);
            }
        }
        const delegates = delegatedEvents[type];
        let delegate = $kIfua.find(delegates, (d)=>d.selector === selector && d.context === context);
        if (!delegate) {
            delegate = {
                selector: selector,
                context: context,
                listeners: []
            };
            delegates.push(delegate);
        }
        delegate.listeners.push([
            listener,
            options
        ]);
    }
    function removeDelegate(selector, context, type, listener, optionalArg) {
        const options = $9e19380eba6f5078$var$getOptions(optionalArg);
        const delegates = delegatedEvents[type];
        let matchFound = false;
        let index;
        if (!delegates) return; // count from last index of delegated to 0
        for(index = delegates.length - 1; index >= 0; index--){
            const cur = delegates[index]; // look for matching selector and context Node
            if (cur.selector === selector && cur.context === context) {
                const { listeners: listeners  } = cur; // each item of the listeners array is an array: [function, capture, passive]
                for(let i = listeners.length - 1; i >= 0; i--){
                    const [fn, { capture: capture , passive: passive  }] = listeners[i]; // check if the listener functions and capture and passive flags match
                    if (fn === listener && capture === options.capture && passive === options.passive) {
                        // remove the listener from the array of listeners
                        listeners.splice(i, 1); // if all listeners for this target have been removed
                        // remove the target from the delegates array
                        if (!listeners.length) {
                            delegates.splice(index, 1); // remove delegate function from context
                            remove(context, type, delegateListener);
                            remove(context, type, delegateUseCapture, true);
                        } // only remove one listener
                        matchFound = true;
                        break;
                    }
                }
                if (matchFound) break;
            }
        }
    } // bound to the interactable context when a DOM event
    // listener is added to a selector interactable
    function delegateListener(event, optionalArg) {
        const options = $9e19380eba6f5078$var$getOptions(optionalArg);
        const fakeEvent = new $9e19380eba6f5078$var$FakeEvent(event);
        const delegates = delegatedEvents[event.type];
        const [eventTarget] = $hCEXH.getEventTargets(event);
        let element = eventTarget; // climb up document tree looking for selector matches
        while((0, $4dw5o.default).element(element)){
            for(let i = 0; i < delegates.length; i++){
                const cur = delegates[i];
                const { selector: selector , context: context  } = cur;
                if ($jLvtZ.matchesSelector(element, selector) && $jLvtZ.nodeContains(context, eventTarget) && $jLvtZ.nodeContains(context, element)) {
                    const { listeners: listeners  } = cur;
                    fakeEvent.currentTarget = element;
                    for (const [fn, { capture: capture , passive: passive  }] of listeners)if (capture === options.capture && passive === options.passive) fn(fakeEvent);
                }
            }
            element = $jLvtZ.parentNode(element);
        }
    }
    function delegateUseCapture(event) {
        return delegateListener.call(this, event, true);
    } // for type inferrence
    return eventsMethods;
}
class $9e19380eba6f5078$var$FakeEvent {
    currentTarget;
    originalEvent;
    type;
    constructor(originalEvent){
        this.originalEvent = originalEvent; // duplicate the event so that currentTarget can be changed
        (0, $aLC5p.default)(this, originalEvent);
    }
    preventOriginalDefault() {
        this.originalEvent.preventDefault();
    }
    stopPropagation() {
        this.originalEvent.stopPropagation();
    }
    stopImmediatePropagation() {
        this.originalEvent.stopImmediatePropagation();
    }
}
function $9e19380eba6f5078$var$getOptions(param) {
    if (!(0, $4dw5o.default).object(param)) return {
        capture: !!param,
        passive: false
    };
    const options = (0, $cT3g2.default)({}, param);
    options.capture = !!param.capture;
    options.passive = !!param.passive;
    return options;
}
var $9e19380eba6f5078$export$2e2bcd8739ae039 = {
    id: "events",
    install: $9e19380eba6f5078$var$install
};

});

parcelRequire.register("hpOUN", function(module, exports) {

$parcel$export(module.exports, "default", () => $cadc44216417330d$export$2e2bcd8739ae039);

var $fIr2Q = parcelRequire("fIr2Q");

var $3Ilbz = parcelRequire("3Ilbz");

var $jLvtZ = parcelRequire("jLvtZ");

var $hCEXH = parcelRequire("hCEXH");

var $fVJnv = parcelRequire("fVJnv");

var $1WRoq = parcelRequire("1WRoq");

var $3ro5m = parcelRequire("3ro5m");
const $cadc44216417330d$var$methodNames = [
    "pointerDown",
    "pointerMove",
    "pointerUp",
    "updatePointer",
    "removePointer",
    "windowBlur"
];
function $cadc44216417330d$var$install(scope) {
    const listeners = {};
    for (const method of $cadc44216417330d$var$methodNames)listeners[method] = $cadc44216417330d$var$doOnInteractions(method, scope);
    const pEventTypes = (0, $fIr2Q.default).pEventTypes;
    let docEvents;
    if ((0, $3Ilbz.default).PointerEvent) docEvents = [
        {
            type: pEventTypes.down,
            listener: releasePointersOnRemovedEls
        },
        {
            type: pEventTypes.down,
            listener: listeners.pointerDown
        },
        {
            type: pEventTypes.move,
            listener: listeners.pointerMove
        },
        {
            type: pEventTypes.up,
            listener: listeners.pointerUp
        },
        {
            type: pEventTypes.cancel,
            listener: listeners.pointerUp
        }
    ];
    else docEvents = [
        {
            type: "mousedown",
            listener: listeners.pointerDown
        },
        {
            type: "mousemove",
            listener: listeners.pointerMove
        },
        {
            type: "mouseup",
            listener: listeners.pointerUp
        },
        {
            type: "touchstart",
            listener: releasePointersOnRemovedEls
        },
        {
            type: "touchstart",
            listener: listeners.pointerDown
        },
        {
            type: "touchmove",
            listener: listeners.pointerMove
        },
        {
            type: "touchend",
            listener: listeners.pointerUp
        },
        {
            type: "touchcancel",
            listener: listeners.pointerUp
        }
    ];
    docEvents.push({
        type: "blur",
        listener (event) {
            for (const interaction of scope.interactions.list)interaction.documentBlur(event);
        }
    }); // for ignoring browser's simulated mouse events
    scope.prevTouchTime = 0;
    scope.Interaction = class extends (0, $fVJnv.default) {
        get pointerMoveTolerance() {
            return scope.interactions.pointerMoveTolerance;
        }
        set pointerMoveTolerance(value) {
            scope.interactions.pointerMoveTolerance = value;
        }
        _now() {
            return scope.now();
        }
    };
    scope.interactions = {
        // all active and idle interactions
        list: [],
        new (options) {
            options.scopeFire = (name, arg)=>scope.fire(name, arg);
            const interaction = new scope.Interaction(options);
            scope.interactions.list.push(interaction);
            return interaction;
        },
        listeners: listeners,
        docEvents: docEvents,
        pointerMoveTolerance: 1
    };
    function releasePointersOnRemovedEls() {
        // for all inactive touch interactions with pointers down
        for (const interaction of scope.interactions.list){
            if (!interaction.pointerIsDown || interaction.pointerType !== "touch" || interaction._interacting) continue;
             // if a pointer is down on an element that is no longer in the DOM tree
            for (const pointer of interaction.pointers)if (!scope.documents.some(({ doc: doc  })=>(0, $jLvtZ.nodeContains)(doc, pointer.downTarget))) // remove the pointer from the interaction
            interaction.removePointer(pointer.pointer, pointer.event);
        }
    }
    scope.usePlugin((0, $1WRoq.default));
}
function $cadc44216417330d$var$doOnInteractions(method, scope) {
    return function(event) {
        const interactions1 = scope.interactions.list;
        const pointerType = $hCEXH.getPointerType(event);
        const [eventTarget, curEventTarget] = $hCEXH.getEventTargets(event);
        const matches = []; // [ [pointer, interaction], ...]
        if (/^touch/.test(event.type)) {
            scope.prevTouchTime = scope.now(); // @ts-expect-error
            for (const changedTouch of event.changedTouches){
                const pointer = changedTouch;
                const pointerId = $hCEXH.getPointerId(pointer);
                const searchDetails = {
                    pointer: pointer,
                    pointerId: pointerId,
                    pointerType: pointerType,
                    eventType: event.type,
                    eventTarget: eventTarget,
                    curEventTarget: curEventTarget,
                    scope: scope
                };
                const interaction = $cadc44216417330d$var$getInteraction(searchDetails);
                matches.push([
                    searchDetails.pointer,
                    searchDetails.eventTarget,
                    searchDetails.curEventTarget,
                    interaction
                ]);
            }
        } else {
            let invalidPointer = false;
            if (!(0, $fIr2Q.default).supportsPointerEvent && /mouse/.test(event.type)) {
                // ignore mouse events while touch interactions are active
                for(let i = 0; i < interactions1.length && !invalidPointer; i++)invalidPointer = interactions1[i].pointerType !== "mouse" && interactions1[i].pointerIsDown;
                 // try to ignore mouse events that are simulated by the browser
                // after a touch event
                invalidPointer = invalidPointer || scope.now() - scope.prevTouchTime < 500 || event.timeStamp === 0;
            }
            if (!invalidPointer) {
                const searchDetails = {
                    pointer: event,
                    pointerId: $hCEXH.getPointerId(event),
                    pointerType: pointerType,
                    eventType: event.type,
                    curEventTarget: curEventTarget,
                    eventTarget: eventTarget,
                    scope: scope
                };
                const interaction = $cadc44216417330d$var$getInteraction(searchDetails);
                matches.push([
                    searchDetails.pointer,
                    searchDetails.eventTarget,
                    searchDetails.curEventTarget,
                    interaction
                ]);
            }
        } // eslint-disable-next-line no-shadow
        for (const [pointer, eventTarget1, curEventTarget1, interaction] of matches)interaction[method](pointer, event, eventTarget1, curEventTarget1);
    };
}
function $cadc44216417330d$var$getInteraction(searchDetails) {
    const { pointerType: pointerType , scope: scope  } = searchDetails;
    const foundInteraction = (0, $3ro5m.default).search(searchDetails);
    const signalArg = {
        interaction: foundInteraction,
        searchDetails: searchDetails
    };
    scope.fire("interactions:find", signalArg);
    return signalArg.interaction || scope.interactions.new({
        pointerType: pointerType
    });
}
function $cadc44216417330d$var$onDocSignal({ doc: doc , scope: scope , options: options  }, eventMethodName) {
    const { interactions: { docEvents: docEvents  } , events: events  } = scope;
    const eventMethod = events[eventMethodName];
    if (scope.browser.isIOS && !options.events) options.events = {
        passive: false
    };
     // delegate event listener
    for(const eventType in events.delegatedEvents){
        eventMethod(doc, eventType, events.delegateListener);
        eventMethod(doc, eventType, events.delegateUseCapture, true);
    }
    const eventOptions = options && options.events;
    for (const { type: type , listener: listener  } of docEvents)eventMethod(doc, type, listener, eventOptions);
}
const $cadc44216417330d$var$interactions = {
    id: "core/interactions",
    install: $cadc44216417330d$var$install,
    listeners: {
        "scope:add-document": (arg)=>$cadc44216417330d$var$onDocSignal(arg, "add"),
        "scope:remove-document": (arg)=>$cadc44216417330d$var$onDocSignal(arg, "remove"),
        "interactable:unset": ({ interactable: interactable  }, scope)=>{
            // Stop and destroy related interactions when an Interactable is unset
            for(let i = scope.interactions.list.length - 1; i >= 0; i--){
                const interaction = scope.interactions.list[i];
                if (interaction.interactable !== interactable) continue;
                interaction.stop();
                scope.fire("interactions:destroy", {
                    interaction: interaction
                });
                interaction.destroy();
                if (scope.interactions.list.length > 2) scope.interactions.list.splice(i, 1);
            }
        }
    },
    onDocSignal: $cadc44216417330d$var$onDocSignal,
    doOnInteractions: $cadc44216417330d$var$doOnInteractions,
    methodNames: $cadc44216417330d$var$methodNames
};
var $cadc44216417330d$export$2e2bcd8739ae039 = $cadc44216417330d$var$interactions;

});
parcelRequire.register("3ro5m", function(module, exports) {

$parcel$export(module.exports, "default", () => $28169392692c990a$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");
const $28169392692c990a$var$finder = {
    methodOrder: [
        "simulationResume",
        "mouseOrPen",
        "hasPointer",
        "idle"
    ],
    search (details) {
        for (const method of $28169392692c990a$var$finder.methodOrder){
            const interaction = $28169392692c990a$var$finder[method](details);
            if (interaction) return interaction;
        }
        return null;
    },
    // try to resume simulation with a new pointer
    simulationResume ({ pointerType: pointerType , eventType: eventType , eventTarget: eventTarget , scope: scope  }) {
        if (!/down|start/i.test(eventType)) return null;
        for (const interaction of scope.interactions.list){
            let element = eventTarget;
            if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) while(element){
                // if the element is the interaction element
                if (element === interaction.element) return interaction;
                element = $jLvtZ.parentNode(element);
            }
        }
        return null;
    },
    // if it's a mouse or pen interaction
    mouseOrPen ({ pointerId: pointerId , pointerType: pointerType , eventType: eventType , scope: scope  }) {
        if (pointerType !== "mouse" && pointerType !== "pen") return null;
        let firstNonActive;
        for (const interaction of scope.interactions.list)if (interaction.pointerType === pointerType) {
            // if it's a down event, skip interactions with running simulations
            if (interaction.simulation && !$28169392692c990a$var$hasPointerId(interaction, pointerId)) continue;
             // if the interaction is active, return it immediately
            if (interaction.interacting()) return interaction;
            else if (!firstNonActive) firstNonActive = interaction;
        }
         // if no active mouse interaction was found use the first inactive mouse
        // interaction
        if (firstNonActive) return firstNonActive;
         // find any mouse or pen interaction.
        // ignore the interaction if the eventType is a *down, and a simulation
        // is active
        for (const interaction1 of scope.interactions.list){
            if (interaction1.pointerType === pointerType && !(/down/i.test(eventType) && interaction1.simulation)) return interaction1;
        }
        return null;
    },
    // get interaction that has this pointer
    hasPointer ({ pointerId: pointerId , scope: scope  }) {
        for (const interaction of scope.interactions.list){
            if ($28169392692c990a$var$hasPointerId(interaction, pointerId)) return interaction;
        }
        return null;
    },
    // get first idle interaction with a matching pointerType
    idle ({ pointerType: pointerType , scope: scope  }) {
        for (const interaction of scope.interactions.list){
            // if there's already a pointer held down
            if (interaction.pointers.length === 1) {
                const target = interaction.interactable; // don't add this pointer if there is a target interactable and it
                // isn't gesturable
                if (target && !(target.options.gesture && target.options.gesture.enabled)) continue;
            } else if (interaction.pointers.length >= 2) continue;
            if (!interaction.interacting() && pointerType === interaction.pointerType) return interaction;
        }
        return null;
    }
};
function $28169392692c990a$var$hasPointerId(interaction, pointerId) {
    return interaction.pointers.some(({ id: id  })=>id === pointerId);
}
var $28169392692c990a$export$2e2bcd8739ae039 = $28169392692c990a$var$finder;

});




parcelRequire.register("8P9Xs", function(module, exports) {

$parcel$export(module.exports, "default", () => $66cacf94c0923549$export$2e2bcd8739ae039);

var $6WfnK = parcelRequire("6WfnK");

var $iskqZ = parcelRequire("iskqZ");

var $htFb1 = parcelRequire("htFb1");
const $66cacf94c0923549$var$modifiers = {
    id: "modifiers",
    install (scope) {
        const { interactStatic: interact  } = scope;
        scope.usePlugin((0, $htFb1.default));
        scope.usePlugin((0, $6WfnK.default));
        interact.modifiers = (0, $iskqZ.default); // for backwrads compatibility
        for(const type in 0, $iskqZ.default){
            const { _defaults: _defaults , _methods: _methods  } = (0, $iskqZ.default)[type];
            _defaults._methods = _methods;
            scope.defaults.perAction[type] = _defaults;
        }
    }
};
var $66cacf94c0923549$export$2e2bcd8739ae039 = $66cacf94c0923549$var$modifiers;

});
parcelRequire.register("6WfnK", function(module, exports) {

$parcel$export(module.exports, "default", () => $50d417666b8047de$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $680ur = parcelRequire("680ur");
const $50d417666b8047de$var$snappersPlugin = {
    id: "snappers",
    install (scope) {
        const { interactStatic: interact  } = scope;
        interact.snappers = (0, $cT3g2.default)(interact.snappers || {}, $680ur);
        interact.createSnapGrid = interact.snappers.grid;
    }
};
var $50d417666b8047de$export$2e2bcd8739ae039 = $50d417666b8047de$var$snappersPlugin;

});
parcelRequire.register("680ur", function(module, exports) {

$parcel$export(module.exports, "edgeTarget", () => (parcelRequire("lcMe3")).default);
$parcel$export(module.exports, "elements", () => (parcelRequire("US40M")).default);
$parcel$export(module.exports, "grid", () => (parcelRequire("bABSk")).default);

var $lcMe3 = parcelRequire("lcMe3");

var $US40M = parcelRequire("US40M");

var $bABSk = parcelRequire("bABSk");

});
parcelRequire.register("lcMe3", function(module, exports) {

$parcel$export(module.exports, "default", () => $f700208ebf8afbb2$export$2e2bcd8739ae039);
var $f700208ebf8afbb2$export$2e2bcd8739ae039 = ()=>{};

});

parcelRequire.register("US40M", function(module, exports) {

$parcel$export(module.exports, "default", () => $0aaf2b0094c2f96f$export$2e2bcd8739ae039);
var $0aaf2b0094c2f96f$export$2e2bcd8739ae039 = ()=>{};

});

parcelRequire.register("bABSk", function(module, exports) {

$parcel$export(module.exports, "default", () => $87006fb7aef4e8c4$export$2e2bcd8739ae039);
var $87006fb7aef4e8c4$export$2e2bcd8739ae039 = (grid)=>{
    const coordFields = [
        [
            "x",
            "y"
        ],
        [
            "left",
            "top"
        ],
        [
            "right",
            "bottom"
        ],
        [
            "width",
            "height"
        ]
    ].filter(([xField, yField])=>xField in grid || yField in grid);
    const gridFunc = (x, y)=>{
        const { range: range , limits: limits = {
            left: -Infinity,
            right: Infinity,
            top: -Infinity,
            bottom: Infinity
        } , offset: offset = {
            x: 0,
            y: 0
        }  } = grid;
        const result = {
            range: range,
            grid: grid,
            x: null,
            y: null
        };
        for (const [xField, yField] of coordFields){
            const gridx = Math.round((x - offset.x) / grid[xField]);
            const gridy = Math.round((y - offset.y) / grid[yField]);
            result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid[xField] + offset.x));
            result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid[yField] + offset.y));
        }
        return result;
    };
    gridFunc.grid = grid;
    gridFunc.coordFields = coordFields;
    return gridFunc;
};

});



parcelRequire.register("iskqZ", function(module, exports) {

$parcel$export(module.exports, "default", () => $d6fab152eef7a0d9$export$2e2bcd8739ae039);

var $5C06M = parcelRequire("5C06M");

var $kKfMq = parcelRequire("kKfMq");

var $lM7us = parcelRequire("lM7us");

var $cCZL9 = parcelRequire("cCZL9");

var $41nQl = parcelRequire("41nQl");

var $fnDJF = parcelRequire("fnDJF");

var $kKfMq = parcelRequire("kKfMq");

var $92j7A = parcelRequire("92j7A");

var $hI2V0 = parcelRequire("hI2V0");

var $lOvTV = parcelRequire("lOvTV");

var $kKfMq = parcelRequire("kKfMq");

var $kKfMq = parcelRequire("kKfMq");
var $d6fab152eef7a0d9$export$2e2bcd8739ae039 = {
    aspectRatio: $5C06M.default,
    restrictEdges: $lM7us.default,
    restrict: $cCZL9.default,
    restrictRect: $41nQl.default,
    restrictSize: $fnDJF.default,
    snapEdges: $92j7A.default,
    snap: $hI2V0.default,
    snapSize: $lOvTV.default,
    spring: $kKfMq.default,
    avoid: $kKfMq.default,
    transform: $kKfMq.default,
    rubberband: $kKfMq.default
};

});
parcelRequire.register("5C06M", function(module, exports) {

$parcel$export(module.exports, "default", () => $416095e65203673d$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $5ZvQW = parcelRequire("5ZvQW");

var $l77dP = parcelRequire("l77dP");

var $htFb1 = parcelRequire("htFb1");
const $416095e65203673d$export$c5706146bc63213 = {
    start (arg) {
        const { state: state , rect: rect , edges: originalEdges , pageCoords: coords  } = arg;
        let { ratio: ratio  } = state.options;
        const { equalDelta: equalDelta , modifiers: modifiers  } = state.options;
        if (ratio === "preserve") ratio = rect.width / rect.height;
        state.startCoords = (0, $cT3g2.default)({}, coords);
        state.startRect = (0, $cT3g2.default)({}, rect);
        state.ratio = ratio;
        state.equalDelta = equalDelta;
        const linkedEdges = state.linkedEdges = {
            top: originalEdges.top || originalEdges.left && !originalEdges.bottom,
            left: originalEdges.left || originalEdges.top && !originalEdges.right,
            bottom: originalEdges.bottom || originalEdges.right && !originalEdges.top,
            right: originalEdges.right || originalEdges.bottom && !originalEdges.left
        };
        state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right);
        if (state.equalDelta) {
            const sign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1);
            state.edgeSign = {
                x: sign,
                y: sign
            };
        } else state.edgeSign = {
            x: linkedEdges.left ? -1 : 1,
            y: linkedEdges.top ? -1 : 1
        };
        (0, $cT3g2.default)(arg.edges, linkedEdges);
        if (!modifiers || !modifiers.length) return;
        const subModification = new (0, $l77dP.default)(arg.interaction);
        subModification.copyFrom(arg.interaction.modification);
        subModification.prepareStates(modifiers);
        state.subModification = subModification;
        subModification.startAll({
            ...arg
        });
    },
    set (arg) {
        const { state: state , rect: rect , coords: coords  } = arg;
        const initialCoords = (0, $cT3g2.default)({}, coords);
        const aspectMethod = state.equalDelta ? $416095e65203673d$var$setEqualDelta : $416095e65203673d$var$setRatio;
        aspectMethod(state, state.xIsPrimaryAxis, coords, rect);
        if (!state.subModification) return null;
        const correctedRect = (0, $cT3g2.default)({}, rect);
        (0, $5ZvQW.addEdges)(state.linkedEdges, correctedRect, {
            x: coords.x - initialCoords.x,
            y: coords.y - initialCoords.y
        });
        const result = state.subModification.setAll({
            ...arg,
            rect: correctedRect,
            edges: state.linkedEdges,
            pageCoords: coords,
            prevCoords: coords,
            prevRect: correctedRect
        });
        const { delta: delta  } = result;
        if (result.changed) {
            const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y); // do aspect modification again with critical edge axis as primary
            aspectMethod(state, xIsCriticalAxis, result.coords, result.rect);
            (0, $cT3g2.default)(coords, result.coords);
        }
        return result.eventProps;
    },
    defaults: {
        ratio: "preserve",
        equalDelta: false,
        modifiers: [],
        enabled: false
    }
};
function $416095e65203673d$var$setEqualDelta({ startCoords: startCoords , edgeSign: edgeSign  }, xIsPrimaryAxis, coords) {
    if (xIsPrimaryAxis) coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign.y;
    else coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign.x;
}
function $416095e65203673d$var$setRatio({ startRect: startRect , startCoords: startCoords , ratio: ratio , edgeSign: edgeSign  }, xIsPrimaryAxis, coords, rect) {
    if (xIsPrimaryAxis) {
        const newHeight = rect.width / ratio;
        coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign.y;
    } else {
        const newWidth = rect.height * ratio;
        coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign.x;
    }
}
var $416095e65203673d$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($416095e65203673d$export$c5706146bc63213, "aspectRatio");

});

parcelRequire.register("kKfMq", function(module, exports) {

$parcel$export(module.exports, "default", () => $f1a4581a8fdfe1d0$export$2e2bcd8739ae039);
const $f1a4581a8fdfe1d0$var$noop = ()=>{};
$f1a4581a8fdfe1d0$var$noop._defaults = {};
var $f1a4581a8fdfe1d0$export$2e2bcd8739ae039 = $f1a4581a8fdfe1d0$var$noop;

});


parcelRequire.register("lM7us", function(module, exports) {

$parcel$export(module.exports, "restrictEdges", () => $fda3e419597a3020$export$a82b809266e17f73);
$parcel$export(module.exports, "default", () => $fda3e419597a3020$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $5ZvQW = parcelRequire("5ZvQW");

var $htFb1 = parcelRequire("htFb1");

var $cCZL9 = parcelRequire("cCZL9");
const $fda3e419597a3020$var$noInner = {
    top: Infinity,
    left: Infinity,
    bottom: -Infinity,
    right: -Infinity
};
const $fda3e419597a3020$var$noOuter = {
    top: -Infinity,
    left: -Infinity,
    bottom: Infinity,
    right: Infinity
};
function $fda3e419597a3020$var$start({ interaction: interaction , startOffset: startOffset , state: state  }) {
    const { options: options  } = state;
    let offset;
    if (options) {
        const offsetRect = (0, $cCZL9.getRestrictionRect)(options.offset, interaction, interaction.coords.start.page);
        offset = $5ZvQW.rectToXY(offsetRect);
    }
    offset = offset || {
        x: 0,
        y: 0
    };
    state.offset = {
        top: offset.y + startOffset.top,
        left: offset.x + startOffset.left,
        bottom: offset.y - startOffset.bottom,
        right: offset.x - startOffset.right
    };
}
function $fda3e419597a3020$var$set({ coords: coords , edges: edges , interaction: interaction , state: state  }) {
    const { offset: offset , options: options  } = state;
    if (!edges) return;
    const page = (0, $cT3g2.default)({}, coords);
    const inner = (0, $cCZL9.getRestrictionRect)(options.inner, interaction, page) || {};
    const outer = (0, $cCZL9.getRestrictionRect)(options.outer, interaction, page) || {};
    $fda3e419597a3020$var$fixRect(inner, $fda3e419597a3020$var$noInner);
    $fda3e419597a3020$var$fixRect(outer, $fda3e419597a3020$var$noOuter);
    if (edges.top) coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);
    else if (edges.bottom) coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom);
    if (edges.left) coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);
    else if (edges.right) coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right);
}
function $fda3e419597a3020$var$fixRect(rect, defaults1) {
    for (const edge of [
        "top",
        "left",
        "bottom",
        "right"
    ])if (!(edge in rect)) rect[edge] = defaults1[edge];
    return rect;
}
const $fda3e419597a3020$var$defaults = {
    inner: null,
    outer: null,
    offset: null,
    endOnly: false,
    enabled: false
};
const $fda3e419597a3020$export$a82b809266e17f73 = {
    noInner: $fda3e419597a3020$var$noInner,
    noOuter: $fda3e419597a3020$var$noOuter,
    start: $fda3e419597a3020$var$start,
    set: $fda3e419597a3020$var$set,
    defaults: $fda3e419597a3020$var$defaults
};
var $fda3e419597a3020$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($fda3e419597a3020$export$a82b809266e17f73, "restrictEdges");

});
parcelRequire.register("cCZL9", function(module, exports) {

$parcel$export(module.exports, "getRestrictionRect", () => $9318f0c7796492f5$export$65f16e4759e2d0dd);
$parcel$export(module.exports, "restrict", () => $9318f0c7796492f5$export$b7e8b7f0ba562fda);
$parcel$export(module.exports, "default", () => $9318f0c7796492f5$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $5ZvQW = parcelRequire("5ZvQW");

var $htFb1 = parcelRequire("htFb1");
function $9318f0c7796492f5$var$start({ rect: rect , startOffset: startOffset , state: state , interaction: interaction , pageCoords: pageCoords  }) {
    const { options: options  } = state;
    const { elementRect: elementRect  } = options;
    const offset = (0, $cT3g2.default)({
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
    }, options.offset || {});
    if (rect && elementRect) {
        const restriction = $9318f0c7796492f5$export$65f16e4759e2d0dd(options.restriction, interaction, pageCoords);
        if (restriction) {
            const widthDiff = restriction.right - restriction.left - rect.width;
            const heightDiff = restriction.bottom - restriction.top - rect.height;
            if (widthDiff < 0) {
                offset.left += widthDiff;
                offset.right += widthDiff;
            }
            if (heightDiff < 0) {
                offset.top += heightDiff;
                offset.bottom += heightDiff;
            }
        }
        offset.left += startOffset.left - rect.width * elementRect.left;
        offset.top += startOffset.top - rect.height * elementRect.top;
        offset.right += startOffset.right - rect.width * (1 - elementRect.right);
        offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom);
    }
    state.offset = offset;
}
function $9318f0c7796492f5$var$set({ coords: coords , interaction: interaction , state: state  }) {
    const { options: options , offset: offset  } = state;
    const restriction = $9318f0c7796492f5$export$65f16e4759e2d0dd(options.restriction, interaction, coords);
    if (!restriction) return;
    const rect = $5ZvQW.xywhToTlbr(restriction);
    coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left);
    coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top);
}
function $9318f0c7796492f5$export$65f16e4759e2d0dd(value, interaction, coords) {
    if ((0, $4dw5o.default).func(value)) return $5ZvQW.resolveRectLike(value, interaction.interactable, interaction.element, [
        coords.x,
        coords.y,
        interaction
    ]);
    else return $5ZvQW.resolveRectLike(value, interaction.interactable, interaction.element);
}
const $9318f0c7796492f5$var$defaults = {
    restriction: null,
    elementRect: null,
    offset: null,
    endOnly: false,
    enabled: false
};
const $9318f0c7796492f5$export$b7e8b7f0ba562fda = {
    start: $9318f0c7796492f5$var$start,
    set: $9318f0c7796492f5$var$set,
    defaults: $9318f0c7796492f5$var$defaults
};
var $9318f0c7796492f5$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($9318f0c7796492f5$export$b7e8b7f0ba562fda, "restrict");

});


parcelRequire.register("41nQl", function(module, exports) {

$parcel$export(module.exports, "default", () => $2ed9c02ea87c11b9$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $htFb1 = parcelRequire("htFb1");

var $cCZL9 = parcelRequire("cCZL9");
const $2ed9c02ea87c11b9$var$defaults = (0, $cT3g2.default)({
    get elementRect () {
        return {
            top: 0,
            left: 0,
            bottom: 1,
            right: 1
        };
    },
    set elementRect (_){}
}, (0, $cCZL9.restrict).defaults);
const $2ed9c02ea87c11b9$export$a44b48ad8ee149b = {
    start: (0, $cCZL9.restrict).start,
    set: (0, $cCZL9.restrict).set,
    defaults: $2ed9c02ea87c11b9$var$defaults
};
var $2ed9c02ea87c11b9$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($2ed9c02ea87c11b9$export$a44b48ad8ee149b, "restrictRect");

});

parcelRequire.register("fnDJF", function(module, exports) {

$parcel$export(module.exports, "default", () => $b327d3a15978737e$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $5ZvQW = parcelRequire("5ZvQW");

var $htFb1 = parcelRequire("htFb1");

var $lM7us = parcelRequire("lM7us");

var $cCZL9 = parcelRequire("cCZL9");
const $b327d3a15978737e$var$noMin = {
    width: -Infinity,
    height: -Infinity
};
const $b327d3a15978737e$var$noMax = {
    width: Infinity,
    height: Infinity
};
function $b327d3a15978737e$var$start(arg) {
    return (0, $lM7us.restrictEdges).start(arg);
}
function $b327d3a15978737e$var$set(arg) {
    const { interaction: interaction , state: state , rect: rect , edges: edges  } = arg;
    const { options: options  } = state;
    if (!edges) return;
    const minSize = $5ZvQW.tlbrToXywh((0, $cCZL9.getRestrictionRect)(options.min, interaction, arg.coords)) || $b327d3a15978737e$var$noMin;
    const maxSize = $5ZvQW.tlbrToXywh((0, $cCZL9.getRestrictionRect)(options.max, interaction, arg.coords)) || $b327d3a15978737e$var$noMax;
    state.options = {
        endOnly: options.endOnly,
        inner: (0, $cT3g2.default)({}, (0, $lM7us.restrictEdges).noInner),
        outer: (0, $cT3g2.default)({}, (0, $lM7us.restrictEdges).noOuter)
    };
    if (edges.top) {
        state.options.inner.top = rect.bottom - minSize.height;
        state.options.outer.top = rect.bottom - maxSize.height;
    } else if (edges.bottom) {
        state.options.inner.bottom = rect.top + minSize.height;
        state.options.outer.bottom = rect.top + maxSize.height;
    }
    if (edges.left) {
        state.options.inner.left = rect.right - minSize.width;
        state.options.outer.left = rect.right - maxSize.width;
    } else if (edges.right) {
        state.options.inner.right = rect.left + minSize.width;
        state.options.outer.right = rect.left + maxSize.width;
    }
    (0, $lM7us.restrictEdges).set(arg);
    state.options = options;
}
const $b327d3a15978737e$var$defaults = {
    min: null,
    max: null,
    endOnly: false,
    enabled: false
};
const $b327d3a15978737e$export$cad5e97f488a5ba7 = {
    start: $b327d3a15978737e$var$start,
    set: $b327d3a15978737e$var$set,
    defaults: $b327d3a15978737e$var$defaults
};
var $b327d3a15978737e$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($b327d3a15978737e$export$cad5e97f488a5ba7, "restrictSize");

});

parcelRequire.register("92j7A", function(module, exports) {

$parcel$export(module.exports, "default", () => $69432212df95bdb6$export$2e2bcd8739ae039);

var $2ySEv = parcelRequire("2ySEv");

var $cT3g2 = parcelRequire("cT3g2");

var $htFb1 = parcelRequire("htFb1");

var $lOvTV = parcelRequire("lOvTV");
function $69432212df95bdb6$var$start(arg) {
    const { edges: edges  } = arg;
    if (!edges) return null;
    arg.state.targetFields = arg.state.targetFields || [
        [
            edges.left ? "left" : "right",
            edges.top ? "top" : "bottom"
        ]
    ];
    return (0, $lOvTV.snapSize).start(arg);
}
const $69432212df95bdb6$export$c8e0692acc2bec = {
    start: $69432212df95bdb6$var$start,
    set: (0, $lOvTV.snapSize).set,
    defaults: (0, $cT3g2.default)((0, $2ySEv.default)((0, $lOvTV.snapSize).defaults), {
        targets: null,
        range: null,
        offset: {
            x: 0,
            y: 0
        }
    })
};
var $69432212df95bdb6$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($69432212df95bdb6$export$c8e0692acc2bec, "snapEdges");

});
parcelRequire.register("lOvTV", function(module, exports) {

$parcel$export(module.exports, "snapSize", () => $fe1703599ea92095$export$2b1340c10fd454d5);
$parcel$export(module.exports, "default", () => $fe1703599ea92095$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $4dw5o = parcelRequire("4dw5o");

var $htFb1 = parcelRequire("htFb1");

var $hI2V0 = parcelRequire("hI2V0");
function $fe1703599ea92095$var$start(arg) {
    const { state: state , edges: edges  } = arg;
    const { options: options  } = state;
    if (!edges) return null;
    arg.state = {
        options: {
            targets: null,
            relativePoints: [
                {
                    x: edges.left ? 0 : 1,
                    y: edges.top ? 0 : 1
                }
            ],
            offset: options.offset || "self",
            origin: {
                x: 0,
                y: 0
            },
            range: options.range
        }
    };
    state.targetFields = state.targetFields || [
        [
            "width",
            "height"
        ],
        [
            "x",
            "y"
        ]
    ];
    (0, $hI2V0.snap).start(arg);
    state.offsets = arg.state.offsets;
    arg.state = state;
}
function $fe1703599ea92095$var$set(arg) {
    const { interaction: interaction , state: state , coords: coords  } = arg;
    const { options: options , offsets: offsets  } = state;
    const relative = {
        x: coords.x - offsets[0].x,
        y: coords.y - offsets[0].y
    };
    state.options = (0, $cT3g2.default)({}, options);
    state.options.targets = [];
    for (const snapTarget of options.targets || []){
        let target;
        if ((0, $4dw5o.default).func(snapTarget)) target = snapTarget(relative.x, relative.y, interaction);
        else target = snapTarget;
        if (!target) continue;
        for (const [xField, yField] of state.targetFields)if (xField in target || yField in target) {
            target.x = target[xField];
            target.y = target[yField];
            break;
        }
        state.options.targets.push(target);
    }
    const returnValue = (0, $hI2V0.snap).set(arg);
    state.options = options;
    return returnValue;
}
const $fe1703599ea92095$var$defaults = {
    range: Infinity,
    targets: null,
    offset: null,
    endOnly: false,
    enabled: false
};
const $fe1703599ea92095$export$2b1340c10fd454d5 = {
    start: $fe1703599ea92095$var$start,
    set: $fe1703599ea92095$var$set,
    defaults: $fe1703599ea92095$var$defaults
};
var $fe1703599ea92095$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($fe1703599ea92095$export$2b1340c10fd454d5, "snapSize");

});
parcelRequire.register("hI2V0", function(module, exports) {

$parcel$export(module.exports, "snap", () => $ce48cf40fed3c58a$export$51a0620f7a28532b);
$parcel$export(module.exports, "default", () => $ce48cf40fed3c58a$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");

var $5bWyX = parcelRequire("5bWyX");

var $djSxD = parcelRequire("djSxD");

var $4dw5o = parcelRequire("4dw5o");

var $5ZvQW = parcelRequire("5ZvQW");

var $htFb1 = parcelRequire("htFb1");
function $ce48cf40fed3c58a$var$start(arg) {
    const { interaction: interaction , interactable: interactable , element: element , rect: rect , state: state , startOffset: startOffset  } = arg;
    const { options: options  } = state;
    const origin = options.offsetWithOrigin ? $ce48cf40fed3c58a$var$getOrigin(arg) : {
        x: 0,
        y: 0
    };
    let snapOffset;
    if (options.offset === "startCoords") snapOffset = {
        x: interaction.coords.start.page.x,
        y: interaction.coords.start.page.y
    };
    else {
        const offsetRect = (0, $5ZvQW.resolveRectLike)(options.offset, interactable, element, [
            interaction
        ]);
        snapOffset = (0, $5ZvQW.rectToXY)(offsetRect) || {
            x: 0,
            y: 0
        };
        snapOffset.x += origin.x;
        snapOffset.y += origin.y;
    }
    const { relativePoints: relativePoints  } = options;
    state.offsets = rect && relativePoints && relativePoints.length ? relativePoints.map((relativePoint, index)=>({
            index: index,
            relativePoint: relativePoint,
            x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,
            y: startOffset.top - rect.height * relativePoint.y + snapOffset.y
        })) : [
        {
            index: 0,
            relativePoint: null,
            x: snapOffset.x,
            y: snapOffset.y
        }
    ];
}
function $ce48cf40fed3c58a$var$set(arg) {
    const { interaction: interaction , coords: coords , state: state  } = arg;
    const { options: options , offsets: offsets  } = state;
    const origin = (0, $5bWyX.default)(interaction.interactable, interaction.element, interaction.prepared.name);
    const page = (0, $cT3g2.default)({}, coords);
    const targets = [];
    if (!options.offsetWithOrigin) {
        page.x -= origin.x;
        page.y -= origin.y;
    }
    for (const offset of offsets){
        const relativeX = page.x - offset.x;
        const relativeY = page.y - offset.y;
        for(let index = 0, len = options.targets.length; index < len; index++){
            const snapTarget = options.targets[index];
            let target;
            if ((0, $4dw5o.default).func(snapTarget)) target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index);
            else target = snapTarget;
            if (!target) continue;
            targets.push({
                x: ((0, $4dw5o.default).number(target.x) ? target.x : relativeX) + offset.x,
                y: ((0, $4dw5o.default).number(target.y) ? target.y : relativeY) + offset.y,
                range: (0, $4dw5o.default).number(target.range) ? target.range : options.range,
                source: snapTarget,
                index: index,
                offset: offset
            });
        }
    }
    const closest = {
        target: null,
        inRange: false,
        distance: 0,
        range: 0,
        delta: {
            x: 0,
            y: 0
        }
    };
    for (const target of targets){
        const range = target.range;
        const dx = target.x - page.x;
        const dy = target.y - page.y;
        const distance = (0, $djSxD.default)(dx, dy);
        let inRange = distance <= range; // Infinite targets count as being out of range
        // compared to non infinite ones that are in range
        if (range === Infinity && closest.inRange && closest.range !== Infinity) inRange = false;
        if (!closest.target || (inRange ? closest.inRange && range !== Infinity ? distance / range < closest.distance / closest.range : range === Infinity && closest.range !== Infinity || distance < closest.distance : !closest.inRange && distance < closest.distance)) {
            closest.target = target;
            closest.distance = distance;
            closest.range = range;
            closest.inRange = inRange;
            closest.delta.x = dx;
            closest.delta.y = dy;
        }
    }
    if (closest.inRange) {
        coords.x = closest.target.x;
        coords.y = closest.target.y;
    }
    state.closest = closest;
    return closest;
}
function $ce48cf40fed3c58a$var$getOrigin(arg) {
    const { element: element  } = arg.interaction;
    const optionsOrigin = (0, $5ZvQW.rectToXY)((0, $5ZvQW.resolveRectLike)(arg.state.options.origin, null, null, [
        element
    ]));
    const origin = optionsOrigin || (0, $5bWyX.default)(arg.interactable, element, arg.interaction.prepared.name);
    return origin;
}
const $ce48cf40fed3c58a$var$defaults = {
    range: Infinity,
    targets: null,
    offset: null,
    offsetWithOrigin: true,
    origin: null,
    relativePoints: null,
    endOnly: false,
    enabled: false
};
const $ce48cf40fed3c58a$export$51a0620f7a28532b = {
    start: $ce48cf40fed3c58a$var$start,
    set: $ce48cf40fed3c58a$var$set,
    defaults: $ce48cf40fed3c58a$var$defaults
};
var $ce48cf40fed3c58a$export$2e2bcd8739ae039 = (0, $htFb1.makeModifier)($ce48cf40fed3c58a$export$51a0620f7a28532b, "snap");

});





parcelRequire.register("gPPRo", function(module, exports) {

$parcel$export(module.exports, "default", () => $c419a318b71cd679$export$2e2bcd8739ae039);

var $1xO4W = parcelRequire("1xO4W");

var $dznAl = parcelRequire("dznAl");

var $dHei2 = parcelRequire("dHei2");
const $c419a318b71cd679$var$plugin = {
    id: "pointer-events",
    install (scope) {
        scope.usePlugin($1xO4W);
        scope.usePlugin((0, $dznAl.default));
        scope.usePlugin((0, $dHei2.default));
    }
};
var $c419a318b71cd679$export$2e2bcd8739ae039 = $c419a318b71cd679$var$plugin;

});
parcelRequire.register("1xO4W", function(module, exports) {

$parcel$defineInteropFlag(module.exports);

$parcel$export(module.exports, "default", () => $11ffb8150300f618$export$2e2bcd8739ae039);

var $jLvtZ = parcelRequire("jLvtZ");

var $cT3g2 = parcelRequire("cT3g2");

var $5bWyX = parcelRequire("5bWyX");

var $bA6Zk = parcelRequire("bA6Zk");
const $11ffb8150300f618$var$defaults = {
    holdDuration: 600,
    ignoreFrom: null,
    allowFrom: null,
    origin: {
        x: 0,
        y: 0
    }
};
const $11ffb8150300f618$var$pointerEvents = {
    id: "pointer-events/base",
    before: [
        "inertia",
        "modifiers",
        "auto-start",
        "actions"
    ],
    install: $11ffb8150300f618$var$install,
    listeners: {
        "interactions:new": $11ffb8150300f618$var$addInteractionProps,
        "interactions:update-pointer": $11ffb8150300f618$var$addHoldInfo,
        "interactions:move": $11ffb8150300f618$var$moveAndClearHold,
        "interactions:down": (arg, scope)=>{
            $11ffb8150300f618$var$downAndStartHold(arg, scope);
            $11ffb8150300f618$var$fire(arg, scope);
        },
        "interactions:up": (arg, scope)=>{
            $11ffb8150300f618$var$clearHold(arg);
            $11ffb8150300f618$var$fire(arg, scope);
            $11ffb8150300f618$var$tapAfterUp(arg, scope);
        },
        "interactions:cancel": (arg, scope)=>{
            $11ffb8150300f618$var$clearHold(arg);
            $11ffb8150300f618$var$fire(arg, scope);
        }
    },
    PointerEvent: $bA6Zk.PointerEvent,
    fire: $11ffb8150300f618$var$fire,
    collectEventTargets: $11ffb8150300f618$var$collectEventTargets,
    defaults: $11ffb8150300f618$var$defaults,
    types: {
        down: true,
        move: true,
        up: true,
        cancel: true,
        tap: true,
        doubletap: true,
        hold: true
    }
};
function $11ffb8150300f618$var$fire(arg, scope) {
    const { interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget , type: type , targets: targets = $11ffb8150300f618$var$collectEventTargets(arg, scope)  } = arg;
    const pointerEvent = new (0, $bA6Zk.PointerEvent)(type, pointer, event, eventTarget, interaction, scope.now());
    scope.fire("pointerEvents:new", {
        pointerEvent: pointerEvent
    });
    const signalArg = {
        interaction: interaction,
        pointer: pointer,
        event: event,
        eventTarget: eventTarget,
        targets: targets,
        type: type,
        pointerEvent: pointerEvent
    };
    for(let i = 0; i < targets.length; i++){
        const target = targets[i];
        for(const prop in target.props || {})pointerEvent[prop] = target.props[prop];
        const origin = (0, $5bWyX.default)(target.eventable, target.node);
        pointerEvent._subtractOrigin(origin);
        pointerEvent.eventable = target.eventable;
        pointerEvent.currentTarget = target.node;
        target.eventable.fire(pointerEvent);
        pointerEvent._addOrigin(origin);
        if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].node !== pointerEvent.currentTarget) break;
    }
    scope.fire("pointerEvents:fired", signalArg);
    if (type === "tap") {
        // if pointerEvent should make a double tap, create and fire a doubletap
        // PointerEvent and use that as the prevTap
        const prevTap = pointerEvent.double ? $11ffb8150300f618$var$fire({
            interaction: interaction,
            pointer: pointer,
            event: event,
            eventTarget: eventTarget,
            type: "doubletap"
        }, scope) : pointerEvent;
        interaction.prevTap = prevTap;
        interaction.tapTime = prevTap.timeStamp;
    }
    return pointerEvent;
}
function $11ffb8150300f618$var$collectEventTargets({ interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget , type: type  }, scope) {
    const pointerIndex = interaction.getPointerIndex(pointer);
    const pointerInfo = interaction.pointers[pointerIndex]; // do not fire a tap event if the pointer was moved before being lifted
    if (type === "tap" && (interaction.pointerWasMoved || !(pointerInfo && pointerInfo.downTarget === eventTarget))) return [];
    const path = $jLvtZ.getPath(eventTarget);
    const signalArg = {
        interaction: interaction,
        pointer: pointer,
        event: event,
        eventTarget: eventTarget,
        type: type,
        path: path,
        targets: [],
        node: null
    };
    for (const node of path){
        signalArg.node = node;
        scope.fire("pointerEvents:collect-targets", signalArg);
    }
    if (type === "hold") signalArg.targets = signalArg.targets.filter((target)=>{
        var _interaction$pointers;
        return target.eventable.options.holdDuration === ((_interaction$pointers = interaction.pointers[pointerIndex]) == null ? void 0 : _interaction$pointers.hold.duration);
    });
    return signalArg.targets;
}
function $11ffb8150300f618$var$addInteractionProps({ interaction: interaction  }) {
    interaction.prevTap = null; // the most recent tap event on this interaction
    interaction.tapTime = 0; // time of the most recent tap event
}
function $11ffb8150300f618$var$addHoldInfo({ down: down , pointerInfo: pointerInfo  }) {
    if (!down && pointerInfo.hold) return;
    pointerInfo.hold = {
        duration: Infinity,
        timeout: null
    };
}
function $11ffb8150300f618$var$clearHold({ interaction: interaction , pointerIndex: pointerIndex  }) {
    const hold = interaction.pointers[pointerIndex].hold;
    if (hold && hold.timeout) {
        clearTimeout(hold.timeout);
        hold.timeout = null;
    }
}
function $11ffb8150300f618$var$moveAndClearHold(arg, scope) {
    const { interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget , duplicate: duplicate  } = arg;
    if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {
        if (interaction.pointerIsDown) $11ffb8150300f618$var$clearHold(arg);
        $11ffb8150300f618$var$fire({
            interaction: interaction,
            pointer: pointer,
            event: event,
            eventTarget: eventTarget,
            type: "move"
        }, scope);
    }
}
function $11ffb8150300f618$var$downAndStartHold({ interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget , pointerIndex: pointerIndex  }, scope) {
    const timer = interaction.pointers[pointerIndex].hold;
    const path = $jLvtZ.getPath(eventTarget);
    const signalArg = {
        interaction: interaction,
        pointer: pointer,
        event: event,
        eventTarget: eventTarget,
        type: "hold",
        targets: [],
        path: path,
        node: null
    };
    for (const node of path){
        signalArg.node = node;
        scope.fire("pointerEvents:collect-targets", signalArg);
    }
    if (!signalArg.targets.length) return;
    let minDuration = Infinity;
    for (const target of signalArg.targets){
        const holdDuration = target.eventable.options.holdDuration;
        if (holdDuration < minDuration) minDuration = holdDuration;
    }
    timer.duration = minDuration;
    timer.timeout = setTimeout(()=>{
        $11ffb8150300f618$var$fire({
            interaction: interaction,
            eventTarget: eventTarget,
            pointer: pointer,
            event: event,
            type: "hold"
        }, scope);
    }, minDuration);
}
function $11ffb8150300f618$var$tapAfterUp({ interaction: interaction , pointer: pointer , event: event , eventTarget: eventTarget  }, scope) {
    if (!interaction.pointerWasMoved) $11ffb8150300f618$var$fire({
        interaction: interaction,
        eventTarget: eventTarget,
        pointer: pointer,
        event: event,
        type: "tap"
    }, scope);
}
function $11ffb8150300f618$var$install(scope) {
    scope.pointerEvents = $11ffb8150300f618$var$pointerEvents;
    scope.defaults.actions.pointerEvents = $11ffb8150300f618$var$pointerEvents.defaults;
    (0, $cT3g2.default)(scope.actions.phaselessTypes, $11ffb8150300f618$var$pointerEvents.types);
}
var $11ffb8150300f618$export$2e2bcd8739ae039 = $11ffb8150300f618$var$pointerEvents;

});
parcelRequire.register("bA6Zk", function(module, exports) {

$parcel$export(module.exports, "PointerEvent", () => $86e87a2f2506e552$export$2e2bcd8739ae039);

var $iAJcJ = parcelRequire("iAJcJ");
parcelRequire("hCEXH");
var $aLC5p = parcelRequire("aLC5p");
var $hCEXH = parcelRequire("hCEXH");
class $86e87a2f2506e552$export$2e2bcd8739ae039 extends (0, $iAJcJ.BaseEvent) {
    /** */ constructor(type, pointer, event, eventTarget, interaction, timeStamp){
        super(interaction);
        $aLC5p.default(this, event);
        if (event !== pointer) $aLC5p.default(this, pointer);
        this.timeStamp = timeStamp;
        this.originalEvent = event;
        this.type = type;
        this.pointerId = $hCEXH.getPointerId(pointer);
        this.pointerType = $hCEXH.getPointerType(pointer);
        this.target = eventTarget;
        this.currentTarget = null;
        if (type === "tap") {
            const pointerIndex = interaction.getPointerIndex(pointer);
            this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime;
            const interval = this.timeStamp - interaction.tapTime;
            this.double = !!interaction.prevTap && interaction.prevTap.type !== "doubletap" && interaction.prevTap.target === this.target && interval < 500;
        } else if (type === "doubletap") {
            this.dt = pointer.timeStamp - interaction.tapTime;
            this.double = true;
        }
    }
    _subtractOrigin({ x: originX , y: originY  }) {
        this.pageX -= originX;
        this.pageY -= originY;
        this.clientX -= originX;
        this.clientY -= originY;
        return this;
    }
    _addOrigin({ x: originX , y: originY  }) {
        this.pageX += originX;
        this.pageY += originY;
        this.clientX += originX;
        this.clientY += originY;
        return this;
    }
    /**
   * Prevent the default behaviour of the original Event
   */ preventDefault() {
        this.originalEvent.preventDefault();
    }
}

});


parcelRequire.register("dznAl", function(module, exports) {

$parcel$export(module.exports, "default", () => $9e10d6c89ce75319$export$2e2bcd8739ae039);

var $1xO4W = parcelRequire("1xO4W");
function $9e10d6c89ce75319$var$install(scope) {
    scope.usePlugin((0, $1xO4W.default));
    const { pointerEvents: pointerEvents  } = scope; // don't repeat by default
    pointerEvents.defaults.holdRepeatInterval = 0;
    pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true;
}
function $9e10d6c89ce75319$var$onNew({ pointerEvent: pointerEvent  }) {
    if (pointerEvent.type !== "hold") return;
    pointerEvent.count = (pointerEvent.count || 0) + 1;
}
function $9e10d6c89ce75319$var$onFired({ interaction: interaction , pointerEvent: pointerEvent , eventTarget: eventTarget , targets: targets  }, scope) {
    if (pointerEvent.type !== "hold" || !targets.length) return; // get the repeat interval from the first eventable
    const interval = targets[0].eventable.options.holdRepeatInterval; // don't repeat if the interval is 0 or less
    if (interval <= 0) return; // set a timeout to fire the holdrepeat event
    interaction.holdIntervalHandle = setTimeout(()=>{
        scope.pointerEvents.fire({
            interaction: interaction,
            eventTarget: eventTarget,
            type: "hold",
            pointer: pointerEvent,
            event: pointerEvent
        }, scope);
    }, interval);
}
function $9e10d6c89ce75319$var$endHoldRepeat({ interaction: interaction  }) {
    // set the interaction's holdStopTime property
    // to stop further holdRepeat events
    if (interaction.holdIntervalHandle) {
        clearInterval(interaction.holdIntervalHandle);
        interaction.holdIntervalHandle = null;
    }
}
const $9e10d6c89ce75319$var$holdRepeat = {
    id: "pointer-events/holdRepeat",
    install: $9e10d6c89ce75319$var$install,
    listeners: [
        "move",
        "up",
        "cancel",
        "endall"
    ].reduce((acc, enderTypes)=>{
        acc[`pointerEvents:${enderTypes}`] = $9e10d6c89ce75319$var$endHoldRepeat;
        return acc;
    }, {
        "pointerEvents:new": $9e10d6c89ce75319$var$onNew,
        "pointerEvents:fired": $9e10d6c89ce75319$var$onFired
    })
};
var $9e10d6c89ce75319$export$2e2bcd8739ae039 = $9e10d6c89ce75319$var$holdRepeat;

});

parcelRequire.register("dHei2", function(module, exports) {

$parcel$export(module.exports, "default", () => $9f8a603191e69eb9$export$2e2bcd8739ae039);

var $cT3g2 = parcelRequire("cT3g2");
function $9f8a603191e69eb9$var$install(scope) {
    const { Interactable: Interactable  } = scope;
    Interactable.prototype.pointerEvents = $9f8a603191e69eb9$var$pointerEventsMethod;
    const __backCompatOption = Interactable.prototype._backCompatOption;
    Interactable.prototype._backCompatOption = function(optionName, newValue) {
        const ret = __backCompatOption.call(this, optionName, newValue);
        if (ret === this) this.events.options[optionName] = newValue;
        return ret;
    };
}
function $9f8a603191e69eb9$var$pointerEventsMethod(options) {
    (0, $cT3g2.default)(this.events.options, options);
    return this;
}
const $9f8a603191e69eb9$var$plugin = {
    id: "pointer-events/interactableTargets",
    install: $9f8a603191e69eb9$var$install,
    listeners: {
        "pointerEvents:collect-targets": ({ targets: targets , node: node , type: type , eventTarget: eventTarget  }, scope)=>{
            scope.interactables.forEachMatch(node, (interactable)=>{
                const eventable = interactable.events;
                const options = eventable.options;
                if (eventable.types[type] && eventable.types[type].length && interactable.testIgnoreAllow(options, node, eventTarget)) targets.push({
                    node: node,
                    eventable: eventable,
                    props: {
                        interactable: interactable
                    }
                });
            });
        },
        "interactable:new": ({ interactable: interactable  })=>{
            interactable.events.getRect = function(element) {
                return interactable.getRect(element);
            };
        },
        "interactable:set": ({ interactable: interactable , options: options  }, scope)=>{
            (0, $cT3g2.default)(interactable.events.options, scope.pointerEvents.defaults);
            (0, $cT3g2.default)(interactable.events.options, options.pointerEvents || {});
        }
    }
};
var $9f8a603191e69eb9$export$2e2bcd8739ae039 = $9f8a603191e69eb9$var$plugin;

});


parcelRequire.register("svDd8", function(module, exports) {

$parcel$export(module.exports, "default", () => $055b26fbada85b18$export$2e2bcd8739ae039);

var $kIfua = parcelRequire("kIfua");

var $4dw5o = parcelRequire("4dw5o");

var $8uh4b = parcelRequire("8uh4b");

var $hCEXH = parcelRequire("hCEXH");

var $5ZvQW = parcelRequire("5ZvQW");
function $055b26fbada85b18$export$4b3e715f166fdd78(scope) {
    const { Interactable: /** @lends Interactable */ Interactable  } = scope;
    scope.actions.phases.reflow = true;
    /**
   * ```js
   * const interactable = interact(target)
   * const drag = { name: drag, axis: 'x' }
   * const resize = { name: resize, edges: { left: true, bottom: true }
   *
   * interactable.reflow(drag)
   * interactable.reflow(resize)
   * ```
   *
   * Start an action sequence to re-apply modifiers, check drops, etc.
   *
   * @param { Object } action The action to begin
   * @param { string } action.name The name of the action
   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended
   */ Interactable.prototype.reflow = function(action) {
        return $055b26fbada85b18$var$doReflow(this, action, scope);
    };
}
function $055b26fbada85b18$var$doReflow(interactable, action, scope) {
    const elements = (0, $4dw5o.default).string(interactable.target) ? $kIfua.from(interactable._context.querySelectorAll(interactable.target)) : [
        interactable.target
    ]; // tslint:disable-next-line variable-name
    const Promise = scope.window.Promise;
    const promises = Promise ? [] : null;
    for (const element of elements){
        const rect = interactable.getRect(element);
        if (!rect) break;
        const runningInteraction = $kIfua.find(scope.interactions.list, (interaction)=>{
            return interaction.interacting() && interaction.interactable === interactable && interaction.element === element && interaction.prepared.name === action.name;
        });
        let reflowPromise;
        if (runningInteraction) {
            runningInteraction.move();
            if (promises) reflowPromise = runningInteraction._reflowPromise || new Promise((resolve)=>{
                runningInteraction._reflowResolve = resolve;
            });
        } else {
            const xywh = (0, $5ZvQW.tlbrToXywh)(rect);
            const coords = {
                page: {
                    x: xywh.x,
                    y: xywh.y
                },
                client: {
                    x: xywh.x,
                    y: xywh.y
                },
                timeStamp: scope.now()
            };
            const event = $hCEXH.coordsToEvent(coords);
            reflowPromise = $055b26fbada85b18$var$startReflow(scope, interactable, element, action, event);
        }
        if (promises) promises.push(reflowPromise);
    }
    return promises && Promise.all(promises).then(()=>interactable);
}
function $055b26fbada85b18$var$startReflow(scope, interactable, element, action, event) {
    const interaction = scope.interactions.new({
        pointerType: "reflow"
    });
    const signalArg = {
        interaction: interaction,
        event: event,
        pointer: event,
        eventTarget: element,
        phase: "reflow"
    };
    interaction.interactable = interactable;
    interaction.element = element;
    interaction.prevEvent = event;
    interaction.updatePointer(event, event, element, true);
    $hCEXH.setZeroCoords(interaction.coords.delta);
    (0, $8uh4b.copyAction)(interaction.prepared, action);
    interaction._doPhase(signalArg);
    const { Promise: Promise  } = scope.window;
    const reflowPromise = Promise ? new Promise((resolve)=>{
        interaction._reflowResolve = resolve;
    }) : undefined;
    interaction._reflowPromise = reflowPromise;
    interaction.start(action, interactable, element);
    if (interaction._interacting) {
        interaction.move(signalArg);
        interaction.end(event);
    } else {
        interaction.stop();
        interaction._reflowResolve();
    }
    interaction.removePointer(event, event);
    return reflowPromise;
}
const $055b26fbada85b18$var$reflow = {
    id: "reflow",
    install: $055b26fbada85b18$export$4b3e715f166fdd78,
    listeners: {
        // remove completed reflow interactions
        "interactions:stop": ({ interaction: interaction  }, scope)=>{
            if (interaction.pointerType === "reflow") {
                if (interaction._reflowResolve) interaction._reflowResolve();
                $kIfua.remove(scope.interactions.list, interaction);
            }
        }
    }
};
var $055b26fbada85b18$export$2e2bcd8739ae039 = $055b26fbada85b18$var$reflow;

});


var $be851a047ba833dd$export$d16c275374097133;
(function(AudioModule1) {
    let audios;
    AudioModule1.play = (src)=>{
        if (!audios || !(src in audios)) {
            let audio = new Audio(src);
            if (!audios) audios = {};
            audios[src] = audio;
            audio.onended = ()=>{
                delete audios[src];
            };
            audio.play();
            return true;
        } else return false;
    };
})($be851a047ba833dd$export$d16c275374097133 || ($be851a047ba833dd$export$d16c275374097133 = {}));


var $66369552d2da71b5$export$80e45fb591232624;
(function(JuelModule1) {
    JuelModule1.audio = (0, $be851a047ba833dd$export$d16c275374097133);
})($66369552d2da71b5$export$80e45fb591232624 || ($66369552d2da71b5$export$80e45fb591232624 = {}));


var $9742dbc094643ff0$exports = {};
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */ (function(global, factory) {
    "use strict";
    if (typeof $9742dbc094643ff0$exports === "object") // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    $9742dbc094643ff0$exports = global.document ? factory(global, true) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    };
    else factory(global);
// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : $9742dbc094643ff0$exports, function(window1, noGlobal) {
    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";
    var arr1 = [];
    var getProto = Object.getPrototypeOf;
    var slice1 = arr1.slice;
    var flat = arr1.flat ? function(array) {
        return arr1.flat.call(array);
    } : function(array) {
        return arr1.concat.apply([], array);
    };
    var push1 = arr1.push;
    var indexOf1 = arr1.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn1 = class2type.hasOwnProperty;
    var fnToString = hasOwn1.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support1 = {};
    var isFunction = function isFunction(obj) {
        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
        // Plus for old WebKit, typeof returns "function" for HTML collections
        // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };
    var document1 = window1.document;
    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };
    function DOMEval(code, node, doc) {
        doc = doc || document1;
        var i, val, script = doc.createElement("script");
        script.text = code;
        if (node) for(i in preservedScriptAttributes){
            // Support: Firefox 64+, Edge 18+
            // Some browsers don't support the "nonce" property on scripts.
            // On the other hand, just using `getAttribute` is not enough as
            // the `nonce` attribute is reset to an empty string whenever it
            // becomes browsing-context connected.
            // See https://github.com/whatwg/html/issues/2369
            // See https://html.spec.whatwg.org/#nonce-attributes
            // The `node.getAttribute` check was added for the sake of
            // `jQuery.globalEval` so that it can fake a nonce-containing node
            // via an object.
            val = node[i] || node.getAttribute && node.getAttribute(i);
            if (val) script.setAttribute(i, val);
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
        if (obj == null) return obj + "";
        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module
    var version = "3.6.0", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice1.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return all the elements in a clean array
            if (num == null) return slice1.call(this);
            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice1.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        even: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return (i + 1) % 2;
            }));
        },
        odd: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return i % 2;
            }));
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [
                this[j]
            ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push1,
        sort: arr1.sort,
        splice: arr1.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) target = {};
        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for(; i < length; i++){
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) // Extend the base object
            for(name in options){
                copy = options[name];
                // Prevent Object.prototype pollution
                // Prevent never-ending loop
                if (name === "__proto__" || target === copy) continue;
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    src = target[name];
                    // Ensure proper type for the source value
                    if (copyIsArray && !Array.isArray(src)) clone = [];
                    else if (!copyIsArray && !jQuery.isPlainObject(src)) clone = {};
                    else clone = src;
                    copyIsArray = false;
                    // Never move original objects, clone them
                    target[name] = jQuery.extend(deep, clone, copy);
                // Don't bring in undefined values
                } else if (copy !== undefined) target[name] = copy;
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isPlainObject: function(obj) {
            var proto, Ctor;
            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") return false;
            proto = getProto(obj);
            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) return true;
            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn1.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
            var name;
            for(name in obj)return false;
            return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
            DOMEval(code, {
                nonce: options && options.nonce
            }, doc);
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for(; i < length; i++){
                    if (callback.call(obj[i], i, obj[i]) === false) break;
                }
            } else for(i in obj){
                if (callback.call(obj[i], i, obj[i]) === false) break;
            }
            return obj;
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) jQuery.merge(ret, typeof arr === "string" ? [
                    arr
                ] : arr);
                else push1.call(ret, arr);
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf1.call(arr, elem, i);
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for(; j < len; j++)first[i++] = second[j];
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for(; i < length; i++){
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) matches.push(elems[i]);
            }
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for(; i < length; i++){
                    value = callback(elems[i], i, arg);
                    if (value != null) ret.push(value);
                }
            // Go through every key on the object,
            } else for(i in elems){
                value = callback(elems[i], i, arg);
                if (value != null) ret.push(value);
            }
            // Flatten any nested arrays
            return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support1
    });
    if (typeof Symbol === "function") jQuery.fn[Symbol.iterator] = arr1[Symbol.iterator];
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) return false;
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle1 = /*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */ function(window) {
        var i1, support, Expr, getText, isXML1, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem1, documentIsHTML, rbuggyQSA, rbuggyMatches, matches1, contains, // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) hasDuplicate = true;
            return 0;
        }, // Instance methods
        hasOwn = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push = arr2.push, slice = arr2.slice, // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for(; i < len; i++){
                if (list[i] === elem) return i;
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
        identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
        // or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 0x10000;
            return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
            nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
            high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        }, // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if (ch === "\0") return "\uFFFD";
                // Control characters and (dependent upon position) numbers get escaped as code points
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        }, // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        }, inDisabledFieldset = addCombinator(function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
        }, {
            dir: "parentNode",
            next: "legend"
        });
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr2 = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            // eslint-disable-next-line no-unused-expressions
            arr2[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr2.length ? // Leverage slice if possible
                function(target, els) {
                    pushNative.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length, i = 0;
                    // Can't trust NodeList.length
                    while(target[j++] = els[i++]);
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;
            results = results || [];
            // Return early from calls with invalid selector or context
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) return results;
            // Try to shortcut find operations (as opposed to filters) in HTML documents
            if (!seed) {
                setDocument(context);
                context = context || document;
                if (documentIsHTML) {
                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        // ID selector
                        if (m = match[1]) {
                            // Document context
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else return results;
                            // Element context
                            } else // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        // Type selector
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        // Class selector
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    // Take advantage of querySelectorAll
                    if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                        newSelector = selector;
                        newContext = context;
                        // qSA considers elements outside a scoping root when evaluating child or
                        // descendant combinators, which is not what we want.
                        // In such cases, we work around the behavior by prefixing every selector in the
                        // list with an ID selector referencing the scope context.
                        // The technique has to be used as well when a leading combinator is used
                        // as such selectors are not recognized by querySelectorAll.
                        // Thanks to Andrew Dupont for this technique.
                        if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                            // Expand context for sibling selectors
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                            // We can use :scope instead of the ID hack if the browser
                            // supports it & if we're not changing the context.
                            if (newContext !== context || !support.scope) {
                                // Capture the context ID, setting it first if necessary
                                if (nid = context.getAttribute("id")) nid = nid.replace(rcssescape, fcssescape);
                                else context.setAttribute("id", nid = expando);
                            }
                            // Prefix every selector in the list
                            groups = tokenize(selector);
                            i = groups.length;
                            while(i--)groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                            newSelector = groups.join(",");
                        }
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                            nonnativeSelectorCache(selector, true);
                        } finally{
                            if (nid === expando) context.removeAttribute("id");
                        }
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */ function createCache() {
            var keys = [];
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) // Only keep the most recent entries
                delete cache[keys.shift()];
                return cache[key + " "] = value;
            }
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */ function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */ function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally{
                // Remove from its parent by default
                if (el.parentNode) el.parentNode.removeChild(el);
                // release memory in IE
                el = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */ function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = arr.length;
            while(i--)Expr.attrHandle[arr[i]] = handler;
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */ function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            // Use IE sourceIndex if available on both nodes
            if (diff) return diff;
            // Check if b follows a
            if (cur) while(cur = cur.nextSibling){
                if (cur === b) return -1;
            }
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */ function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */ function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */ function createDisabledPseudo(disabled) {
            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
            return function(elem) {
                // Only certain elements can match :enabled or :disabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                if ("form" in elem) {
                    // Check for inherited disabledness on relevant non-disabled elements:
                    // * listed form-associated elements in a disabled fieldset
                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                    // * option elements in a disabled optgroup
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                    // All such elements have a "form" property.
                    if (elem.parentNode && elem.disabled === false) {
                        // Option elements defer to a parent optgroup if present
                        if ("label" in elem) {
                            if ("label" in elem.parentNode) return elem.parentNode.disabled === disabled;
                            else return elem.disabled === disabled;
                        }
                        // Support: IE 6 - 11
                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                        return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                        /* jshint -W018 */ elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                // even exist on them, let alone have a boolean value.
                } else if ("label" in elem) return elem.disabled === disabled;
                // Remaining elements are neither :enabled nor :disabled
                return false;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */ function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    // Match elements found at the specified indexes
                    while(i--)if (seed[j = matchIndexes[i]]) seed[j] = !(matches[j] = seed[j]);
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */ function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        // Expose support vars for convenience
        support = Sizzle.support = {};
        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */ isXML1 = Sizzle.isXML = function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            // Support: IE <=8
            // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
            // https://bugs.jquery.com/ticket/4833
            return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
        };
        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */ setDocument = Sizzle.setDocument = function(node1) {
            var hasCompare, subWindow, doc = node1 ? node1.ownerDocument || node1 : preferredDoc;
            // Return early if doc is invalid or already selected
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (doc == document || doc.nodeType !== 9 || !doc.documentElement) return document;
            // Update global variables
            document = doc;
            docElem1 = document.documentElement;
            documentIsHTML = !isXML1(document);
            // Support: IE 9 - 11+, Edge 12 - 18+
            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                // Support: IE 11, Edge
                if (subWindow.addEventListener) subWindow.addEventListener("unload", unloadHandler, false);
                else if (subWindow.attachEvent) subWindow.attachEvent("onunload", unloadHandler);
            }
            // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
            // Safari 4 - 5 only, Opera <=11.6 - 12.x only
            // IE/Edge & older browsers don't support the :scope pseudo-class.
            // Support: Safari 6.0 only
            // Safari 6.0 supports :scope but it's an alias of :root there.
            support.scope = assert(function(el) {
                docElem1.appendChild(el).appendChild(document.createElement("div"));
                return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
            });
            /* Attributes
	---------------------------------------------------------------------- */ // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function(el) {
                el.className = "i";
                return !el.getAttribute("className");
            });
            /* getElement(s)By*
	---------------------------------------------------------------------- */ // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(el) {
                el.appendChild(document.createComment(""));
                return !el.getElementsByTagName("*").length;
            });
            // Support: IE<9
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programmatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(el) {
                docElem1.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            // ID filter and find
            if (support.getById) {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [
                            elem
                        ] : [];
                    }
                };
            } else {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
                // Support: IE 6 - 7 only
                // getElementById is not reliable as a find shortcut
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            // Verify the id attribute
                            node = elem.getAttributeNode("id");
                            if (node && node.value === id) return [
                                elem
                            ];
                            // Fall back on getElementsByName
                            elems = context.getElementsByName(id);
                            i = 0;
                            while(elem = elems[i++]){
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) return [
                                    elem
                                ];
                            }
                        }
                        return [];
                    }
                };
            }
            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") return context.getElementsByTagName(tag);
                else if (support.qsa) return context.querySelectorAll(tag);
            } : function(tag, context) {
                var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);
                // Filter out possible comments
                if (tag === "*") {
                    while(elem = results[i++])if (elem.nodeType === 1) tmp.push(elem);
                    return tmp;
                }
                return results;
            };
            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) return context.getElementsByClassName(className);
            };
            /* QSA/matchesSelector
	---------------------------------------------------------------------- */ // QSA and matchesSelector support
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];
            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See https://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(el) {
                    var input;
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // https://bugs.jquery.com/ticket/12359
                    docElem1.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (el.querySelectorAll("[msallowcapture^='']").length) rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!el.querySelectorAll("[selected]").length) rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!el.querySelectorAll("[id~=" + expando + "-]").length) rbuggyQSA.push("~=");
                    // Support: IE 11+, Edge 15 - 18+
                    // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                    // Adding a temporary attribute to the document before the selection works
                    // around the issue.
                    // Interestingly, IE 10 & older don't seem to have the issue.
                    input = document.createElement("input");
                    input.setAttribute("name", "");
                    el.appendChild(input);
                    if (!el.querySelectorAll("[name='']").length) rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!el.querySelectorAll(":checked").length) rbuggyQSA.push(":checked");
                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibling-combinator selector` fails
                    if (!el.querySelectorAll("a#" + expando + "+*").length) rbuggyQSA.push(".#.+[+~]");
                    // Support: Firefox <=3.6 - 5 only
                    // Old Firefox doesn't throw on a badly-escaped identifier.
                    el.querySelectorAll("\\\f");
                    rbuggyQSA.push("[\\r\\n\\f]");
                });
                assert(function(el) {
                    el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    el.appendChild(input).setAttribute("name", "D");
                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (el.querySelectorAll("[name=d]").length) rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (el.querySelectorAll(":enabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: IE9-11+
                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                    docElem1.appendChild(el).disabled = true;
                    if (el.querySelectorAll(":disabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: Opera 10 - 11 only
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    el.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches1 = docElem1.matches || docElem1.webkitMatchesSelector || docElem1.mozMatchesSelector || docElem1.oMatchesSelector || docElem1.msMatchesSelector)) assert(function(el) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches1.call(el, "*");
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches1.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
            });
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            /* Contains
	---------------------------------------------------------------------- */ hasCompare = rnative.test(docElem1.compareDocumentPosition);
            // Element contains another
            // Purposefully self-exclusive
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem1.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) while(b = b.parentNode){
                    if (b === a) return true;
                }
                return false;
            };
            /* Sorting
	---------------------------------------------------------------------- */ // Document order sorting
            sortOrder = hasCompare ? function(a, b) {
                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) return compare;
                // Calculate position if both inputs belong to the same document
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                1;
                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    // Choose the first element that is related to our preferred document
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) return -1;
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) return 1;
                    // Maintain original order
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [
                    a
                ], bp = [
                    b
                ];
                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */ return a == document ? -1 : b == document ? 1 : /* eslint-enable eqeqeq */ aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                else if (aup === bup) return siblingCheck(a, b);
                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while(cur = cur.parentNode)ap.unshift(cur);
                cur = b;
                while(cur = cur.parentNode)bp.unshift(cur);
                // Walk down the tree looking for a discrepancy
                while(ap[i] === bp[i])i++;
                return i ? // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */ ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : /* eslint-enable eqeqeq */ 0;
            };
            return document;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches1.call(elem, expr);
                // IE 9's matchesSelector returns false on disconnected nodes
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) return ret;
            } catch (e) {
                nonnativeSelectorCache(expr, true);
            }
            return Sizzle(expr, document, null, [
                elem
            ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ((context.ownerDocument || context) != document) setDocument(context);
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ((elem.ownerDocument || elem) != document) setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */ Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while(elem = results[i++])if (elem === results[i]) j = duplicates.push(i);
                while(j--)results.splice(duplicates[j], 1);
            }
            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;
            return results;
        };
        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */ getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) // If no nodeType, this is expected to be an array
            while(node = elem[i++])// Do not traverse comment nodes
            ret += getText(node);
            else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") return elem.textContent;
                else // Traverse its children
                for(elem = elem.firstChild; elem; elem = elem.nextSibling)ret += getText(elem);
            } else if (nodeType === 3 || nodeType === 4) return elem.nodeValue;
            // Do not include comment or processing instruction nodes
            return ret;
        };
        Expr = Sizzle.selectors = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") match[3] = " " + match[3] + " ";
                    return match.slice(0, 4);
                },
                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/ match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) Sizzle.error(match[0]);
                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    // other types prohibit arguments
                    } else if (match[3]) Sizzle.error(match[0]);
                    return match;
                },
                "PSEUDO": function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) return null;
                    // Accept quoted arguments as-is
                    if (match[3]) match[2] = match[4] || match[5] || "";
                    else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },
            filter: {
                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                "CLASS": function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"), classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    }));
                },
                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) return operator === "!=";
                        if (!operator) return true;
                        result += "";
                        /* eslint-disable max-len */ return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    /* eslint-enable max-len */ };
                },
                "CHILD": function(type, what, _argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
                    function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, _context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while(dir){
                                    node = elem;
                                    while(node = node[dir]){
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) return false;
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [
                                forward ? parent.firstChild : parent.lastChild
                            ];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())// When found, cache indexes on `parent` and break
                                if (node.nodeType === 1 && ++diff && node === elem) {
                                    uniqueCache[type] = [
                                        dirruns,
                                        nodeIndex,
                                        diff
                                    ];
                                    break;
                                }
                            } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            outerCache = node[expando] || (node[expando] = {});
                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                            uniqueCache[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) break;
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) return fn(argument);
                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            "",
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while(i--){
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, _context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while(i--)if (elem = unmatched[i]) seed[i] = !(matches[i] = elem);
                    }) : function(elem, _context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                "contains": markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || getText(elem)).indexOf(text) > -1;
                    };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) Sizzle.error("unsupported lang: " + lang);
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                        }
                        while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                // Miscellaneous
                "target": function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                "root": function(elem) {
                    return elem === docElem1;
                },
                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),
                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) // eslint-disable-next-line no-unused-expressions
                    elem.parentNode.selectedIndex;
                    return elem.selected === true;
                },
                // Contents
                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for(elem = elem.firstChild; elem; elem = elem.nextSibling){
                        if (elem.nodeType < 6) return false;
                    }
                    return true;
                },
                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },
                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                "first": createPositionalPseudo(function() {
                    return [
                        0
                    ];
                }),
                "last": createPositionalPseudo(function(_matchIndexes, length) {
                    return [
                        length - 1
                    ];
                }),
                "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                    return [
                        argument < 0 ? argument + length : argument
                    ];
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument > length ? length : argument;
                    for(; --i >= 0;)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for(; ++i < length;)matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        // Add button/input type pseudos
        for(i1 in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        })Expr.pseudos[i1] = createInputPseudo(i1);
        for(i1 in {
            submit: true,
            reset: true
        })Expr.pseudos[i1] = createButtonPseudo(i1);
        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while(soFar){
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) // Don't consume trailing commas as valid
                    soFar = soFar.slice(match[0].length) || soFar;
                    groups.push(tokens = []);
                }
                matched = false;
                // Combinators
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                // Filters
                for(type in Expr.filter)if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice(matched.length);
                }
                if (!matched) break;
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
            tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for(; i < len; i++)selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? // Check against closest ancestor/preceding element
            function(elem, context, xml) {
                while(elem = elem[dir]){
                    if (elem.nodeType === 1 || checkNonElements) return matcher(elem, context, xml);
                }
                return false;
            } : // Check against all ancestor/preceding elements
            function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                    dirruns,
                    doneName
                ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) return true;
                    }
                } else {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                        if (skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem;
                        else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) // Assign to newCache so results back-propagate to previous elements
                        return newCache[2] = oldCache[2];
                        else {
                            // Reuse newcache so results back-propagate to previous elements
                            uniqueCache[key] = newCache;
                            // A match means we're done; a fail means we have to keep checking
                            if (newCache[2] = matcher(elem, context, xml)) return true;
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while(i--){
                    if (!matchers[i](elem, context, xml)) return false;
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for(; i < len; i++)Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for(; i < len; i++){
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) map.push(i);
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) postFilter = setMatcher(postFilter);
            if (postFinder && !postFinder[expando]) postFinder = setMatcher(postFinder, postSelector);
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [
                    context
                ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : // ...otherwise use results directly
                results : matcherIn;
                // Find primary matches
                if (matcher) matcher(matcherIn, matcherOut, context, xml);
                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while(i--)if (elem = temp[i]) matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while(i--)if (elem = matcherOut[i]) // Restore matcherIn since elem is not yet a final match
                            temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while(i--)if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) seed[temp] = !(results[temp] = elem);
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) postFinder(null, results, matcherOut, xml);
                    else push.apply(results, matcherOut);
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [
                function(elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    // Avoid hanging onto element (issue #299)
                    checkContext = null;
                    return ret;
                }
            ];
            for(; i < len; i++)if (matcher = Expr.relative[tokens[i].type]) matchers = [
                addCombinator(elementMatcher(matchers), matcher)
            ];
            else {
                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                // Return special upon seeing a positional matcher
                if (matcher[expando]) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for(; j < len; j++){
                        if (Expr.relative[tokens[j].type]) break;
                    }
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i - 1).concat({
                        value: tokens[i - 2].type === " " ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                outermostContext = context == document || context || outermost;
                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for(; i !== len && (elem = elems[i]) != null; i++){
                    if (byElement && elem) {
                        j = 0;
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (!context && elem.ownerDocument != document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while(matcher = elementMatchers[j++])if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        if (outermost) dirruns = dirrunsUnique;
                    }
                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) matchedCount--;
                        // Lengthen the array for every element, matched or not
                        if (seed) unmatched.push(elem);
                    }
                }
                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;
                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while(matcher = setMatchers[j++])matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while(i--)if (!(unmatched[i] || setMatched[i])) setMatched[i] = pop.call(results);
                        }
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched);
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) Sizzle.uniqueSort(results);
                }
                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) match = tokenize(selector);
                i = match.length;
                while(i--){
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) setMatchers.push(cached);
                    else elementMatchers.push(cached);
                }
                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */ select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            // Try to minimize operations if there is only one selector in the list and no seed
            // (the latter of which guarantees us context)
            if (match.length === 1) {
                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) return results;
                    else if (compiled) context = context.parentNode;
                    selector = selector.slice(tokens.shift().value.length);
                }
                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while(i--){
                    token = tokens[i];
                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) break;
                    if (find = Expr.find[type]) // Search, expanding context for leading sibling combinators
                    {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        // One-time assignments
        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;
        // Initialize against the default document
        setDocument();
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(el) {
            // Should return 1, but returns 4 (following)
            return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        });
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
        })) addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        });
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
        })) addHandle("value", function(elem, _name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") return elem.defaultValue;
        });
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
        })) addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        });
        return Sizzle;
    }(window1);
    jQuery.find = Sizzle1;
    jQuery.expr = Sizzle1.selectors;
    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle1.uniqueSort;
    jQuery.text = Sizzle1.getText;
    jQuery.isXMLDoc = Sizzle1.isXML;
    jQuery.contains = Sizzle1.contains;
    jQuery.escapeSelector = Sizzle1.escape;
    var dir1 = function(elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while((elem = elem[dir]) && elem.nodeType !== 9)if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for(; n; n = n.nextSibling)if (n.nodeType === 1 && n !== elem) matched.push(n);
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName1(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        });
        // Single element
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        });
        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") return jQuery.grep(elements, function(elem) {
            return indexOf1.call(qualifier, elem) > -1 !== not;
        });
        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
        var elem1 = elems[0];
        if (not) expr = ":not(" + expr + ")";
        if (elems.length === 1 && elem1.nodeType === 1) return jQuery.find.matchesSelector(elem1, expr) ? [
            elem1
        ] : [];
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== "string") return this.pushStack(jQuery(selector).filter(function() {
                for(i = 0; i < len; i++){
                    if (jQuery.contains(self[i], this)) return true;
                }
            }));
            ret = this.pushStack([]);
            for(i = 0; i < len; i++)jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr1 = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) return this;
        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;
        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [
                null,
                selector,
                null
            ];
            else match = rquickExpr1.exec(selector);
            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {
                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document1, true));
                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for(match in context)// Properties of context are called as methods if possible
                        if (isFunction(this[match])) this[match](context[match]);
                        else this.attr(match, context[match]);
                    }
                    return this;
                // HANDLE: $(#id)
                } else {
                    elem = document1.getElementById(match[2]);
                    if (elem) {
                        // Inject the element directly into the jQuery object
                        this[0] = elem;
                        this.length = 1;
                    }
                    return this;
                }
            } else if (!context || context.jquery) return (context || root).find(selector);
            else return this.constructor(context).find(selector);
        // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
        // HANDLE: $(function)
        // Shortcut for document ready
        } else if (isFunction(selector)) return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
        return jQuery.makeArray(selector, this);
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    // Initialize central reference
    rootjQuery = jQuery(document1);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for(; i < l; i++){
                    if (jQuery.contains(this, targets[i])) return true;
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) for(; i < l; i++){
                for(cur = this[i]; cur && cur !== context; cur = cur.parentNode)// Always skip document fragments
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
            // No argument, return index in parent
            if (!elem) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            // Index in selector
            if (typeof elem === "string") return indexOf1.call(jQuery(elem), this[0]);
            // Locate the position of the desired element
            return indexOf1.call(this, // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while((cur = cur[dir]) && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir1(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
            return dir1(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir1(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir1(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
            return dir1(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
            return dir1(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) return elem.contentDocument;
            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName1(elem, "template")) elem = elem.content || elem;
            return jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") selector = until;
            if (selector && typeof selector === "string") matched = jQuery.filter(selector, matched);
            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) jQuery.uniqueSort(matched);
                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) matched.reverse();
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */ jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, // Last fire value for non-forgettable lists
        memory, // Flag to know if list was already fired
        fired, // Flag to prevent firing
        locked, // Actual callback list
        list = [], // Queue of execution data for repeatable lists
        queue = [], // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1, // Fire callbacks
        fire = function() {
            // Enforce single-firing
            locked = locked || options.once;
            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            fired = firing = true;
            for(; queue.length; firingIndex = -1){
                memory = queue.shift();
                while(++firingIndex < list.length)// Run callback and check for early termination
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    // Jump to end and forget the data so .add doesn't re-fire
                    firingIndex = list.length;
                    memory = false;
                }
            }
            // Forget the data if we're done with it
            if (!options.memory) memory = false;
            firing = false;
            // Clean up if we're done firing for good
            if (locked) {
                // Keep an empty list if we have data for future add calls
                if (memory) list = [];
                else list = "";
            }
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) list.push(arg);
                            } else if (arg && arg.length && toType(arg) !== "string") // Inspect recursively
                            add(arg);
                        });
                    })(arguments);
                    if (memory && !firing) fire();
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while((index = jQuery.inArray(arg, list, index)) > -1){
                        list.splice(index, 1);
                        // Handle firing indexes
                        if (index <= firingIndex) firingIndex--;
                    }
                });
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
                if (list) list = [];
                return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
                locked = queue = [];
                if (!memory && !firing) list = memory = "";
                return this;
            },
            locked: function() {
                return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [
                        context,
                        args.slice ? args.slice() : args
                    ];
                    queue.push(args);
                    if (!firing) fire();
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction(method = value.promise)) method.call(value).done(resolve).fail(reject);
            else if (value && isFunction(method = value.then)) method.call(value, resolve, reject);
            else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply(undefined, [
                value
            ].slice(noValue));
        // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.
        } catch (value1) {
            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [
                value1
            ]);
        }
    }
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [
                    "notify",
                    "progress",
                    jQuery.Callbacks("memory"),
                    jQuery.Callbacks("memory"),
                    2
                ],
                [
                    "resolve",
                    "done",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    0,
                    "resolved"
                ],
                [
                    "reject",
                    "fail",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    1,
                    "rejected"
                ]
            ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred1.done(arguments).fail(arguments);
                    return this;
                },
                "catch": function(fn) {
                    return promise.then(null, fn);
                },
                // Keep pipe for back-compat
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(_i, tuple) {
                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                            deferred1[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && isFunction(returned.promise)) returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                else newDefer[tuple[0] + "With"](this, fn ? [
                                    returned
                                ] : arguments);
                            });
                        });
                        fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0;
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                // Support: Promises/A+ section 2.3.3.3.3
                                // https://promisesaplus.com/#point-59
                                // Ignore double-resolution attempts
                                if (depth < maxDepth) return;
                                returned = handler.apply(that, args);
                                // Support: Promises/A+ section 2.3.1
                                // https://promisesaplus.com/#point-48
                                if (returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                // https://promisesaplus.com/#point-54
                                // https://promisesaplus.com/#point-75
                                // Retrieve `then` only once
                                then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                                // Handle a returned thenable
                                if (isFunction(then)) {
                                    // Special processors (notify) just wait for resolution
                                    if (special) then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                    else {
                                        // ...and disregard older resolution values
                                        maxDepth++;
                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                    }
                                } else {
                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Identity) {
                                        that = undefined;
                                        args = [
                                            returned
                                        ];
                                    }
                                    // Process the value(s)
                                    // Default process is resolve
                                    (special || deferred.resolveWith)(that, args);
                                }
                            }, // Only normal processors (resolve) catch and reject exceptions
                            process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    if (jQuery.Deferred.exceptionHook) jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                    // Support: Promises/A+ section 2.3.3.3.4.1
                                    // https://promisesaplus.com/#point-61
                                    // Ignore post-resolution exceptions
                                    if (depth + 1 >= maxDepth) {
                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        if (handler !== Thrower) {
                                            that = undefined;
                                            args = [
                                                e
                                            ];
                                        }
                                        deferred.rejectWith(that, args);
                                    }
                                }
                            };
                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            if (depth) process();
                            else {
                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                if (jQuery.Deferred.getStackHook) process.stackTrace = jQuery.Deferred.getStackHook();
                                window1.setTimeout(process);
                            }
                        };
                    }
                    return jQuery.Deferred(function(newDefer) {
                        // progress_handlers.add( ... )
                        tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                        // rejected_handlers.add( ... )
                        tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred1 = {};
            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;
                // Handle state
                if (stateString) list.add(function() {
                    // state = "resolved" (i.e., fulfilled)
                    // state = "rejected"
                    state = stateString;
                }, // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i][2].disable, // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i][3].disable, // progress_callbacks.lock
                tuples[0][2].lock, // progress_handlers.lock
                tuples[0][3].lock);
                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);
                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred1[tuple[0]] = function() {
                    deferred1[tuple[0] + "With"](this === deferred1 ? undefined : this, arguments);
                    return this;
                };
                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred1[tuple[0] + "With"] = list.fireWith;
            });
            // Make the deferred a promise
            promise.promise(deferred1);
            // Call given func if any
            if (func) func.call(deferred1, deferred1);
            // All done!
            return deferred1;
        },
        // Deferred helper
        when: function(singleValue) {
            var // count of uncompleted subordinates
            remaining = arguments.length, // count of unprocessed arguments
            i2 = remaining, // subordinate fulfillment data
            resolveContexts = Array(i2), resolveValues = slice1.call(arguments), // the primary Deferred
            primary = jQuery.Deferred(), // subordinate callback factory
            updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this;
                    resolveValues[i] = arguments.length > 1 ? slice1.call(arguments) : value;
                    if (!--remaining) primary.resolveWith(resolveContexts, resolveValues);
                };
            };
            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, primary.done(updateFunc(i2)).resolve, primary.reject, !remaining);
                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (primary.state() === "pending" || isFunction(resolveValues[i2] && resolveValues[i2].then)) return primary.then();
            }
            // Multiple arguments are aggregated like Promise.all array elements
            while(i2--)adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
            return primary.promise();
        }
    });
    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) window1.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    };
    jQuery.readyException = function(error) {
        window1.setTimeout(function() {
            throw error;
        });
    };
    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function(error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) return;
            // Remember that the DOM is ready
            jQuery.isReady = true;
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) return;
            // If there are functions bound, to execute
            readyList.resolveWith(document1, [
                jQuery
            ]);
        }
    });
    jQuery.ready.then = readyList.then;
    // The ready event handler and self cleanup method
    function completed1() {
        document1.removeEventListener("DOMContentLoaded", completed1);
        window1.removeEventListener("load", completed1);
        jQuery.ready();
    }
    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document1.readyState === "complete" || document1.readyState !== "loading" && !document1.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
    window1.setTimeout(jQuery.ready);
    else {
        // Use the handy event callback
        document1.addEventListener("DOMContentLoaded", completed1);
        // A fallback to window.onload, that will always work
        window1.addEventListener("load", completed1);
    }
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function(elems, fn, key, value2, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for(i in key)access(elems, fn, i, key[i], true, emptyGet, raw);
        // Sets one value
        } else if (value2 !== undefined) {
            chainable = true;
            if (!isFunction(value2)) raw = true;
            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value2);
                    fn = null;
                // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function(elem, _key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) for(; i < len; i++)fn(elems[i], key, raw ? value2 : value2.call(elems[i], i, fn(elems[i], key)));
        }
        if (chainable) return elems;
        // Gets
        if (bulk) return fn.call(elems);
        return len ? fn(elems[0], key) : emptyGet;
    };
    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    // Used by camelCase as callback to replace()
    function fcamelCase(_all, letter) {
        return letter.toUpperCase();
    }
    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function(owner) {
            // Check if the owner object already has a cache
            var value = owner[this.expando];
            // If not, create one
            if (!value) {
                value = {};
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {
                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) owner[this.expando] = value;
                    else Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") cache[camelCase(data)] = value;
            else // Copy the properties one-by-one to the cache object
            for(prop in data)cache[camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function(owner, key, value) {
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || key && typeof key === "string" && value === undefined) return this.get(owner, key);
            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);
            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) return;
            if (key !== undefined) {
                // Support array or space separated string of keys
                if (Array.isArray(key)) // If key is an array of keys...
                // We always set camelCase keys, so remove that.
                key = key.map(camelCase);
                else {
                    key = camelCase(key);
                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ? [
                        key
                    ] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while(i--)delete cache[key[i]];
            }
            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) owner[this.expando] = undefined;
                else delete owner[this.expando];
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === "true") return true;
        if (data === "false") return false;
        if (data === "null") return null;
        // Only convert to a number if it doesn't change the string
        if (data === +data + "") return +data;
        if (rbrace.test(data)) return JSON.parse(data);
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {}
                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else data = undefined;
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value3) {
            var i, name, data1, elem = this[0], attrs = elem && elem.attributes;
            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data1 = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while(i--)// Support: IE 11 only
                        // The attrs elements can be null (#14894)
                        if (attrs[i]) {
                            name = attrs[i].name;
                            if (name.indexOf("data-") === 0) {
                                name = camelCase(name.slice(5));
                                dataAttr(elem, name, data1[name]);
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data1;
            }
            // Sets multiple values
            if (typeof key === "object") return this.each(function() {
                dataUser.set(this, key);
            });
            return access(this, function(value) {
                var data;
                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) return data;
                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) return data;
                    // We tried really hard, but the data doesn't exist.
                    return;
                }
                // Set the data...
                this.each(function() {
                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value3, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    else queue.push(data);
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") queue.unshift("inprogress");
                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) hooks.empty.fire();
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [
                        type + "queue",
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) return jQuery.queue(this[0], type);
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) defer.resolveWith(elements, [
                    elements
                ]);
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while(i--){
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [
        "Top",
        "Right",
        "Bottom",
        "Left"
    ];
    var documentElement = document1.documentElement;
    var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
    }, composed = {
        composed: true
    };
    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if (documentElement.getRootNode) isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
    var isHiddenWithinTree = function(elem, el) {
        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        // Inline style trumps all
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;
            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];
            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;
            while(maxIterations--){
                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) maxIterations = 0;
                initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) return display;
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") display = "block";
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        // Determine new display value for elements that need to change
        for(; index < length; index++){
            elem = elements[index];
            if (!elem.style) continue;
            display = elem.style.display;
            if (show) {
                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) elem.style.display = "";
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) values[index] = getDefaultDisplay(elem);
            } else if (display !== "none") {
                values[index] = "none";
                // Remember what we're overwriting
                dataPriv.set(elem, "display", display);
            }
        }
        // Set the display of the elements in a second loop to avoid constant reflow
        for(index = 0; index < length; index++)if (values[index] != null) elements[index].style.display = values[index];
        return elements;
    }
    jQuery.fn.extend({
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") return state ? this.show() : this.hide();
            return this.each(function() {
                if (isHiddenWithinTree(this)) jQuery(this).show();
                else jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
        var fragment = document1.createDocumentFragment(), div = fragment.appendChild(document1.createElement("div")), input = document1.createElement("input");
        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support1.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support1.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        // Support: IE <=9 only
        // IE <=9 replaces <option> tags with their contents when inserted outside of
        // the select element.
        div.innerHTML = "<option></option>";
        support1.option = !!div.lastChild;
    })();
    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [
            1,
            "<table>",
            "</table>"
        ],
        col: [
            2,
            "<table><colgroup>",
            "</colgroup></table>"
        ],
        tr: [
            2,
            "<table><tbody>",
            "</tbody></table>"
        ],
        td: [
            3,
            "<table><tbody><tr>",
            "</tr></tbody></table>"
        ],
        _default: [
            0,
            "",
            ""
        ]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    // Support: IE <=9 only
    if (!support1.option) wrapMap.optgroup = wrapMap.option = [
        1,
        "<select multiple='multiple'>",
        "</select>"
    ];
    function getAll(context, tag) {
        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") ret = context.getElementsByTagName(tag || "*");
        else if (typeof context.querySelectorAll !== "undefined") ret = context.querySelectorAll(tag || "*");
        else ret = [];
        if (tag === undefined || tag && nodeName1(context, tag)) return jQuery.merge([
            context
        ], ret);
        return ret;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for(; i < l; i++)dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    var rhtml1 = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for(; i < l; i++){
            elem = elems[i];
            if (elem || elem === 0) {
                // Add nodes directly
                if (toType(elem) === "object") // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(nodes, elem.nodeType ? [
                    elem
                ] : elem);
                else if (!rhtml1.test(elem)) nodes.push(context.createTextNode(elem));
                else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || [
                        "",
                        ""
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while(j--)tmp = tmp.lastChild;
                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);
                    // Remember the top-level container
                    tmp = fragment.firstChild;
                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }
        // Remove wrapper from fragment
        fragment.textContent = "";
        i = 0;
        while(elem = nodes[i++]){
            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) ignored.push(elem);
                continue;
            }
            attached = isAttached(elem);
            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");
            // Preserve script evaluation history
            if (attached) setGlobalEval(tmp);
            // Capture executables
            if (scripts) {
                j = 0;
                while(elem = tmp[j++])if (rscriptType.test(elem.type || "")) scripts.push(elem);
            }
        }
        return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).
    function expectSync1(elem, type) {
        return elem === safeActiveElement() === (type === "focus");
    }
    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
        try {
            return document1.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        // Types can be a map of types/handlers
        if (typeof types === "object") {
            // ( types-Object, selector, data )
            if (typeof selector !== "string") {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for(type in types)on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (data == null && fn == null) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) fn = returnFalse;
        else if (!fn) return elem;
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */ jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            // Only attach events to objects that accept data
            if (!acceptData(elem)) return;
            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) jQuery.find.matchesSelector(documentElement, selector);
            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) handler.guid = jQuery.guid++;
            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) events = elemData.events = Object.create(null);
            if (!(eventHandle = elemData.handle)) eventHandle = elemData.handle = function(e) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // There *must* be a type, no attaching namespace-only handlers
                if (!type) continue;
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};
                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;
                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) elem.addEventListener(type, eventHandle);
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) handleObj.handler.guid = handler.guid;
                }
                // Add to the element's handler list, delegates in front
                if (selector) handlers.splice(handlers.delegateCount++, 0, handleObj);
                else handlers.push(handleObj);
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) return;
            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for(type in events)jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                // Remove matching events
                origCount = j = handlers.length;
                while(j--){
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) handlers.delegateCount--;
                        if (special.remove) special.remove.call(elem, handleObj);
                    }
                }
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) jQuery.removeEvent(elem, type, elemData.handle);
                    delete events[type];
                }
            }
            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) dataPriv.remove(elem, "handle events");
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            for(i = 1; i < arguments.length; i++)args[i] = arguments[i];
            event.delegateTarget = this;
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) return;
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){
                event.currentTarget = matched.elem;
                j = 0;
                while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped())// If the event is namespaced, then each handler is only invoked if it is
                // specially universal or its namespaces are a superset of the event's.
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                    if (ret !== undefined) {
                        if ((event.result = ret) === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) special.postDispatch.call(this, event);
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
                for(; cur !== this; cur = cur.parentNode || this)// Don't check non-elements (#13208)
                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                    matchedHandlers = [];
                    matchedSelectors = {};
                    for(i = 0; i < delegateCount; i++){
                        handleObj = handlers[i];
                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";
                        if (matchedSelectors[sel] === undefined) matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [
                            cur
                        ]).length;
                        if (matchedSelectors[sel]) matchedHandlers.push(handleObj);
                    }
                    if (matchedHandlers.length) handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                    });
                }
            }
            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            });
            return handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction(hook) ? function() {
                    if (this.originalEvent) return hook(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[name];
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function(data) {
                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;
                    // Claim the first handler
                    if (rcheckableType.test(el.type) && el.click && nodeName1(el, "input")) // dataPriv.set( el, "click", ... )
                    leverageNative(el, "click", returnTrue);
                    // Return false to allow normal processing in the caller
                    return false;
                },
                trigger: function(data) {
                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;
                    // Force setup before triggering a click
                    if (rcheckableType.test(el.type) && el.click && nodeName1(el, "input")) leverageNative(el, "click");
                    // Return non-false to allow normal event-path propagation
                    return true;
                },
                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function(event) {
                    var target = event.target;
                    return rcheckableType.test(target.type) && target.click && nodeName1(target, "input") && dataPriv.get(target, "click") || nodeName1(target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) event.originalEvent.returnValue = event.result;
                }
            }
        }
    };
    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative(el, type, expectSync) {
        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if (!expectSync) {
            if (dataPriv.get(el, type) === undefined) jQuery.event.add(el, type, returnTrue);
            return;
        }
        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
            namespace: false,
            handler: function(event) {
                var notAsync, result, saved = dataPriv.get(this, type);
                if (event.isTrigger & 1 && this[type]) {
                    // Interrupt processing of the outer synthetic .trigger()ed event
                    // Saved data should be false in such cases, but might be a leftover capture object
                    // from an async native handler (gh-4350)
                    if (!saved.length) {
                        // Store arguments for use when handling the inner native event
                        // There will always be at least one argument (an event object), so this array
                        // will not be confused with a leftover capture object.
                        saved = slice1.call(arguments);
                        dataPriv.set(this, type, saved);
                        // Trigger the native event and capture its result
                        // Support: IE <=9 - 11+
                        // focus() and blur() are asynchronous
                        notAsync = expectSync(this, type);
                        this[type]();
                        result = dataPriv.get(this, type);
                        if (saved !== result || notAsync) dataPriv.set(this, type, false);
                        else result = {};
                        if (saved !== result) {
                            // Cancel the outer synthetic event
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            // Support: Chrome 86+
                            // In Chrome, if an element having a focusout handler is blurred by
                            // clicking outside of it, it invokes the handler synchronously. If
                            // that handler calls `.remove()` on the element, the data is cleared,
                            // leaving `result` undefined. We need to guard against this.
                            return result && result.value;
                        }
                    // If this is an inner synthetic event for an event with a bubbling surrogate
                    // (focus or blur), assume that the surrogate already propagated from triggering the
                    // native event and prevent that from happening again here.
                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                    // less bad than duplication.
                    } else if ((jQuery.event.special[type] || {}).delegateType) event.stopPropagation();
                // If this is a native event triggered above, everything is now in order
                // Fire an inner synthetic event with the original arguments
                } else if (saved.length) {
                    // ...and capture the result
                    dataPriv.set(this, type, {
                        value: jQuery.event.trigger(// Support: IE <=9 - 11+
                        // Extend with the prototype to reset the above stopImmediatePropagation()
                        jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
                    });
                    // Abort handling of the native event
                    event.stopImmediatePropagation();
                }
            }
        });
    }
    jQuery.removeEvent = function(elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) elem.removeEventListener(type, handle);
    };
    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        // Event type
        } else this.type = src;
        // Put explicitly provided properties onto the event object
        if (props) jQuery.extend(this, props);
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();
        // Mark it as fixed
        this[jQuery.expando] = true;
    };
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopImmediatePropagation();
            this.stopPropagation();
        }
    };
    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
    }, jQuery.event.addProp);
    jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(type, delegateType) {
        jQuery.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
                // Claim the first handler
                // dataPriv.set( this, "focus", ... )
                // dataPriv.set( this, "blur", ... )
                leverageNative(this, type, expectSync1);
                // Return false to allow normal processing in the caller
                return false;
            },
            trigger: function() {
                // Force setup before trigger
                leverageNative(this, type);
                // Return non-false to allow normal event-path propagation
                return true;
            },
            // Suppress native focus or blur as it's already being fired
            // in leverageNative.
            _default: function() {
                return true;
            },
            delegateType: delegateType
        };
    });
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for(type in types)this.off(type, selector, types[type]);
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) fn = returnFalse;
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName1(elem, "table") && nodeName1(content.nodeType !== 11 ? content : content.firstChild, "tr")) return jQuery(elem).children("tbody")[0] || elem;
        return elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") elem.type = elem.type.slice(5);
        else elem.removeAttribute("type");
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) return;
        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
                dataPriv.remove(dest, "handle events");
                for(type in events)for(i = 0, l = events[type].length; i < l; i++)jQuery.event.add(dest, type, events[type][i]);
            }
        }
        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) dest.checked = src.checked;
        else if (nodeName === "input" || nodeName === "textarea") dest.defaultValue = src.defaultValue;
    }
    function domManip(collection, args, callback, ignored) {
        // Flatten any nested arrays
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction || l > 1 && typeof value === "string" && !support1.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            if (valueIsFunction) args[0] = value.call(this, index, self.html());
            domManip(self, args, callback, ignored);
        });
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) fragment = first;
            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for(; i < l; i++){
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) // Support: Android <=4.0 only, PhantomJS 1 only
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(scripts, getAll(node, "script"));
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);
                    // Evaluate executable scripts on first document insertion
                    for(i = 0; i < hasScripts; i++){
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src && (node.type || "").toLowerCase() !== "module") // Optional AJAX dependency, but won't run scripts if not present
                            {
                                if (jQuery._evalUrl && !node.noModule) jQuery._evalUrl(node.src, {
                                    nonce: node.nonce || node.getAttribute("nonce")
                                }, doc);
                            } else DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for(; (node = nodes[i]) != null; i++){
            if (!keepData && node.nodeType === 1) jQuery.cleanData(getAll(node));
            if (node.parentNode) {
                if (keepData && isAttached(node)) setGlobalEval(getAll(node, "script"));
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            // Fix IE cloning issues
            if (!support1.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for(i = 0, l = srcElements.length; i < l; i++)fixInput(srcElements[i], destElements[i]);
            }
            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for(i = 0, l = srcElements.length; i < l; i++)cloneCopyEvent(srcElements[i], destElements[i]);
                } else cloneCopyEvent(elem, clone);
            }
            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            // Return the cloned set
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for(; (elem = elems[i]) !== undefined; i++)if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) {
                        for(type in data.events)if (special[type]) jQuery.event.remove(elem, type);
                        else jQuery.removeEvent(elem, type, data.handle);
                    }
                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataPriv.expando] = undefined;
                }
                if (elem[dataUser.expando]) // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[dataUser.expando] = undefined;
            }
        }
    });
    jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value4) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) this.textContent = value;
                });
            }, null, value4, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            var elem, i = 0;
            for(; (elem = this[i]) != null; i++)if (elem.nodeType === 1) {
                // Prevent memory leaks
                jQuery.cleanData(getAll(elem, false));
                // Remove any remaining nodes
                elem.textContent = "";
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value5) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) return elem.innerHTML;
                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                    "",
                    ""
                ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for(; i < l; i++){
                            elem = this[i] || {};
                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }
                if (elem) this.empty().append(value);
            }, null, value5, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) parent.replaceChild(elem, this);
                }
            // Force callback invocation
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for(; i <= last; i++){
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push1.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) view = window1;
        return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
        var ret, name, old = {};
        // Remember the old values, and insert the new ones
        for(name in options){
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        // Revert the old values
        for(name in options)elem.style[name] = old[name];
        return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    (function() {
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            // This is a singleton, we need to execute it only once
            if (!div) return;
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window1.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            // Support: Chrome <=64
            // Don't get tricked when zoom affects offsetWidth (gh-4029)
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }
        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document1.createElement("div"), div = document1.createElement("div");
        // Finish early in limited (non-browser) environments
        if (!div.style) return;
        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support1.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support1, {
            boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
                computeStyleTests();
                return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
                var table, tr, trChild, trStyle;
                if (reliableTrDimensionsVal == null) {
                    table = document1.createElement("table");
                    tr = document1.createElement("tr");
                    trChild = document1.createElement("div");
                    table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                    tr.style.cssText = "border:1px solid";
                    // Support: Chrome 86+
                    // Height set through cssText does not get applied.
                    // Computed height then comes back as 0.
                    tr.style.height = "1px";
                    trChild.style.height = "9px";
                    // Support: Android 8 Chrome 86+
                    // In our bodyBackground.html iframe,
                    // display for all div elements is set to "inline",
                    // which causes a problem only in Android 8 Chrome 86.
                    // Ensuring the div is display: block
                    // gets around this issue.
                    trChild.style.display = "block";
                    documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                    trStyle = window1.getComputedStyle(tr);
                    reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                    documentElement.removeChild(table);
                }
                return reliableTrDimensionsVal;
            }
        });
    })();
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;
        computed = computed || getStyles(elem);
        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === "" && !isAttached(elem)) ret = jQuery.style(elem, name);
            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support1.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }
                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var cssPrefixes = [
        "Webkit",
        "Moz",
        "ms"
    ], emptyStyle = document1.createElement("div").style, vendorProps = {};
    // Return a vendor-prefixed property or undefined
    function vendorPropName(name) {
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while(i--){
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) return name;
        }
    }
    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) return final;
        if (name in emptyStyle) return name;
        return vendorProps[name] = vendorPropName(name) || name;
    }
    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) return 0;
        for(; i < 4; i += 2){
            // Both box models exclude margin
            if (box === "margin") delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {
                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // For "border" or "margin", add border
                if (box !== "padding") delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                else extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            // If we get here with a border-box (content + padding + border), we're seeking "content" or
            // "padding" or "margin"
            } else {
                // For "content", subtract padding
                if (box === "content") delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // For "content" or "padding", subtract border
                if (box !== "margin") delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
        }
        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
        // Assuming integer scroll gutter, subtract the rest and round down
        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
        return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
        // Start with computed style
        var styles = getStyles(elem), // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
        // Fake content-box until we know it's needed to know the true value.
        boxSizingNeeded = !support1.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) return val;
            val = "auto";
        }
        // Support: IE 9 - 11 only
        // Use offsetWidth/offsetHeight for when box sizing is unreliable.
        // In those cases, the computed value can be trusted to be border-box.
        if ((!support1.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support1.reliableTrDimensions() && nodeName1(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            // Where available, offsetWidth/offsetHeight approximate border box dimensions.
            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
            // retrieved value as a content box dimension.
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) val = elem[offsetProp];
        }
        // Normalize "" and auto
        val = parseFloat(val) || 0;
        // Adjust for the element's box model
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val) + "px";
    }
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) return;
            // Make sure that we're working with the right name
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;
                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    // Fixes bug #9237
                    type = "number";
                }
                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) return;
                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === "number" && !isCustomProp) value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                // background-* props affect original clone's values
                if (!support1.clearCloneStyle && value === "" && name.indexOf("background") === 0) style[name] = "inherit";
                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) style.setProperty(name, value);
                    else style[name] = value;
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) return ret;
                // Otherwise just get the value from the style object
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) val = hooks.get(elem, true, extra);
            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) val = curCSS(elem, name, styles);
            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) val = cssNormalTransform[name];
            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        "height",
        "width"
    ], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
                if (computed) // Certain elements can have dimension info if we invisibly show them
                // but it must have a current display style that would benefit
                return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
            },
            set: function(elem, value, extra) {
                var matches, styles = getStyles(elem), // Only read styles.position if the test has a chance to fail
                // to avoid forcing a reflow.
                scrollboxSizeBuggy = !support1.scrollboxSize() && styles.position === "absolute", // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support1.reliableMarginLeft, function(elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px";
    });
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [
                    value
                ];
                for(; i < 4; i++)expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        };
        if (prefix !== "margin") jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    });
    jQuery.fn.extend({
        css: function(name1, value6) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for(; i < len; i++)map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name1, value6, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            else this.pos = eased = percent;
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) this.options.step.call(this.elem, this.now, this);
            if (hooks && hooks.set) hooks.set(this);
            else Tween.propHooks._default.set(this);
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) return tween.elem[tween.prop];
                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) jQuery.fx.step[tween.prop](tween);
                else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                else tween.elem[tween.prop] = tween.now;
            }
        }
    };
    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) tween.elem[tween.prop] = tween.now;
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    // Back compat <1.8 extension point
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document1.hidden === false && window1.requestAnimationFrame) window1.requestAnimationFrame(schedule);
            else window1.setTimeout(schedule, jQuery.fx.interval);
            jQuery.fx.tick();
        }
    }
    // Animations created synchronously will run synchronously
    function createFxNow() {
        window1.setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = Date.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for(; i < 4; i += 2 - includeWidth){
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) attrs.opacity = attrs.width = type;
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for(; index < length; index++){
            if (tween = collection[index].call(animation, prop, value)) // We're done with this property
            return tween;
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) oldfire();
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                // Ensure the complete handler is called before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) hooks.empty.fire();
                });
            });
        }
        // Detect show/hide animations
        for(prop in props){
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) hidden = true;
                    else continue;
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) return;
        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {
            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) restoreDisplay = dataPriv.get(elem, "display");
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) display = restoreDisplay;
                else {
                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([
                        elem
                    ], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([
                        elem
                    ]);
                }
            }
            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {
                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function() {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        // Implement show/hide animations
        propTween = false;
        for(prop in orig){
            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) hidden = dataShow.hidden;
                } else dataShow = dataPriv.access(elem, "fxshow", {
                    display: restoreDisplay
                });
                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) dataShow.hidden = !hidden;
                // Show elements before animating them
                if (hidden) showHide([
                    elem
                ], true);
                /* eslint-disable no-loop-func */ anim.done(function() {
                    /* eslint-enable no-loop-func */ // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) showHide([
                        elem
                    ]);
                    dataPriv.remove(elem, "fxshow");
                    for(prop in orig)jQuery.style(elem, prop, orig[prop]);
                });
            }
            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for(index in props){
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for(index in value)if (!(index in props)) {
                    props[index] = value[index];
                    specialEasing[index] = easing;
                }
            } else specialEasing[name] = easing;
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index1 = 0, length1 = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            // Don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) return false;
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for(; index < length; index++)animation.tweens[index].run(percent);
            deferred.notifyWith(elem, [
                animation,
                percent,
                remaining
            ]);
            // If there's more to do, yield
            if (percent < 1 && length) return remaining;
            // If this was an empty animation, synthesize a final progress notification
            if (!length) deferred.notifyWith(elem, [
                animation,
                1,
                0
            ]);
            // Resolve the animation and report its conclusion
            deferred.resolveWith(elem, [
                animation
            ]);
            return false;
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                stopped = true;
                for(; index < length; index++)animation.tweens[index].run(1);
                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                    deferred.resolveWith(elem, [
                        animation,
                        gotoEnd
                    ]);
                } else deferred.rejectWith(elem, [
                    animation,
                    gotoEnd
                ]);
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for(; index1 < length1; index1++){
            result = Animation.prefilters[index1].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) animation.opts.start.call(elem, animation);
        // Attach callbacks from options
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [
                function(prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }
            ]
        },
        tweener: function(props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = [
                    "*"
                ];
            } else props = props.match(rnothtmlwhite);
            var prop, index = 0, length = props.length;
            for(; index < length; index++){
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [
            defaultPrefilter
        ],
        prefilter: function(callback, prepend) {
            if (prepend) Animation.prefilters.unshift(callback);
            else Animation.prefilters.push(callback);
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };
        // Go to the end state if fx are off
        if (jQuery.fx.off) opt.duration = 0;
        else if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) opt.duration = jQuery.fx.speeds[opt.duration];
            else opt.duration = jQuery.fx.speeds._default;
        }
        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) opt.queue = "fx";
        // Queueing
        opt.old = opt.complete;
        opt.complete = function() {
            if (isFunction(opt.old)) opt.old.call(this);
            if (opt.queue) jQuery.dequeue(this, opt.queue);
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()// Animate to the value specified
            .end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                // Empty animations, or finishing resolves immediately
                if (empty || dataPriv.get(this, "finish")) anim.stop(true);
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue) this.queue(type || "fx", []);
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) stopQueue(data[index]);
                } else {
                    for(index in data)if (data[index] && data[index].stop && rrun.test(index)) stopQueue(data[index]);
                }
                for(index = timers.length; index--;)if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    timers[index].anim.stop(gotoEnd);
                    dequeue = false;
                    timers.splice(index, 1);
                }
                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            if (type !== false) type = type || "fx";
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // Enable finishing flag on private data
                data.finish = true;
                // Empty the queue first
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) hooks.stop.call(this, true);
                // Look for any active animations, and finish them
                for(index = timers.length; index--;)if (timers[index].elem === this && timers[index].queue === type) {
                    timers[index].anim.stop(true);
                    timers.splice(index, 1);
                }
                // Look for any animations in the old queue and finish them
                for(index = 0; index < length; index++)if (queue[index] && queue[index].finish) queue[index].finish.call(this);
                // Turn off finishing flag
                delete data.finish;
            });
        }
    });
    jQuery.each([
        "toggle",
        "show",
        "hide"
    ], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for(; i < timers.length; i++){
            timer = timers[i];
            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) timers.splice(i--, 1);
        }
        if (!timers.length) jQuery.fx.stop();
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (inProgress) return;
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function() {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };
    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window1.setTimeout(next, time);
            hooks.stop = function() {
                window1.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document1.createElement("input"), select = document1.createElement("select"), opt = select.appendChild(document1.createElement("option"));
        input.type = "checkbox";
        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support1.checkOn = input.value !== "";
        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support1.optSelected = opt.selected;
        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document1.createElement("input");
        input.value = "t";
        input.type = "radio";
        support1.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") return jQuery.prop(elem, name, value);
            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            ret = jQuery.find.attr(elem, name);
            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support1.radioValue && value === "radio" && nodeName1(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) elem.value = val;
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, // Attribute names can contain non-HTML whitespace characters
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
            attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) while(name = attrNames[i++])elem.removeAttribute(name);
        }
    });
    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) // Remove boolean attributes when set to false
            jQuery.removeAttr(elem, name);
            else elem.setAttribute(name, name);
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name2) {
        var getter = attrHandle[name2] || jQuery.find.attr;
        attrHandle[name2] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    if (tabindex) return parseInt(tabindex, 10);
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) return 0;
                    return -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });
    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support1.optSelected) jQuery.propHooks.selected = {
        get: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent && parent.parentNode) parent.parentNode.selectedIndex;
            return null;
        },
        set: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) parent.parentNode.selectedIndex;
            }
        }
    };
    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
        if (Array.isArray(value)) return value;
        if (typeof value === "string") return value.match(rnothtmlwhite) || [];
        return [];
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j1, finalValue, i = 0;
            if (isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            classes = classesToArray(value);
            if (classes.length) while(elem = this[i++]){
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                    j1 = 0;
                    while(clazz = classes[j1++])if (cur.indexOf(" " + clazz + " ") < 0) cur += clazz + " ";
                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) elem.setAttribute("class", finalValue);
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j2, finalValue, i = 0;
            if (isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            classes = classesToArray(value);
            if (classes.length) while(elem = this[i++]){
                curValue = getClass(elem);
                // This expression is here for better compressibility (see addClass)
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                    j2 = 0;
                    while(clazz = classes[j2++])// Remove *all* instances
                    while(cur.indexOf(" " + clazz + " ") > -1)cur = cur.replace(" " + clazz + " ", " ");
                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) elem.setAttribute("class", finalValue);
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (typeof stateVal === "boolean" && isValidValue) return stateVal ? this.addClass(value) : this.removeClass(value);
            if (isFunction(value)) return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
            return this.each(function() {
                var className, i, self, classNames;
                if (isValidValue) {
                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);
                    while(className = classNames[i++])// Check each className given, space separated list
                    if (self.hasClass(className)) self.removeClass(className);
                    else self.addClass(className);
                // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) // Store className if set
                    dataPriv.set(this, "__className__", className);
                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while(elem = this[i++]){
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return true;
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value7) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) return ret;
                    ret = elem.value;
                    // Handle most common string cases
                    if (typeof ret === "string") return ret.replace(rreturn, "");
                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }
                return;
            }
            valueIsFunction = isFunction(value7);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) return;
                if (valueIsFunction) val = value7.call(this, i, jQuery(this).val());
                else val = value7;
                // Treat null/undefined as ""; convert numbers to string
                if (val == null) val = "";
                else if (typeof val === "number") val += "";
                else if (Array.isArray(val)) val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + "";
                });
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) this.value = val;
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : // Support: IE <=10 - 11 only
                    // option.text throws exceptions (#14686, #14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) i = max;
                    else i = one ? index : 0;
                    // Loop through all the selected options
                    for(; i < max; i++){
                        option = options[i];
                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                        !option.disabled && (!option.parentNode.disabled || !nodeName1(option.parentNode, "optgroup"))) {
                            // Get the specific value for the option
                            value = jQuery(option).val();
                            // We don't need an array for one selects
                            if (one) return value;
                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while(i--){
                        option = options[i];
                        /* eslint-disable no-cond-assign */ if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) optionSet = true;
                    /* eslint-enable no-cond-assign */ }
                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) elem.selectedIndex = -1;
                    return values;
                }
            }
        }
    });
    // Radios and checkboxes getter/setter
    jQuery.each([
        "radio",
        "checkbox"
    ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
        };
        if (!support1.checkOn) jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    });
    // Return jQuery for attributes-only inclusion
    support1.focusin = "onfocusin" in window1;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
        e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [
                elem || document1
            ], type = hasOwn1.call(event, "type") ? event.type : event, namespaces = hasOwn1.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document1;
            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) return;
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) return;
            if (type.indexOf(".") > -1) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) event.target = elem;
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [
                event
            ] : jQuery.makeArray(data, [
                event
            ]);
            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) return;
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) cur = cur.parentNode;
                for(; cur; cur = cur.parentNode){
                    eventPath.push(cur);
                    tmp = cur;
                }
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document1)) eventPath.push(tmp.defaultView || tmp.parentWindow || window1);
            }
            // Fire handlers on the event path
            i = 0;
            while((cur = eventPath[i++]) && !event.isPropagationStopped()){
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                // jQuery handler
                handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");
                if (handle) handle.apply(cur, data);
                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) event.preventDefault();
                }
            }
            event.type = type;
            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) // Call a native DOM method on the target with the same name as the event.
                // Don't do default actions on window, that's where global variables be (#6170)
                {
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];
                        if (tmp) elem[ontype] = null;
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        if (event.isPropagationStopped()) lastElement.addEventListener(type, stopPropagationCallback);
                        elem[type]();
                        if (event.isPropagationStopped()) lastElement.removeEventListener(type, stopPropagationCallback);
                        jQuery.event.triggered = undefined;
                        if (tmp) elem[ontype] = tmp;
                    }
                }
            }
            return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, true);
        }
    });
    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support1.focusin) jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                // Handle: regular nodes (via `this.ownerDocument`), window
                // (via `this.document`) & document (via `this`).
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) doc.addEventListener(orig, handler, true);
                dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                    doc.removeEventListener(orig, handler, true);
                    dataPriv.remove(doc, fix);
                } else dataPriv.access(doc, fix, attaches);
            }
        };
    });
    var location = window1.location;
    var nonce = {
        guid: Date.now()
    };
    var rquery = /\?/;
    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") return null;
        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = new window1.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {}
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
        }).join("\n") : data));
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) // Serialize array item.
        jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) // Treat each array item as a scalar.
            add(prefix, v);
            else // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        });
        else if (!traditional && toType(obj) === "object") // Serialize object item.
        for(name in obj)buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        else // Serialize scalar item.
        add(prefix, obj);
    }
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            // If value is a function, invoke it and use its return value
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a == null) return "";
        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) // Serialize the form elements
        jQuery.each(a, function() {
            add(this.name, this.value);
        });
        else // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for(prefix in a)buildParams(prefix, a[prefix], traditional, add);
        // Return the resulting serialization
        return s.join("&");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
                var val1 = jQuery(this).val();
                if (val1 == null) return null;
                if (Array.isArray(val1)) return jQuery.map(val1, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                });
                return {
                    name: elem.name,
                    value: val1.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */ prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */ transports = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"), // Anchor tag for parsing the document origin
    originAnchor = document1.createElement("a");
    originAnchor.href = location.href;
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while(dataType = dataTypes[i++])// Prepend if requested
                if (dataType[0] === "+") {
                    dataType = dataType.slice(1) || "*";
                    (structure[dataType] = structure[dataType] || []).unshift(func);
                // Otherwise append
                } else (structure[dataType] = structure[dataType] || []).push(func);
            }
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) return !(selected = dataTypeOrTransport);
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for(key in src)if (src[key] !== undefined) (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        if (deep) jQuery.extend(true, target, deep);
        return target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */ function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        // Remove auto dataType and get content-type in the process
        while(dataTypes[0] === "*"){
            dataTypes.shift();
            if (ct === undefined) ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
        // Check if we're dealing with a known content-type
        if (ct) {
            for(type in contents)if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
            }
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
        else {
            // Try convertible dataTypes
            for(type in responses){
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) firstDataType = type;
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) dataTypes.unshift(finalDataType);
            return responses[finalDataType];
        }
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */ function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) for(conv in s.converters)converters[conv.toLowerCase()] = s.converters[conv];
        current = dataTypes.shift();
        // Convert to each sequential dataType
        while(current){
            if (s.responseFields[current]) jqXHR[s.responseFields[current]] = response;
            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) response = s.dataFilter(response, s.dataType);
            prev = current;
            current = dataTypes.shift();
            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === "*") current = prev;
                else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];
                    // If none found, seek a pair
                    if (!conv) for(conv2 in converters){
                        // If conv2 outputs current
                        tmp = conv2.split(" ");
                        if (tmp[1] === current) {
                            // If prev can be converted to accepted input
                            conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                            if (conv) {
                                // Condense equivalence converters
                                if (conv === true) conv = converters[conv2];
                                else if (converters[conv2] !== true) {
                                    current = tmp[0];
                                    dataTypes.unshift(tmp[1]);
                                }
                                break;
                            }
                        }
                    }
                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) response = conv(response);
                        else try {
                            response = conv(response);
                        } catch (e) {
                            return {
                                state: "parsererror",
                                error: conv ? e : "No conversion from " + prev + " to " + current
                            };
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/ accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": JSON.parse,
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            return settings ? // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            // Force options to be an object
            options = options || {};
            var transport, // URL without anti-cache param
            cacheURL, // Response headers
            responseHeadersString, responseHeaders, // timeout handle
            timeoutTimer, // Url cleanup var
            urlAnchor, // Request state (becomes false upon send and true upon completion)
            completed, // To know if global events are to be dispatched
            fireGlobals, // Loop variable
            i, // uncached part of the url
            uncached, // Create the final options object
            s = jQuery.ajaxSetup({}, options), // Callbacks context
            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), // Status-dependent callbacks
            statusCode = s.statusCode || {}, // Headers (they are sent all at once)
            requestHeaders = {}, requestHeadersNames = {}, // Default abort message
            strAbort = "canceled", // Fake xhr
            jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while(match = rheaders.exec(responseHeadersString))responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                        }
                        match = responseHeaders[key.toLowerCase() + " "];
                    }
                    return match == null ? null : match.join(", ");
                },
                // Raw string
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                    if (completed == null) {
                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (completed == null) s.mimeType = type;
                    return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (completed) // Execute the appropriate callbacks
                        jqXHR.always(map[jqXHR.status]);
                        else // Lazy-add the new callbacks in a way that preserves old ones
                        for(code in map)statusCode[code] = [
                            statusCode[code],
                            map[code]
                        ];
                    }
                    return this;
                },
                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) transport.abort(finalText);
                    done(0, finalText);
                    return this;
                }
            };
            // Attach deferreds
            deferred.promise(jqXHR);
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;
            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [
                ""
            ];
            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document1.createElement("a");
                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;
                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }
            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") s.data = jQuery.param(s.data, s.traditional);
            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            // If request was aborted inside a prefilter, stop there
            if (completed) return jqXHR;
            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;
            // Watch for a new set of requests
            if (fireGlobals && (jQuery.active++) === 0) jQuery.event.trigger("ajaxStart");
            // Uppercase the type
            s.type = s.type.toUpperCase();
            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");
            // More options handling for requests with no content
            if (!s.hasContent) {
                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);
                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
                }
                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;
            // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) s.data = s.data.replace(r20, "+");
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                if (jQuery.etag[cacheURL]) jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) jqXHR.setRequestHeader("Content-Type", s.contentType);
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            // Check for headers option
            for(i in s.headers)jqXHR.setRequestHeader(i, s.headers[i]);
            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) // Abort if not done already and return
            return jqXHR.abort();
            // Aborting is no longer a cancellation
            strAbort = "abort";
            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            // If no transport, we auto-abort
            if (!transport) done(-1, "No Transport");
            else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) globalEventContext.trigger("ajaxSend", [
                    jqXHR,
                    s
                ]);
                // If request was aborted inside ajaxSend, stop there
                if (completed) return jqXHR;
                // Timeout
                if (s.async && s.timeout > 0) timeoutTimer = window1.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout);
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Rethrow post-completion exceptions
                    if (completed) throw e;
                    // Propagate others as results
                    done(-1, e);
                }
            }
            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                // Ignore repeat invocations
                if (completed) return;
                completed = true;
                // Clear timeout if it exists
                if (timeoutTimer) window1.clearTimeout(timeoutTimer);
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
                // Cache response headers
                responseHeadersString = headers || "";
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
                // Get response data
                if (responses) response = ajaxHandleResponses(s, jqXHR, responses);
                // Use a noop converter for missing script but not if jsonp
                if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) s.converters["text script"] = function() {};
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) jQuery.lastModified[cacheURL] = modified;
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) jQuery.etag[cacheURL] = modified;
                    }
                    // if no content
                    if (status === 204 || s.type === "HEAD") statusText = "nocontent";
                    else if (status === 304) statusText = "notmodified";
                    else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) status = 0;
                    }
                }
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                // Success/Error
                if (isSuccess) deferred.resolveWith(callbackContext, [
                    success,
                    statusText,
                    jqXHR
                ]);
                else deferred.rejectWith(callbackContext, [
                    jqXHR,
                    statusText,
                    error
                ]);
                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
                    jqXHR,
                    s,
                    isSuccess ? success : error
                ]);
                // Complete
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [
                        jqXHR,
                        s
                    ]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) jQuery.event.trigger("ajaxStop");
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([
        "get",
        "post"
    ], function(_i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery.ajaxPrefilter(function(s) {
        var i;
        for(i in s.headers)if (i.toLowerCase() === "content-type") s.contentType = s.headers[i] || "";
    });
    jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
            url: url,
            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
                "text script": function() {}
            },
            dataFilter: function(response) {
                jQuery.globalEval(response, options, doc);
            }
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (this[0]) {
                if (isFunction(html)) html = html.call(this[0]);
                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) wrap.insertBefore(this[0]);
                wrap.map(function() {
                    var elem = this;
                    while(elem.firstElementChild)elem = elem.firstElementChild;
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            });
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) contents.wrapAll(html);
                else self.append(html);
            });
        },
        wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window1.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support1.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support1.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        // Cross domain only allowed if supported through XMLHttpRequest
        if (support1.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(options.type, options.url, options.async, options.username, options.password);
                // Apply custom fields if provided
                if (options.xhrFields) for(i in options.xhrFields)xhr[i] = options.xhrFields[i];
                // Override mime type if needed
                if (options.mimeType && xhr.overrideMimeType) xhr.overrideMimeType(options.mimeType);
                // X-Requested-With header
                // For cross-domain requests, seeing as conditions for a preflight are
                // akin to a jigsaw puzzle, we simply never set it to be sure.
                // (it can always be set on a per-request basis or even using ajaxSetup)
                // For same-domain requests, won't change header if already provided.
                if (!options.crossDomain && !headers["X-Requested-With"]) headers["X-Requested-With"] = "XMLHttpRequest";
                // Set headers
                for(i in headers)xhr.setRequestHeader(i, headers[i]);
                // Callback
                callback = function(type) {
                    return function() {
                        if (callback) {
                            callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                            if (type === "abort") xhr.abort();
                            else if (type === "error") {
                                // Support: IE <=9 only
                                // On a manual native abort, IE9 throws
                                // errors on any property access that is not readyState
                                if (typeof xhr.status !== "number") complete(0, "error");
                                else complete(// File: protocol always yields status 0; see #8605, #14207
                                xhr.status, xhr.statusText);
                            } else complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders());
                        }
                    };
                };
                // Listen to events
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                // Support: IE 9 only
                // Use onreadystatechange to replace onabort
                // to handle uncaught aborts
                if (xhr.onabort !== undefined) xhr.onabort = errorCallback;
                else xhr.onreadystatechange = function() {
                    // Check readyState before timeout as it changes
                    if (xhr.readyState === 4) // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window1.setTimeout(function() {
                        if (callback) errorCallback();
                    });
                };
                // Create the abort callback
                callback = callback("abort");
                try {
                    // Do send the request (this may raise an exception)
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    // #14683: Only rethrow if this hasn't been notified as an error yet
                    if (callback) throw e;
                }
            },
            abort: function() {
                if (callback) callback();
            }
        };
    });
    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function(s) {
        if (s.crossDomain) s.contents.script = false;
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) s.cache = false;
        if (s.crossDomain) s.type = "GET";
    });
    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) complete(evt.type === "error" ? 404 : 200, evt.type);
                    });
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document1.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
        }
    });
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            // Insert callback into url or form data
            if (jsonProp) s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            else if (s.jsonp !== false) s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) jQuery.error(callbackName + " was not called");
                return responseContainer[0];
            };
            // Force json dataType
            s.dataTypes[0] = "json";
            // Install callback
            overwritten = window1[callbackName];
            window1[callbackName] = function() {
                responseContainer = arguments;
            };
            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // If previous value didn't exist - remove it
                if (overwritten === undefined) jQuery(window1).removeProp(callbackName);
                else window1[callbackName] = overwritten;
                // Save back as free
                if (s[callbackName]) {
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }
                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) overwritten(responseContainer[0]);
                responseContainer = overwritten = undefined;
            });
            // Delegate to script
            return "script";
        }
    });
    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support1.createHTMLDocument = function() {
        var body = document1.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    }();
    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") return [];
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support1.createHTMLDocument) {
                context = document1.implementation.createHTMLDocument("");
                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document1.location.href;
                context.head.appendChild(base);
            } else context = document1;
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        // Single tag
        if (parsed) return [
            context.createElement(parsed[1])
        ];
        parsed = buildFragment([
            data
        ], context, scripts);
        if (scripts && scripts.length) jQuery(scripts).remove();
        return jQuery.merge([], parsed.childNodes);
    };
    /**
 * Load a url into a page
 */ jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        // If it's a function
        if (isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;
        // Otherwise, build a param string
        } else if (params && typeof params === "object") type = "POST";
        // If we have elements to modify, make the request
        if (self.length > 0) jQuery.ajax({
            url: url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            // Save response for use in complete callback
            response = arguments;
            self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
            responseText);
        // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        });
        return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            // Set position first, in-case top/left are set even on static elem
            if (position === "static") elem.style.position = "relative";
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call(elem, i, jQuery.extend({}, curOffset));
            if (options.top != null) props.top = options.top - curOffset.top + curTop;
            if (options.left != null) props.left = options.left - curOffset.left + curLeft;
            if ("using" in options) options.using.call(elem, props);
            else curElem.css(props);
        }
    };
    jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
            // Preserve chaining for setter
            if (arguments.length) return options === undefined ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var rect, win, elem = this[0];
            if (!elem) return;
            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) return {
                top: 0,
                left: 0
            };
            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
            if (!this[0]) return;
            var offsetParent, offset, doc, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") // Assume position:fixed implies availability of getBoundingClientRect
            offset = elem.getBoundingClientRect();
            else {
                offset = this.offset();
                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while(offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.parentNode;
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }
            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while(offsetParent && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement;
            });
        }
    });
    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method1, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method1] = function(val2) {
            return access(this, function(elem, method, val) {
                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) win = elem;
                else if (elem.nodeType === 9) win = elem.defaultView;
                if (val === undefined) return win ? win[prop] : elem[method];
                if (win) win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                else elem[method] = val;
            }, method1, val2, arguments.length);
        };
    });
    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each([
        "top",
        "left"
    ], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support1.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type1) {
        jQuery.each({
            padding: "inner" + name,
            content: type1,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value8) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value8 === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (isWindow(elem)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) : // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type1, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function(_i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    var rtrim1 = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }
        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) return undefined;
        // Simulated bind
        args = slice1.call(arguments, 2);
        proxy = function() {
            return fn.apply(context || this, args.concat(slice1.call(arguments)));
        };
        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
    };
    jQuery.holdReady = function(hold) {
        if (hold) jQuery.readyWait++;
        else jQuery.ready(true);
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName1;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim1, "");
    };
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    if (typeof define === "function" && define.amd) define("jquery", [], function() {
        return jQuery;
    });
    var // Map over jQuery in case of overwrite
    _jQuery = window1.jQuery, // Map over the $ in case of overwrite
    _$ = window1.$;
    jQuery.noConflict = function(deep) {
        if (window1.$ === jQuery) window1.$ = _$;
        if (deep && window1.jQuery === jQuery) window1.jQuery = _jQuery;
        return jQuery;
    };
    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === "undefined") window1.jQuery = window1.$ = jQuery;
    return jQuery;
});


var $1023b8a9a7973857$exports = {};
$1023b8a9a7973857$exports = "body {\n  font-family: var(--body-font-family);\n  font-size: var(--body-font-size);\n  font-weight: var(--body-font-weight);\n  line-height: var(--body-line-height);\n  color: var(--body-color);\n  text-align: var(--body-text-align);\n  background-color: var(--body-bg);\n  -webkit-text-size-adjust: 100%;\n  -webkit-tap-highlight-color: transparent;\n  margin: 0;\n}\n\njuel-dialog-manager > *, .hide {\n  display: none;\n}\n\n.fullscreen {\n  width: 100vw;\n  height: 100vh;\n}\n\n.flex, .flex form {\n  flex-direction: column;\n  display: flex;\n}\n\n.icon {\n  width: 48px;\n  height: 48px;\n}\n\n.icon-md {\n  width: 32px;\n  height: 32px;\n}\n\n.icon-sm {\n  width: 16px;\n  height: 16px;\n}\n\n:root {\n  --primary: #007bff;\n  --primary-text: #343a40;\n  --secondary: #6c757d;\n  --secondary-text: #f8f9fa;\n  --tertiary: salmon;\n  --tertiary-text: salmon;\n  --highlight: #007bff;\n  --active: #e7f1ff --light: #f8f9fa;\n  --dark: #343a40;\n  --success: #28a745;\n  --info: #17a2b8;\n  --warning: #ffc107;\n  --danger: #dc3545;\n  --highlight-text: #343a40;\n  --active-text: #0c63e4;\n  --light-text: #f8f9fa;\n  --dark-text: #343a40;\n  --success-text: #28a745;\n  --info-text: #343a40;\n  --warning-text: #343a40;\n  --danger-text: #dc3545;\n  --icon-previous: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20fill%3D%22var%28--fil%2C%20%2323fff%29%22%20d%3D%22M11.354%201.646a.5.5%200%200%201%200%20.708L5.707%208l5.647%205.646a.5.5%200%200%201-.708.708l-6-6a.5.5%200%200%201%200-.708l6-6a.5.5%200%200%201%20.708%200z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-next: url(\"data:image/svg+xml,%3Ccsvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20fill%3D%22var%28--fill%2C%20%2323fff%29%22%20d%3D%22M4.646%201.646a.5.5%200%200%201%20.708%200l6%206a.5.5%200%200%201%200%20.708l-6%206a.5.5%200%200%201-.708-.708L10.293%208%204.646%202.354a.5.5%200%200%201%200-.708z%22%3E%3C%2Fpath%3E%3C%2Fcsvg%3E\");\n  --icon-indicator: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22rgba%28280%2C0%2C0%2C.5%29%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%222%22%20d%3D%22M5%2014l6-6-6-6%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-crosshair: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20id%3D%22root%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%3E%3Ccircle%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20cx%3D%228%22%20cy%3D%228%22%20r%3D%226%22%3E%3C%2Fcircle%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%208%200%20L%208%206.5%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%200%208%20L%206.5%208%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%208%209.5%20L%208%2016%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20d%3D%22M%209.5%208%20L%2016%208%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-close: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220px%22%20height%3D%2220px%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20fill%3D%22var%28--fill%2C%20black%29%22%20d%3D%22M%204.7070312%203.2929688%20L%203.2929688%204.7070312%20L%2010.585938%2012%20L%203.2929688%2019.292969%20L%204.7070312%2020.707031%20L%2012%2013.414062%20L%2019.292969%2020.707031%20L%2020.707031%2019.292969%20L%2013.414062%2012%20L%2020.707031%204.7070312%20L%2019.292969%203.2929688%20L%2012%2010.585938%20L%204.7070312%203.2929688%20z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --icon-tick: url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2020%2020%22%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22var%28--stroke%2C%20black%29%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%223%22%20d%3D%22M6%2010l3%203l6-6%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n  --justify: center;\n  --padding-left: 32px;\n  --padding-right: 32px;\n  --body-color-rgb: 33, 37, 41;\n  --body-bg-rgb: 255, 255, 255;\n  --font-sans-serif: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Liberation Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n  --font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  --gradient: linear-gradient(180deg, #ffffff26, #fff0);\n  --body-font-family: var(--bs-font-sans-serif);\n  --body-font-size: 1rem;\n  --body-font-weight: 400;\n  --body-line-height: 1.5;\n  --body-color: #212529;\n}\n\n::part(ripple) {\n  background-color: #ffffffb3;\n  border-radius: 50%;\n  animation: ripple .6s linear;\n  position: absolute;\n  transform: scale(0);\n}\n\n";


window.juel = (0, $66369552d2da71b5$export$80e45fb591232624);
window.$ = (0, (/*@__PURE__*/$parcel$interopDefault($9742dbc094643ff0$exports)));
window.jQuery = (0, (/*@__PURE__*/$parcel$interopDefault($9742dbc094643ff0$exports)));
(function() {
    let style = document.createElement("style");
    style.id = "juel-styles";
    style.textContent = (0, (/*@__PURE__*/$parcel$interopDefault($1023b8a9a7973857$exports)));
    document.head.append(style);
})();


function $88b1143c261b729c$export$af899be8b8440dd5() {
    if ("isMobile" in window) return window.isMobile;
    else {
        window["isMobile"] = window.matchMedia("(max-device-width: 500px)").matches || window.matchMedia("(max-device-height: 500px)").matches;
        return window["isMobile"];
    }
}


function $d2e5bb9409e4cccd$export$81eb3b81d17ebff1() {
    let root = document.documentElement;
    function updateRealViewportDimensions() {
        root.style.setProperty("--vh", window.innerHeight / 100 + "px");
    }
    updateRealViewportDimensions();
    const vhChangeEventTypes = [
        "scroll",
        "resize",
        "fullscreenchange",
        "fullscreenerror",
        "touchcancel",
        "touchend",
        "touchmove",
        "touchstart",
        "mozbrowserscroll",
        "mozbrowserscrollareachanged",
        "mozbrowserscrollviewchange",
        "mozbrowserresize",
        "MozScrolledAreaChanged",
        "mozbrowserresize",
        "orientationchange"
    ];
    vhChangeEventTypes.forEach(function(type) {
        window.addEventListener(type, (event)=>updateRealViewportDimensions());
    });
}


var $5c4d424c0d6a93d1$exports = {};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $0e96f61157968e0c$export$b4d10f6001c083c2 = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, $0e96f61157968e0c$var$e = Symbol(), $0e96f61157968e0c$var$n = new Map;
class $0e96f61157968e0c$export$505d1e8739bad805 {
    constructor(t1, n1){
        if (this._$cssResult$ = !0, n1 !== $0e96f61157968e0c$var$e) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t1;
    }
    get styleSheet() {
        let e1 = $0e96f61157968e0c$var$n.get(this.cssText);
        return $0e96f61157968e0c$export$b4d10f6001c083c2 && void 0 === e1 && ($0e96f61157968e0c$var$n.set(this.cssText, e1 = new CSSStyleSheet), e1.replaceSync(this.cssText)), e1;
    }
    toString() {
        return this.cssText;
    }
}
const $0e96f61157968e0c$export$8d80f9cac07cdb3 = (t2)=>new $0e96f61157968e0c$export$505d1e8739bad805("string" == typeof t2 ? t2 : t2 + "", $0e96f61157968e0c$var$e), $0e96f61157968e0c$export$dbf350e5966cf602 = (t3, ...n2)=>{
    const o1 = 1 === t3.length ? t3[0] : n2.reduce((e2, n3, s1)=>e2 + ((t4)=>{
            if (!0 === t4._$cssResult$) return t4.cssText;
            if ("number" == typeof t4) return t4;
            throw Error("Value passed to 'css' function must be a 'css' function result: " + t4 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
        })(n3) + t3[s1 + 1], t3[0]);
    return new $0e96f61157968e0c$export$505d1e8739bad805(o1, $0e96f61157968e0c$var$e);
}, $0e96f61157968e0c$export$2ca4a66ec4cecb90 = (e3, n4)=>{
    $0e96f61157968e0c$export$b4d10f6001c083c2 ? e3.adoptedStyleSheets = n4.map((t5)=>t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet) : n4.forEach((t6)=>{
        const n5 = document.createElement("style"), s2 = window.litNonce;
        void 0 !== s2 && n5.setAttribute("nonce", s2), n5.textContent = t6.cssText, e3.appendChild(n5);
    });
}, $0e96f61157968e0c$export$ee69dfd951e24778 = $0e96f61157968e0c$export$b4d10f6001c083c2 ? (t7)=>t7 : (t8)=>t8 instanceof CSSStyleSheet ? ((t9)=>{
        let e4 = "";
        for (const n6 of t9.cssRules)e4 += n6.cssText;
        return $0e96f61157968e0c$export$8d80f9cac07cdb3(e4);
    })(t8) : t8;



/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $e3c93d8bd711ce9f$var$s;
const $e3c93d8bd711ce9f$var$e = window.trustedTypes, $e3c93d8bd711ce9f$var$r = $e3c93d8bd711ce9f$var$e ? $e3c93d8bd711ce9f$var$e.emptyScript : "", $e3c93d8bd711ce9f$var$h = window.reactiveElementPolyfillSupport, $e3c93d8bd711ce9f$export$7312b35fbf521afb = {
    toAttribute (t1, i1) {
        switch(i1){
            case Boolean:
                t1 = t1 ? $e3c93d8bd711ce9f$var$r : null;
                break;
            case Object:
            case Array:
                t1 = null == t1 ? t1 : JSON.stringify(t1);
        }
        return t1;
    },
    fromAttribute (t2, i2) {
        let s1 = t2;
        switch(i2){
            case Boolean:
                s1 = null !== t2;
                break;
            case Number:
                s1 = null === t2 ? null : Number(t2);
                break;
            case Object:
            case Array:
                try {
                    s1 = JSON.parse(t2);
                } catch (t) {
                    s1 = null;
                }
        }
        return s1;
    }
}, $e3c93d8bd711ce9f$export$53a6892c50694894 = (t3, i3)=>i3 !== t3 && (i3 == i3 || t3 == t3), $e3c93d8bd711ce9f$var$l = {
    attribute: !0,
    type: String,
    converter: $e3c93d8bd711ce9f$export$7312b35fbf521afb,
    reflect: !1,
    hasChanged: $e3c93d8bd711ce9f$export$53a6892c50694894
};
class $e3c93d8bd711ce9f$export$c7c07a37856565d extends HTMLElement {
    constructor(){
        super(), this._$Et = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Ei = null, this.o();
    }
    static addInitializer(t4) {
        var i4;
        null !== (i4 = this.l) && void 0 !== i4 || (this.l = []), this.l.push(t4);
    }
    static get observedAttributes() {
        this.finalize();
        const t5 = [];
        return this.elementProperties.forEach((i5, s2)=>{
            const e1 = this._$Eh(s2, i5);
            void 0 !== e1 && (this._$Eu.set(e1, s2), t5.push(e1));
        }), t5;
    }
    static createProperty(t6, i6 = $e3c93d8bd711ce9f$var$l) {
        if (i6.state && (i6.attribute = !1), this.finalize(), this.elementProperties.set(t6, i6), !i6.noAccessor && !this.prototype.hasOwnProperty(t6)) {
            const s3 = "symbol" == typeof t6 ? Symbol() : "__" + t6, e2 = this.getPropertyDescriptor(t6, s3, i6);
            void 0 !== e2 && Object.defineProperty(this.prototype, t6, e2);
        }
    }
    static getPropertyDescriptor(t7, i7, s4) {
        return {
            get () {
                return this[i7];
            },
            set (e3) {
                const r1 = this[t7];
                this[i7] = e3, this.requestUpdate(t7, r1, s4);
            },
            configurable: !0,
            enumerable: !0
        };
    }
    static getPropertyOptions(t8) {
        return this.elementProperties.get(t8) || $e3c93d8bd711ce9f$var$l;
    }
    static finalize() {
        if (this.hasOwnProperty("finalized")) return !1;
        this.finalized = !0;
        const t9 = Object.getPrototypeOf(this);
        if (t9.finalize(), this.elementProperties = new Map(t9.elementProperties), this._$Eu = new Map, this.hasOwnProperty("properties")) {
            const t10 = this.properties, i8 = [
                ...Object.getOwnPropertyNames(t10),
                ...Object.getOwnPropertySymbols(t10)
            ];
            for (const s5 of i8)this.createProperty(s5, t10[s5]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), !0;
    }
    static finalizeStyles(i9) {
        const s6 = [];
        if (Array.isArray(i9)) {
            const e4 = new Set(i9.flat(1 / 0).reverse());
            for (const i10 of e4)s6.unshift((0, $0e96f61157968e0c$export$ee69dfd951e24778)(i10));
        } else void 0 !== i9 && s6.push((0, $0e96f61157968e0c$export$ee69dfd951e24778)(i9));
        return s6;
    }
    static _$Eh(t11, i11) {
        const s7 = i11.attribute;
        return !1 === s7 ? void 0 : "string" == typeof s7 ? s7 : "string" == typeof t11 ? t11.toLowerCase() : void 0;
    }
    o() {
        var t12;
        this._$Ep = new Promise((t13)=>this.enableUpdating = t13), this._$AL = new Map, this._$Em(), this.requestUpdate(), null === (t12 = this.constructor.l) || void 0 === t12 || t12.forEach((t14)=>t14(this));
    }
    addController(t15) {
        var i12, s8;
        (null !== (i12 = this._$Eg) && void 0 !== i12 ? i12 : this._$Eg = []).push(t15), void 0 !== this.renderRoot && this.isConnected && (null === (s8 = t15.hostConnected) || void 0 === s8 || s8.call(t15));
    }
    removeController(t16) {
        var i13;
        null === (i13 = this._$Eg) || void 0 === i13 || i13.splice(this._$Eg.indexOf(t16) >>> 0, 1);
    }
    _$Em() {
        this.constructor.elementProperties.forEach((t, i14)=>{
            this.hasOwnProperty(i14) && (this._$Et.set(i14, this[i14]), delete this[i14]);
        });
    }
    createRenderRoot() {
        var t17;
        const s9 = null !== (t17 = this.shadowRoot) && void 0 !== t17 ? t17 : this.attachShadow(this.constructor.shadowRootOptions);
        return (0, $0e96f61157968e0c$export$2ca4a66ec4cecb90)(s9, this.constructor.elementStyles), s9;
    }
    connectedCallback() {
        var t18;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t18 = this._$Eg) || void 0 === t18 || t18.forEach((t19)=>{
            var i15;
            return null === (i15 = t19.hostConnected) || void 0 === i15 ? void 0 : i15.call(t19);
        });
    }
    enableUpdating(t) {}
    disconnectedCallback() {
        var t20;
        null === (t20 = this._$Eg) || void 0 === t20 || t20.forEach((t21)=>{
            var i16;
            return null === (i16 = t21.hostDisconnected) || void 0 === i16 ? void 0 : i16.call(t21);
        });
    }
    attributeChangedCallback(t22, i, s10) {
        this._$AK(t22, s10);
    }
    _$ES(t23, i17, s11 = $e3c93d8bd711ce9f$var$l) {
        var e5, r2;
        const h1 = this.constructor._$Eh(t23, s11);
        if (void 0 !== h1 && !0 === s11.reflect) {
            const n1 = (null !== (r2 = null === (e5 = s11.converter) || void 0 === e5 ? void 0 : e5.toAttribute) && void 0 !== r2 ? r2 : $e3c93d8bd711ce9f$export$7312b35fbf521afb.toAttribute)(i17, s11.type);
            this._$Ei = t23, null == n1 ? this.removeAttribute(h1) : this.setAttribute(h1, n1), this._$Ei = null;
        }
    }
    _$AK(t24, i18) {
        var s12, e6, r3;
        const h2 = this.constructor, n2 = h2._$Eu.get(t24);
        if (void 0 !== n2 && this._$Ei !== n2) {
            const t25 = h2.getPropertyOptions(n2), l1 = t25.converter, a1 = null !== (r3 = null !== (e6 = null === (s12 = l1) || void 0 === s12 ? void 0 : s12.fromAttribute) && void 0 !== e6 ? e6 : "function" == typeof l1 ? l1 : null) && void 0 !== r3 ? r3 : $e3c93d8bd711ce9f$export$7312b35fbf521afb.fromAttribute;
            this._$Ei = n2, this[n2] = a1(i18, t25.type), this._$Ei = null;
        }
    }
    requestUpdate(t26, i19, s13) {
        let e7 = !0;
        void 0 !== t26 && (((s13 = s13 || this.constructor.getPropertyOptions(t26)).hasChanged || $e3c93d8bd711ce9f$export$53a6892c50694894)(this[t26], i19) ? (this._$AL.has(t26) || this._$AL.set(t26, i19), !0 === s13.reflect && this._$Ei !== t26 && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t26, s13))) : e7 = !1), !this.isUpdatePending && e7 && (this._$Ep = this._$E_());
    }
    async _$E_() {
        this.isUpdatePending = !0;
        try {
            await this._$Ep;
        } catch (t27) {
            Promise.reject(t27);
        }
        const t28 = this.scheduleUpdate();
        return null != t28 && await t28, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var t29;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Et && (this._$Et.forEach((t30, i21)=>this[i21] = t30), this._$Et = void 0);
        let i20 = !1;
        const s14 = this._$AL;
        try {
            i20 = this.shouldUpdate(s14), i20 ? (this.willUpdate(s14), null === (t29 = this._$Eg) || void 0 === t29 || t29.forEach((t31)=>{
                var i22;
                return null === (i22 = t31.hostUpdate) || void 0 === i22 ? void 0 : i22.call(t31);
            }), this.update(s14)) : this._$EU();
        } catch (t32) {
            throw i20 = !1, this._$EU(), t32;
        }
        i20 && this._$AE(s14);
    }
    willUpdate(t) {}
    _$AE(t33) {
        var i23;
        null === (i23 = this._$Eg) || void 0 === i23 || i23.forEach((t34)=>{
            var i24;
            return null === (i24 = t34.hostUpdated) || void 0 === i24 ? void 0 : i24.call(t34);
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t33)), this.updated(t33);
    }
    _$EU() {
        this._$AL = new Map, this.isUpdatePending = !1;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$Ep;
    }
    shouldUpdate(t) {
        return !0;
    }
    update(t35) {
        void 0 !== this._$EC && (this._$EC.forEach((t36, i25)=>this._$ES(i25, this[i25], t36)), this._$EC = void 0), this._$EU();
    }
    updated(t) {}
    firstUpdated(t) {}
}
$e3c93d8bd711ce9f$export$c7c07a37856565d.finalized = !0, $e3c93d8bd711ce9f$export$c7c07a37856565d.elementProperties = new Map, $e3c93d8bd711ce9f$export$c7c07a37856565d.elementStyles = [], $e3c93d8bd711ce9f$export$c7c07a37856565d.shadowRootOptions = {
    mode: "open"
}, null == $e3c93d8bd711ce9f$var$h || $e3c93d8bd711ce9f$var$h({
    ReactiveElement: $e3c93d8bd711ce9f$export$c7c07a37856565d
}), (null !== ($e3c93d8bd711ce9f$var$s = globalThis.reactiveElementVersions) && void 0 !== $e3c93d8bd711ce9f$var$s ? $e3c93d8bd711ce9f$var$s : globalThis.reactiveElementVersions = []).push("1.3.2");


/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $37260750aa7b368d$var$t;
const $37260750aa7b368d$var$i = globalThis.trustedTypes, $37260750aa7b368d$var$s = $37260750aa7b368d$var$i ? $37260750aa7b368d$var$i.createPolicy("lit-html", {
    createHTML: (t1)=>t1
}) : void 0, $37260750aa7b368d$var$e = `lit$${(Math.random() + "").slice(9)}$`, $37260750aa7b368d$var$o = "?" + $37260750aa7b368d$var$e, $37260750aa7b368d$var$n = `<${$37260750aa7b368d$var$o}>`, $37260750aa7b368d$var$l = document, $37260750aa7b368d$var$h = (t2 = "")=>$37260750aa7b368d$var$l.createComment(t2), $37260750aa7b368d$var$r = (t3)=>null === t3 || "object" != typeof t3 && "function" != typeof t3, $37260750aa7b368d$var$d = Array.isArray, $37260750aa7b368d$var$u = (t4)=>{
    var i1;
    return $37260750aa7b368d$var$d(t4) || "function" == typeof (null === (i1 = t4) || void 0 === i1 ? void 0 : i1[Symbol.iterator]);
}, $37260750aa7b368d$var$c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, $37260750aa7b368d$var$v = /-->/g, $37260750aa7b368d$var$a = />/g, $37260750aa7b368d$var$f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, $37260750aa7b368d$var$_ = /'/g, $37260750aa7b368d$var$m = /"/g, $37260750aa7b368d$var$g = /^(?:script|style|textarea|title)$/i, $37260750aa7b368d$var$p = (t5)=>(i2, ...s1)=>({
            _$litType$: t5,
            strings: i2,
            values: s1
        }), $37260750aa7b368d$export$c0bb0b647f701bb5 = $37260750aa7b368d$var$p(1), $37260750aa7b368d$export$7ed1367e7fa1ad68 = $37260750aa7b368d$var$p(2), $37260750aa7b368d$export$9c068ae9cc5db4e8 = Symbol.for("lit-noChange"), $37260750aa7b368d$export$45b790e32b2810ee = Symbol.for("lit-nothing"), $37260750aa7b368d$var$T = new WeakMap, $37260750aa7b368d$export$b3890eb0ae9dca99 = (t7, i3, s2)=>{
    var e1, o1;
    const n1 = null !== (e1 = null == s2 ? void 0 : s2.renderBefore) && void 0 !== e1 ? e1 : i3;
    let l1 = n1._$litPart$;
    if (void 0 === l1) {
        const t6 = null !== (o1 = null == s2 ? void 0 : s2.renderBefore) && void 0 !== o1 ? o1 : null;
        n1._$litPart$ = l1 = new $37260750aa7b368d$var$N(i3.insertBefore($37260750aa7b368d$var$h(), t6), t6, void 0, null != s2 ? s2 : {});
    }
    return l1._$AI(t7), l1;
}, $37260750aa7b368d$var$A = $37260750aa7b368d$var$l.createTreeWalker($37260750aa7b368d$var$l, 129, null, !1), $37260750aa7b368d$var$C = (t8, i5)=>{
    const o2 = t8.length - 1, l2 = [];
    let h1, r1 = 2 === i5 ? "<svg>" : "", d1 = $37260750aa7b368d$var$c;
    for(let i4 = 0; i4 < o2; i4++){
        const s3 = t8[i4];
        let o3, u1, p1 = -1, $1 = 0;
        for(; $1 < s3.length && (d1.lastIndex = $1, u1 = d1.exec(s3), null !== u1);)$1 = d1.lastIndex, d1 === $37260750aa7b368d$var$c ? "!--" === u1[1] ? d1 = $37260750aa7b368d$var$v : void 0 !== u1[1] ? d1 = $37260750aa7b368d$var$a : void 0 !== u1[2] ? ($37260750aa7b368d$var$g.test(u1[2]) && (h1 = RegExp("</" + u1[2], "g")), d1 = $37260750aa7b368d$var$f) : void 0 !== u1[3] && (d1 = $37260750aa7b368d$var$f) : d1 === $37260750aa7b368d$var$f ? ">" === u1[0] ? (d1 = null != h1 ? h1 : $37260750aa7b368d$var$c, p1 = -1) : void 0 === u1[1] ? p1 = -2 : (p1 = d1.lastIndex - u1[2].length, o3 = u1[1], d1 = void 0 === u1[3] ? $37260750aa7b368d$var$f : '"' === u1[3] ? $37260750aa7b368d$var$m : $37260750aa7b368d$var$_) : d1 === $37260750aa7b368d$var$m || d1 === $37260750aa7b368d$var$_ ? d1 = $37260750aa7b368d$var$f : d1 === $37260750aa7b368d$var$v || d1 === $37260750aa7b368d$var$a ? d1 = $37260750aa7b368d$var$c : (d1 = $37260750aa7b368d$var$f, h1 = void 0);
        const y1 = d1 === $37260750aa7b368d$var$f && t8[i4 + 1].startsWith("/>") ? " " : "";
        r1 += d1 === $37260750aa7b368d$var$c ? s3 + $37260750aa7b368d$var$n : p1 >= 0 ? (l2.push(o3), s3.slice(0, p1) + "$lit$" + s3.slice(p1) + $37260750aa7b368d$var$e + y1) : s3 + $37260750aa7b368d$var$e + (-2 === p1 ? (l2.push(void 0), i4) : y1);
    }
    const u2 = r1 + (t8[o2] || "<?>") + (2 === i5 ? "</svg>" : "");
    if (!Array.isArray(t8) || !t8.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [
        void 0 !== $37260750aa7b368d$var$s ? $37260750aa7b368d$var$s.createHTML(u2) : u2,
        l2
    ];
};
class $37260750aa7b368d$var$E {
    constructor({ strings: t9 , _$litType$: s4  }, n2){
        let l3;
        this.parts = [];
        let r2 = 0, d2 = 0;
        const u3 = t9.length - 1, c1 = this.parts, [v1, a1] = $37260750aa7b368d$var$C(t9, s4);
        if (this.el = $37260750aa7b368d$var$E.createElement(v1, n2), $37260750aa7b368d$var$A.currentNode = this.el.content, 2 === s4) {
            const t10 = this.el.content, i6 = t10.firstChild;
            i6.remove(), t10.append(...i6.childNodes);
        }
        for(; null !== (l3 = $37260750aa7b368d$var$A.nextNode()) && c1.length < u3;){
            if (1 === l3.nodeType) {
                if (l3.hasAttributes()) {
                    const t11 = [];
                    for (const i8 of l3.getAttributeNames())if (i8.endsWith("$lit$") || i8.startsWith($37260750aa7b368d$var$e)) {
                        const s5 = a1[d2++];
                        if (t11.push(i8), void 0 !== s5) {
                            const t12 = l3.getAttribute(s5.toLowerCase() + "$lit$").split($37260750aa7b368d$var$e), i9 = /([.?@])?(.*)/.exec(s5);
                            c1.push({
                                type: 1,
                                index: r2,
                                name: i9[2],
                                strings: t12,
                                ctor: "." === i9[1] ? $37260750aa7b368d$var$M : "?" === i9[1] ? $37260750aa7b368d$var$H : "@" === i9[1] ? $37260750aa7b368d$var$I : $37260750aa7b368d$var$S
                            });
                        } else c1.push({
                            type: 6,
                            index: r2
                        });
                    }
                    for (const i7 of t11)l3.removeAttribute(i7);
                }
                if ($37260750aa7b368d$var$g.test(l3.tagName)) {
                    const t13 = l3.textContent.split($37260750aa7b368d$var$e), s6 = t13.length - 1;
                    if (s6 > 0) {
                        l3.textContent = $37260750aa7b368d$var$i ? $37260750aa7b368d$var$i.emptyScript : "";
                        for(let i10 = 0; i10 < s6; i10++)l3.append(t13[i10], $37260750aa7b368d$var$h()), $37260750aa7b368d$var$A.nextNode(), c1.push({
                            type: 2,
                            index: ++r2
                        });
                        l3.append(t13[s6], $37260750aa7b368d$var$h());
                    }
                }
            } else if (8 === l3.nodeType) {
                if (l3.data === $37260750aa7b368d$var$o) c1.push({
                    type: 2,
                    index: r2
                });
                else {
                    let t14 = -1;
                    for(; -1 !== (t14 = l3.data.indexOf($37260750aa7b368d$var$e, t14 + 1));)c1.push({
                        type: 7,
                        index: r2
                    }), t14 += $37260750aa7b368d$var$e.length - 1;
                }
            }
            r2++;
        }
    }
    static createElement(t15, i) {
        const s7 = $37260750aa7b368d$var$l.createElement("template");
        return s7.innerHTML = t15, s7;
    }
}
function $37260750aa7b368d$var$P(t16, i15, s8 = t16, e2) {
    var o4, n3, l4, h2;
    if (i15 === $37260750aa7b368d$export$9c068ae9cc5db4e8) return i15;
    let d3 = void 0 !== e2 ? null === (o4 = s8._$Cl) || void 0 === o4 ? void 0 : o4[e2] : s8._$Cu;
    const u4 = $37260750aa7b368d$var$r(i15) ? void 0 : i15._$litDirective$;
    return (null == d3 ? void 0 : d3.constructor) !== u4 && (null === (n3 = null == d3 ? void 0 : d3._$AO) || void 0 === n3 || n3.call(d3, !1), void 0 === u4 ? d3 = void 0 : (d3 = new u4(t16), d3._$AT(t16, s8, e2)), void 0 !== e2 ? (null !== (l4 = (h2 = s8)._$Cl) && void 0 !== l4 ? l4 : h2._$Cl = [])[e2] = d3 : s8._$Cu = d3), void 0 !== d3 && (i15 = $37260750aa7b368d$var$P(t16, d3._$AS(t16, i15.values), d3, e2)), i15;
}
class $37260750aa7b368d$var$V {
    constructor(t17, i16){
        this.v = [], this._$AN = void 0, this._$AD = t17, this._$AM = i16;
    }
    get parentNode() {
        return this._$AM.parentNode;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    p(t18) {
        var i17;
        const { el: { content: s9  } , parts: e3  } = this._$AD, o5 = (null !== (i17 = null == t18 ? void 0 : t18.creationScope) && void 0 !== i17 ? i17 : $37260750aa7b368d$var$l).importNode(s9, !0);
        $37260750aa7b368d$var$A.currentNode = o5;
        let n4 = $37260750aa7b368d$var$A.nextNode(), h3 = 0, r3 = 0, d4 = e3[0];
        for(; void 0 !== d4;){
            if (h3 === d4.index) {
                let i18;
                2 === d4.type ? i18 = new $37260750aa7b368d$var$N(n4, n4.nextSibling, this, t18) : 1 === d4.type ? i18 = new d4.ctor(n4, d4.name, d4.strings, this, t18) : 6 === d4.type && (i18 = new $37260750aa7b368d$var$L(n4, this, t18)), this.v.push(i18), d4 = e3[++r3];
            }
            h3 !== (null == d4 ? void 0 : d4.index) && (n4 = $37260750aa7b368d$var$A.nextNode(), h3++);
        }
        return o5;
    }
    m(t19) {
        let i19 = 0;
        for (const s10 of this.v)void 0 !== s10 && (void 0 !== s10.strings ? (s10._$AI(t19, s10, i19), i19 += s10.strings.length - 2) : s10._$AI(t19[i19])), i19++;
    }
}
class $37260750aa7b368d$var$N {
    constructor(t20, i20, s11, e4){
        var o6;
        this.type = 2, this._$AH = $37260750aa7b368d$export$45b790e32b2810ee, this._$AN = void 0, this._$AA = t20, this._$AB = i20, this._$AM = s11, this.options = e4, this._$Cg = null === (o6 = null == e4 ? void 0 : e4.isConnected) || void 0 === o6 || o6;
    }
    get _$AU() {
        var t21, i21;
        return null !== (i21 = null === (t21 = this._$AM) || void 0 === t21 ? void 0 : t21._$AU) && void 0 !== i21 ? i21 : this._$Cg;
    }
    get parentNode() {
        let t22 = this._$AA.parentNode;
        const i22 = this._$AM;
        return void 0 !== i22 && 11 === t22.nodeType && (t22 = i22.parentNode), t22;
    }
    get startNode() {
        return this._$AA;
    }
    get endNode() {
        return this._$AB;
    }
    _$AI(t23, i23 = this) {
        t23 = $37260750aa7b368d$var$P(this, t23, i23), $37260750aa7b368d$var$r(t23) ? t23 === $37260750aa7b368d$export$45b790e32b2810ee || null == t23 || "" === t23 ? (this._$AH !== $37260750aa7b368d$export$45b790e32b2810ee && this._$AR(), this._$AH = $37260750aa7b368d$export$45b790e32b2810ee) : t23 !== this._$AH && t23 !== $37260750aa7b368d$export$9c068ae9cc5db4e8 && this.$(t23) : void 0 !== t23._$litType$ ? this.T(t23) : void 0 !== t23.nodeType ? this.k(t23) : $37260750aa7b368d$var$u(t23) ? this.S(t23) : this.$(t23);
    }
    M(t24, i24 = this._$AB) {
        return this._$AA.parentNode.insertBefore(t24, i24);
    }
    k(t25) {
        this._$AH !== t25 && (this._$AR(), this._$AH = this.M(t25));
    }
    $(t26) {
        this._$AH !== $37260750aa7b368d$export$45b790e32b2810ee && $37260750aa7b368d$var$r(this._$AH) ? this._$AA.nextSibling.data = t26 : this.k($37260750aa7b368d$var$l.createTextNode(t26)), this._$AH = t26;
    }
    T(t27) {
        var i25;
        const { values: s12 , _$litType$: e5  } = t27, o7 = "number" == typeof e5 ? this._$AC(t27) : (void 0 === e5.el && (e5.el = $37260750aa7b368d$var$E.createElement(e5.h, this.options)), e5);
        if ((null === (i25 = this._$AH) || void 0 === i25 ? void 0 : i25._$AD) === o7) this._$AH.m(s12);
        else {
            const t28 = new $37260750aa7b368d$var$V(o7, this), i26 = t28.p(this.options);
            t28.m(s12), this.k(i26), this._$AH = t28;
        }
    }
    _$AC(t29) {
        let i27 = $37260750aa7b368d$var$T.get(t29.strings);
        return void 0 === i27 && $37260750aa7b368d$var$T.set(t29.strings, i27 = new $37260750aa7b368d$var$E(t29)), i27;
    }
    S(t30) {
        $37260750aa7b368d$var$d(this._$AH) || (this._$AH = [], this._$AR());
        const i28 = this._$AH;
        let s13, e6 = 0;
        for (const o8 of t30)e6 === i28.length ? i28.push(s13 = new $37260750aa7b368d$var$N(this.M($37260750aa7b368d$var$h()), this.M($37260750aa7b368d$var$h()), this, this.options)) : s13 = i28[e6], s13._$AI(o8), e6++;
        e6 < i28.length && (this._$AR(s13 && s13._$AB.nextSibling, e6), i28.length = e6);
    }
    _$AR(t31 = this._$AA.nextSibling, i29) {
        var s14;
        for(null === (s14 = this._$AP) || void 0 === s14 || s14.call(this, !1, !0, i29); t31 && t31 !== this._$AB;){
            const i30 = t31.nextSibling;
            t31.remove(), t31 = i30;
        }
    }
    setConnected(t32) {
        var i31;
        void 0 === this._$AM && (this._$Cg = t32, null === (i31 = this._$AP) || void 0 === i31 || i31.call(this, t32));
    }
}
class $37260750aa7b368d$var$S {
    constructor(t33, i32, s15, e7, o9){
        this.type = 1, this._$AH = $37260750aa7b368d$export$45b790e32b2810ee, this._$AN = void 0, this.element = t33, this.name = i32, this._$AM = e7, this.options = o9, s15.length > 2 || "" !== s15[0] || "" !== s15[1] ? (this._$AH = Array(s15.length - 1).fill(new String), this.strings = s15) : this._$AH = $37260750aa7b368d$export$45b790e32b2810ee;
    }
    get tagName() {
        return this.element.tagName;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t34, i33 = this, s16, e9) {
        const o10 = this.strings;
        let n5 = !1;
        if (void 0 === o10) t34 = $37260750aa7b368d$var$P(this, t34, i33, 0), n5 = !$37260750aa7b368d$var$r(t34) || t34 !== this._$AH && t34 !== $37260750aa7b368d$export$9c068ae9cc5db4e8, n5 && (this._$AH = t34);
        else {
            const e8 = t34;
            let l5, h4;
            for(t34 = o10[0], l5 = 0; l5 < o10.length - 1; l5++)h4 = $37260750aa7b368d$var$P(this, e8[s16 + l5], i33, l5), h4 === $37260750aa7b368d$export$9c068ae9cc5db4e8 && (h4 = this._$AH[l5]), n5 || (n5 = !$37260750aa7b368d$var$r(h4) || h4 !== this._$AH[l5]), h4 === $37260750aa7b368d$export$45b790e32b2810ee ? t34 = $37260750aa7b368d$export$45b790e32b2810ee : t34 !== $37260750aa7b368d$export$45b790e32b2810ee && (t34 += (null != h4 ? h4 : "") + o10[l5 + 1]), this._$AH[l5] = h4;
        }
        n5 && !e9 && this.C(t34);
    }
    C(t35) {
        t35 === $37260750aa7b368d$export$45b790e32b2810ee ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t35 ? t35 : "");
    }
}
class $37260750aa7b368d$var$M extends $37260750aa7b368d$var$S {
    constructor(){
        super(...arguments), this.type = 3;
    }
    C(t36) {
        this.element[this.name] = t36 === $37260750aa7b368d$export$45b790e32b2810ee ? void 0 : t36;
    }
}
const $37260750aa7b368d$var$k = $37260750aa7b368d$var$i ? $37260750aa7b368d$var$i.emptyScript : "";
class $37260750aa7b368d$var$H extends $37260750aa7b368d$var$S {
    constructor(){
        super(...arguments), this.type = 4;
    }
    C(t37) {
        t37 && t37 !== $37260750aa7b368d$export$45b790e32b2810ee ? this.element.setAttribute(this.name, $37260750aa7b368d$var$k) : this.element.removeAttribute(this.name);
    }
}
class $37260750aa7b368d$var$I extends $37260750aa7b368d$var$S {
    constructor(t38, i34, s17, e10, o11){
        super(t38, i34, s17, e10, o11), this.type = 5;
    }
    _$AI(t39, i35 = this) {
        var s18;
        if ((t39 = null !== (s18 = $37260750aa7b368d$var$P(this, t39, i35, 0)) && void 0 !== s18 ? s18 : $37260750aa7b368d$export$45b790e32b2810ee) === $37260750aa7b368d$export$9c068ae9cc5db4e8) return;
        const e11 = this._$AH, o12 = t39 === $37260750aa7b368d$export$45b790e32b2810ee && e11 !== $37260750aa7b368d$export$45b790e32b2810ee || t39.capture !== e11.capture || t39.once !== e11.once || t39.passive !== e11.passive, n6 = t39 !== $37260750aa7b368d$export$45b790e32b2810ee && (e11 === $37260750aa7b368d$export$45b790e32b2810ee || o12);
        o12 && this.element.removeEventListener(this.name, this, e11), n6 && this.element.addEventListener(this.name, this, t39), this._$AH = t39;
    }
    handleEvent(t40) {
        var i36, s19;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s19 = null === (i36 = this.options) || void 0 === i36 ? void 0 : i36.host) && void 0 !== s19 ? s19 : this.element, t40) : this._$AH.handleEvent(t40);
    }
}
class $37260750aa7b368d$var$L {
    constructor(t41, i37, s20){
        this.element = t41, this.type = 6, this._$AN = void 0, this._$AM = i37, this.options = s20;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t42) {
        $37260750aa7b368d$var$P(this, t42);
    }
}
const $37260750aa7b368d$export$8613d1ca9052b22e = {
    L: "$lit$",
    P: $37260750aa7b368d$var$e,
    V: $37260750aa7b368d$var$o,
    I: 1,
    N: $37260750aa7b368d$var$C,
    R: $37260750aa7b368d$var$V,
    j: $37260750aa7b368d$var$u,
    D: $37260750aa7b368d$var$P,
    H: $37260750aa7b368d$var$N,
    F: $37260750aa7b368d$var$S,
    O: $37260750aa7b368d$var$H,
    W: $37260750aa7b368d$var$I,
    B: $37260750aa7b368d$var$M,
    Z: $37260750aa7b368d$var$L
}, $37260750aa7b368d$var$z = window.litHtmlPolyfillSupport;
null == $37260750aa7b368d$var$z || $37260750aa7b368d$var$z($37260750aa7b368d$var$E, $37260750aa7b368d$var$N), (null !== ($37260750aa7b368d$var$t = globalThis.litHtmlVersions) && void 0 !== $37260750aa7b368d$var$t ? $37260750aa7b368d$var$t : globalThis.litHtmlVersions = []).push("2.2.6");






/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $69a66af8deb391ea$var$l, $69a66af8deb391ea$var$o;
const $69a66af8deb391ea$export$8bf27daf9e8907c9 = (0, $e3c93d8bd711ce9f$export$c7c07a37856565d);
class $69a66af8deb391ea$export$3f2f9f5909897157 extends (0, $e3c93d8bd711ce9f$export$c7c07a37856565d) {
    constructor(){
        super(...arguments), this.renderOptions = {
            host: this
        }, this._$Dt = void 0;
    }
    createRenderRoot() {
        var t1, e1;
        const i1 = super.createRenderRoot();
        return null !== (t1 = (e1 = this.renderOptions).renderBefore) && void 0 !== t1 || (e1.renderBefore = i1.firstChild), i1;
    }
    update(t2) {
        const i2 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Dt = (0, $37260750aa7b368d$export$b3890eb0ae9dca99)(i2, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
        var t3;
        super.connectedCallback(), null === (t3 = this._$Dt) || void 0 === t3 || t3.setConnected(!0);
    }
    disconnectedCallback() {
        var t4;
        super.disconnectedCallback(), null === (t4 = this._$Dt) || void 0 === t4 || t4.setConnected(!1);
    }
    render() {
        return 0, $37260750aa7b368d$export$9c068ae9cc5db4e8;
    }
}
$69a66af8deb391ea$export$3f2f9f5909897157.finalized = !0, $69a66af8deb391ea$export$3f2f9f5909897157._$litElement$ = !0, null === ($69a66af8deb391ea$var$l = globalThis.litElementHydrateSupport) || void 0 === $69a66af8deb391ea$var$l || $69a66af8deb391ea$var$l.call(globalThis, {
    LitElement: $69a66af8deb391ea$export$3f2f9f5909897157
});
const $69a66af8deb391ea$var$n = globalThis.litElementPolyfillSupport;
null == $69a66af8deb391ea$var$n || $69a66af8deb391ea$var$n({
    LitElement: $69a66af8deb391ea$export$3f2f9f5909897157
});
const $69a66af8deb391ea$export$f5c524615a7708d6 = {
    _$AK: (t5, e2, i3)=>{
        t5._$AK(e2, i3);
    },
    _$AL: (t6)=>t6._$AL
};
(null !== ($69a66af8deb391ea$var$o = globalThis.litElementVersions) && void 0 !== $69a66af8deb391ea$var$o ? $69a66af8deb391ea$var$o : globalThis.litElementVersions = []).push("3.2.0");




/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $3f78cf6008406935$export$da64fc29f17f9d0e = (n1)=>(e1)=>"function" == typeof e1 ? ((n2, e)=>(window.customElements.define(n2, e), e))(n1, e1) : ((n3, e2)=>{
            const { kind: t , elements: i  } = e2;
            return {
                kind: t,
                elements: i,
                finisher (e) {
                    window.customElements.define(n3, e);
                }
            };
        })(n1, e1);


/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $5fa65b806545cdfc$var$i = (i1, e1)=>"method" === e1.kind && e1.descriptor && !("value" in e1.descriptor) ? {
        ...e1,
        finisher (n) {
            n.createProperty(e1.key, i1);
        }
    } : {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: e1.key,
        initializer () {
            "function" == typeof e1.initializer && (this[e1.key] = e1.initializer.call(this));
        },
        finisher (n) {
            n.createProperty(e1.key, i1);
        }
    };
function $5fa65b806545cdfc$export$d541bacb2bda4494(e2) {
    return (n1, t)=>void 0 !== t ? ((i2, e3, n)=>{
            e3.constructor.createProperty(n, i2);
        })(e2, n1, t) : $5fa65b806545cdfc$var$i(e2, n1);
}



/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $e675fea6c9c9d5e5$export$ca000e230c0caa3e(t1) {
    return (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        ...t1,
        state: !0
    });
}


/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $cd105d2a147899a8$export$29fd0ed4087278b5 = (e1, t1, o1)=>{
    Object.defineProperty(t1, o1, e1);
}, $cd105d2a147899a8$export$18eb0154d0069a01 = (e2, t2)=>({
        kind: "method",
        placement: "prototype",
        key: t2.key,
        descriptor: e2
    }), $cd105d2a147899a8$export$757d561a932dc1cb = ({ finisher: e3 , descriptor: t3  })=>(o2, n)=>{
        var r;
        if (void 0 === n) {
            const n = null !== (r = o2.originalKey) && void 0 !== r ? r : o2.key, i = null != t3 ? {
                kind: "method",
                placement: "prototype",
                key: n,
                descriptor: t3(o2.key)
            } : {
                ...o2,
                key: n
            };
            return null != e3 && (i.finisher = function(t4) {
                e3(t4, n);
            }), i;
        }
        {
            const r = o2.constructor;
            void 0 !== t3 && Object.defineProperty(o2, n, t3(n)), null == e3 || e3(r, n);
        }
    };


/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $e82d765ec92ad8de$export$b2b799818fbabcf3(e1) {
    return (0, $cd105d2a147899a8$export$757d561a932dc1cb)({
        finisher: (r1, t)=>{
            Object.assign(r1.prototype[t], e1);
        }
    });
}



/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $ad8d92587e02b020$export$2fa187e846a241c4(i1, n1) {
    return (0, $cd105d2a147899a8$export$757d561a932dc1cb)({
        descriptor: (o1)=>{
            const t1 = {
                get () {
                    var o2, n;
                    return null !== (n = null === (o2 = this.renderRoot) || void 0 === o2 ? void 0 : o2.querySelector(i1)) && void 0 !== n ? n : null;
                },
                enumerable: !0,
                configurable: !0
            };
            if (n1) {
                const n = "symbol" == typeof o1 ? Symbol() : "__" + o1;
                t1.get = function() {
                    var o3, t;
                    return void 0 === this[n] && (this[n] = null !== (t = null === (o3 = this.renderRoot) || void 0 === o3 ? void 0 : o3.querySelector(i1)) && void 0 !== t ? t : null), this[n];
                };
            }
            return t1;
        }
    });
}



/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $bf6c55a2e0085b3b$export$dcd0d083aa86c355(e1) {
    return (0, $cd105d2a147899a8$export$757d561a932dc1cb)({
        descriptor: (r1)=>({
                get () {
                    var r2, o;
                    return null !== (o = null === (r2 = this.renderRoot) || void 0 === r2 ? void 0 : r2.querySelectorAll(e1)) && void 0 !== o ? o : [];
                },
                enumerable: !0,
                configurable: !0
            })
    });
}



/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $7ea8dd350329589f$export$163dfc35cc43f240(e1) {
    return (0, $cd105d2a147899a8$export$757d561a932dc1cb)({
        descriptor: (r1)=>({
                async get () {
                    var r2;
                    return await this.updateComplete, null === (r2 = this.renderRoot) || void 0 === r2 ? void 0 : r2.querySelector(e1);
                },
                enumerable: !0,
                configurable: !0
            })
    });
}



/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $9030ca0c7e8a59fc$var$n;
const $9030ca0c7e8a59fc$var$e = null != (null === ($9030ca0c7e8a59fc$var$n = window.HTMLSlotElement) || void 0 === $9030ca0c7e8a59fc$var$n ? void 0 : $9030ca0c7e8a59fc$var$n.prototype.assignedElements) ? (o1, n1)=>o1.assignedElements(n1) : (o2, n2)=>o2.assignedNodes(n2).filter((o3)=>o3.nodeType === Node.ELEMENT_NODE);
function $9030ca0c7e8a59fc$export$4682af2d9ee91415(n3) {
    const { slot: l1 , selector: t  } = null != n3 ? n3 : {};
    return (0, $cd105d2a147899a8$export$757d561a932dc1cb)({
        descriptor: (o4)=>({
                get () {
                    var o5;
                    const r = "slot" + (l1 ? `[name=${l1}]` : ":not([name])"), i = null === (o5 = this.renderRoot) || void 0 === o5 ? void 0 : o5.querySelector(r), s = null != i ? $9030ca0c7e8a59fc$var$e(i, n3) : [];
                    return t ? s.filter((o6)=>o6.matches(t)) : s;
                },
                enumerable: !0,
                configurable: !0
            })
    });
}




/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $b9d1a457b35f1e7b$export$1bdbe53f9df1b8(o1, n1, r) {
    let l, s = o1;
    return "object" == typeof o1 ? (s = o1.slot, l = o1) : l = {
        flatten: n1
    }, r ? (0, $9030ca0c7e8a59fc$export$4682af2d9ee91415)({
        slot: s,
        flatten: n1,
        selector: r
    }) : (0, $cd105d2a147899a8$export$757d561a932dc1cb)({
        descriptor: (e1)=>({
                get () {
                    var e2, t1;
                    const o2 = "slot" + (s ? `[name=${s}]` : ":not([name])"), n = null === (e2 = this.renderRoot) || void 0 === e2 ? void 0 : e2.querySelector(o2);
                    return null !== (t1 = null == n ? void 0 : n.assignedNodes(l)) && void 0 !== t1 ? t1 : [];
                },
                enumerable: !0,
                configurable: !0
            })
    });
}




var $d37c65794785f5bf$exports = {};
$d37c65794785f5bf$exports = ":host {\n  width: 100%;\n  display: block;\n}\n\n#container {\n  flex-direction: column;\n  display: flex;\n}\n\n#container .title {\n  width: 100%;\n  text-align: left;\n  overflow-anchor: none;\n  background-color: var(--light, #fff);\n  color: var(--dark-text, #212529);\n  cursor: pointer;\n  border: 0;\n  border-radius: 0;\n  align-items: center;\n  padding: 1rem 1.25rem;\n  font-size: 1rem;\n  transition: color .15s;\n  display: flex;\n  position: relative;\n}\n\n#container .title.active {\n  background-color: var(--active, #e7f1ff);\n  color: var(--active-text);\n  box-shadow: inset 0 -1px #00000020;\n}\n\n#container .title.active + .panel {\n  max-height: 200px;\n}\n\n#container .title:hover {\n  background-color: var(--active);\n  color: var(--active-text);\n}\n\n#container .panel {\n  max-height: 0;\n  background-color: --light;\n  border: 1px solid #00000020;\n  padding: 0 18px;\n  transition: max-height .2s ease-out, max-width .2s ease-out;\n  overflow: auto;\n}\n\n#container .panel:first-of-type {\n  border-top-left-radius: .25rem;\n  border-top-right-radius: .25rem;\n}\n\n#container.horizontal {\n  flex-direction: row;\n}\n\n#container.horizontal .title.active + .panel {\n  max-width: 200px;\n}\n\n#container.horizontal .panel {\n  max-width: 0;\n}\n\n";


class $a0686d78f030e4db$export$8f125625db3161c2 {
    constructor(element){
        this.element = element;
    }
    init() {
        let h = 0;
        let btns = $(this.element.shadowRoot).find(".title");
        btns.each((index, el)=>{
            $(el).off("click").on("click", function() {
                el.classList.toggle("active");
                if (el.classList.contains("active")) $(el).siblings(".title").removeClass("active");
            });
        });
    }
}


function $57c09562a6d0b30e$export$eec70cb3a42440b6(el1, map, ...exclude) {
    let children = Array.prototype.slice.call(el1.children);
    if (exclude && exclude.length > 0) return children.filter((el)=>exclude.some((str)=>!el.matches(str))).map(map);
    else return children.map(map);
}


var $5e0a45860ddebf78$exports = {};

$parcel$export($5e0a45860ddebf78$exports, "JuelComponent", () => $5e0a45860ddebf78$export$c6e5a5bea44a61ec, (v) => $5e0a45860ddebf78$export$c6e5a5bea44a61ec = v);


var $5e0a45860ddebf78$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class $5e0a45860ddebf78$export$c6e5a5bea44a61ec extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super(...arguments);
        this.loaded = false;
    }
    firstUpdated(_changedProperties) {
        setTimeout(()=>{
            this.requestUpdate();
            setTimeout(()=>{
                this.firstLoad();
            });
        });
        super.firstUpdated(_changedProperties);
    }
    firstLoad() {}
    updated(_changedProperties) {
        setTimeout(()=>{
            setTimeout(()=>{
                this.load(_changedProperties);
            });
        });
        this.loaded = true;
        super.updated(_changedProperties);
    }
    load(_changedProperties) {}
}
$5e0a45860ddebf78$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $5e0a45860ddebf78$export$c6e5a5bea44a61ec.prototype, "juelParent", void 0);


var $5c4d424c0d6a93d1$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9 = class JuelAccordion extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.size = "500px";
        this.horizontal = false;
        this.multiple = false;
        this.service = new (0, $a0686d78f030e4db$export$8f125625db3161c2)(this);
    }
    load() {
        this.service.init();
    }
    titleClick(e) {
        let el = e.target;
        el.classList.toggle("active");
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="container" class="${this.horizontal == true ? "horizontal" : ""}">
            ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, (ele, index)=>{
            let id = ele.id ? ele.id : `accordion-section-${index}`;
            ele.setAttribute("slot", id);
            let hasTitleEl = false;
            let titleElId = `${id}-title`;
            let titleEl = ele.previousElementSibling;
            if (titleEl && titleEl.matches('[slot*="title"')) {
                hasTitleEl = true;
                titleEl.setAttribute("slot", titleElId);
            }
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div class="title">
                        ${hasTitleEl ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<slot name="${titleElId}"></slot>` : (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<span>
                                ${ele.dataset.title ? ele.dataset.title : ""}
                            </span>`}
                        </div>
                        <div class="panel">
                        <slot name="${id}"></slot>
                        </div>`;
        }, '[slot*="title"]')}
        </div>`;
    }
};
$5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($d37c65794785f5bf$exports))));
$5c4d424c0d6a93d1$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9.prototype, "size", void 0);
$5c4d424c0d6a93d1$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9.prototype, "horizontal", void 0);
$5c4d424c0d6a93d1$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9.prototype, "multiple", void 0);
$5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9 = $5c4d424c0d6a93d1$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-accordion")
], $5c4d424c0d6a93d1$export$ab4cd39c32ba0bf9);


var $6f8ae91e0990ffcf$exports = {};


var $e3564661e74ddafb$exports = {};
$e3564661e74ddafb$exports = ".fixed {\n  position: fixed;\n  inset: 0;\n}\n\n.loading {\n  width: 100%;\n  height: 100%;\n  z-index: 100;\n  background-color: #f7f7f7;\n  justify-content: center;\n  align-items: center;\n  transition: all .6s;\n  display: flex;\n}\n\n.loading img {\n  height: 80px;\n  z-index: 101;\n  position: absolute;\n}\n\n.loading .circle {\n  width: 100px;\n  height: 100px;\n  background-color: #0061f2;\n  border: 4px solid #0000;\n  border-top-color: gold;\n  border-radius: 50%;\n  transition: all .6s;\n  animation: zoom 2s infinite;\n  position: relative;\n  box-shadow: 4px 1px 5px 2px #19c8ce26;\n}\n\n.hidden {\n  visibility: hidden;\n  opacity: 0;\n  transition: visibility 0s 2s, opacity 2s linear;\n}\n\n@keyframes zoom {\n  0% {\n    -o-transition: .6s;\n    transition: all .6s;\n    transform: rotate(0deg);\n  }\n\n  100% {\n    -o-transition: .6s;\n    transition: all .6s;\n    transform: rotate(360deg);\n  }\n}\n\n";


var $6f8ae91e0990ffcf$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $6f8ae91e0990ffcf$export$41eae17f34af2d67 = class JuelLoading extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    render() {
        let c = "loading";
        if (this.screen == true) c += " fixed";
        if (this.visible == false) c += " hidden";
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
        <div class="${c}">
            <div class="circle"></div>
            ${this.src ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<img src="${this.src}" alt="">` : ``}
        </div>`;
    }
};
$6f8ae91e0990ffcf$export$41eae17f34af2d67.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($e3564661e74ddafb$exports))));
$6f8ae91e0990ffcf$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $6f8ae91e0990ffcf$export$41eae17f34af2d67.prototype, "src", void 0);
$6f8ae91e0990ffcf$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $6f8ae91e0990ffcf$export$41eae17f34af2d67.prototype, "visible", void 0);
$6f8ae91e0990ffcf$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $6f8ae91e0990ffcf$export$41eae17f34af2d67.prototype, "screen", void 0);
$6f8ae91e0990ffcf$export$41eae17f34af2d67 = $6f8ae91e0990ffcf$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-loading")
], $6f8ae91e0990ffcf$export$41eae17f34af2d67);


var $93fa5e13b748ef2a$exports = {};


function $07b546ad6a3a68fc$export$2e2bcd8739ae039(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
}


function $b5560248333a05ae$export$2e2bcd8739ae039(node) {
    if (node == null) return window;
    if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}


function $13b7473a8bec108e$export$45a5e7f76e0caa8d(node) {
    var OwnElement = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function $13b7473a8bec108e$export$1b3bfaa9684536aa(node) {
    var OwnElement = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function $13b7473a8bec108e$export$af51f0f06c0f328a(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === "undefined") return false;
    var OwnElement = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}


// and applies them to the HTMLElements such as popper and arrow
function $53c5672b43233a80$var$applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name1) {
        var style = state.styles[name1] || {};
        var attributes = state.attributes[name1] || {};
        var element = state.elements[name1]; // arrow is optional + virtual elements
        if (!(0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(element) || !(0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? "" : value);
        });
    });
}
function $53c5672b43233a80$var$effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style1 = styleProperties.reduce(function(style, property) {
                style[property] = "";
                return style;
            }, {}); // arrow is optional + virtual elements
            if (!(0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(element) || !(0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(element)) return;
            Object.assign(element.style, style1);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
var $53c5672b43233a80$export$2e2bcd8739ae039 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: $53c5672b43233a80$var$applyStyles,
    effect: $53c5672b43233a80$var$effect,
    requires: [
        "computeStyles"
    ]
};



var $74e3996dc8f01827$export$8960430cfd85939f = Math.max;
var $74e3996dc8f01827$export$96ec731ed4dcb222 = Math.min;
var $74e3996dc8f01827$export$2077e0241d6afd3c = Math.round;


function $87da82eae93d9d84$export$2e2bcd8739ae039(element, includeScale) {
    if (includeScale === void 0) includeScale = false;
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if ((0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`
        if (offsetWidth > 0) scaleX = (0, $74e3996dc8f01827$export$2077e0241d6afd3c)(rect.width) / offsetWidth || 1;
        if (offsetHeight > 0) scaleY = (0, $74e3996dc8f01827$export$2077e0241d6afd3c)(rect.height) / offsetHeight || 1;
    }
    return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
    };
}



function $c2ee136844b33156$export$2e2bcd8739ae039(node) {
    var win = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}




function $eab75fa922b541af$export$2e2bcd8739ae039(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}


function $3e696837f12b77ec$export$2e2bcd8739ae039(node) {
    if (node === (0, $b5560248333a05ae$export$2e2bcd8739ae039)(node) || !(0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(node)) return (0, $c2ee136844b33156$export$2e2bcd8739ae039)(node);
    else return (0, $eab75fa922b541af$export$2e2bcd8739ae039)(node);
}






function $61925fc620e3f3d1$export$2e2bcd8739ae039(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return (((0, $13b7473a8bec108e$export$45a5e7f76e0caa8d)(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}



function $7970f3c84d84a6f1$export$2e2bcd8739ae039(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return (0, $87da82eae93d9d84$export$2e2bcd8739ae039)((0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(element)).left + (0, $c2ee136844b33156$export$2e2bcd8739ae039)(element).scrollLeft;
}




function $e6b6df168bfc238b$export$2e2bcd8739ae039(element) {
    return (0, $b5560248333a05ae$export$2e2bcd8739ae039)(element).getComputedStyle(element);
}


function $8b99bbfa18baee7f$export$2e2bcd8739ae039(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = (0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}



function $6b18c3c088e05995$var$isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = (0, $74e3996dc8f01827$export$2077e0241d6afd3c)(rect.width) / element.offsetWidth || 1;
    var scaleY = (0, $74e3996dc8f01827$export$2077e0241d6afd3c)(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
function $6b18c3c088e05995$export$2e2bcd8739ae039(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = (0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(offsetParent);
    var offsetParentIsScaled = (0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(offsetParent) && $6b18c3c088e05995$var$isElementScaled(offsetParent);
    var documentElement = (0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(offsetParent);
    var rect = (0, $87da82eae93d9d84$export$2e2bcd8739ae039)(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(offsetParent) !== "body" || (0, $8b99bbfa18baee7f$export$2e2bcd8739ae039)(documentElement)) scroll = (0, $3e696837f12b77ec$export$2e2bcd8739ae039)(offsetParent);
        if ((0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(offsetParent)) {
            offsets = (0, $87da82eae93d9d84$export$2e2bcd8739ae039)(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = (0, $7970f3c84d84a6f1$export$2e2bcd8739ae039)(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}



function $46c730d78b3059fd$export$2e2bcd8739ae039(element) {
    var clientRect = (0, $87da82eae93d9d84$export$2e2bcd8739ae039)(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}





function $04446f547a5beb16$export$2e2bcd8739ae039(element) {
    if ((0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(element) === "html") return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || element.parentNode || ((0, $13b7473a8bec108e$export$af51f0f06c0f328a)(element) ? element.host : null) || // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(element) // fallback
    );
}





function $c51e482916d55f34$export$2e2bcd8739ae039(node) {
    if ([
        "html",
        "body",
        "#document"
    ].indexOf((0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if ((0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(node) && (0, $8b99bbfa18baee7f$export$2e2bcd8739ae039)(node)) return node;
    return $c51e482916d55f34$export$2e2bcd8739ae039((0, $04446f547a5beb16$export$2e2bcd8739ae039)(node));
}





function $d3d1ce4a2cde1f33$export$2e2bcd8739ae039(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = (0, $c51e482916d55f34$export$2e2bcd8739ae039)(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], (0, $8b99bbfa18baee7f$export$2e2bcd8739ae039)(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat($d3d1ce4a2cde1f33$export$2e2bcd8739ae039((0, $04446f547a5beb16$export$2e2bcd8739ae039)(target)));
}







function $76d1234d1c913697$export$2e2bcd8739ae039(element) {
    return [
        "table",
        "td",
        "th"
    ].indexOf((0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(element)) >= 0;
}



function $4845c55e2b16c249$var$getTrueOffsetParent(element) {
    if (!(0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(element) || (0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(element).position === "fixed") return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function $4845c55e2b16c249$var$getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && (0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = (0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(element);
        if (elementCss.position === "fixed") return null;
    }
    var currentNode = (0, $04446f547a5beb16$export$2e2bcd8739ae039)(element);
    if ((0, $13b7473a8bec108e$export$af51f0f06c0f328a)(currentNode)) currentNode = currentNode.host;
    while((0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(currentNode) && [
        "html",
        "body"
    ].indexOf((0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(currentNode)) < 0){
        var css = (0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [
            "transform",
            "perspective"
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
function $4845c55e2b16c249$export$2e2bcd8739ae039(element) {
    var window = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(element);
    var offsetParent = $4845c55e2b16c249$var$getTrueOffsetParent(element);
    while(offsetParent && (0, $76d1234d1c913697$export$2e2bcd8739ae039)(offsetParent) && (0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(offsetParent).position === "static")offsetParent = $4845c55e2b16c249$var$getTrueOffsetParent(offsetParent);
    if (offsetParent && ((0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(offsetParent) === "html" || (0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(offsetParent) === "body" && (0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(offsetParent).position === "static")) return window;
    return offsetParent || $4845c55e2b16c249$var$getContainingBlock(element) || window;
}



var $a875f6da2c78516a$export$1e95b668f3b82d = "top";
var $a875f6da2c78516a$export$40e543e69a8b3fbb = "bottom";
var $a875f6da2c78516a$export$79ffe56a765070d2 = "right";
var $a875f6da2c78516a$export$eabcd2c8791e7bf4 = "left";
var $a875f6da2c78516a$export$dfb5619354ba860 = "auto";
var $a875f6da2c78516a$export$aec2ce47c367b8c3 = [
    $a875f6da2c78516a$export$1e95b668f3b82d,
    $a875f6da2c78516a$export$40e543e69a8b3fbb,
    $a875f6da2c78516a$export$79ffe56a765070d2,
    $a875f6da2c78516a$export$eabcd2c8791e7bf4
];
var $a875f6da2c78516a$export$b3571188c770cc5a = "start";
var $a875f6da2c78516a$export$bd5df0f255a350f8 = "end";
var $a875f6da2c78516a$export$390fd549c5303b4d = "clippingParents";
var $a875f6da2c78516a$export$d7b7311ec04a3e8f = "viewport";
var $a875f6da2c78516a$export$ae5ab1c730825774 = "popper";
var $a875f6da2c78516a$export$ca50aac9f3ba507f = "reference";
var $a875f6da2c78516a$export$368f9a87e87fa4e1 = /*#__PURE__*/ $a875f6da2c78516a$export$aec2ce47c367b8c3.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + $a875f6da2c78516a$export$b3571188c770cc5a,
        placement + "-" + $a875f6da2c78516a$export$bd5df0f255a350f8
    ]);
}, []);
var $a875f6da2c78516a$export$803cd8101b6c182b = /*#__PURE__*/ [].concat($a875f6da2c78516a$export$aec2ce47c367b8c3, [
    $a875f6da2c78516a$export$dfb5619354ba860
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + $a875f6da2c78516a$export$b3571188c770cc5a,
        placement + "-" + $a875f6da2c78516a$export$bd5df0f255a350f8
    ]);
}, []); // modifiers that need to read the DOM
var $a875f6da2c78516a$export$421679a7c3d56e = "beforeRead";
var $a875f6da2c78516a$export$aafa59e2e03f2942 = "read";
var $a875f6da2c78516a$export$6964f6c886723980 = "afterRead"; // pure-logic modifiers
var $a875f6da2c78516a$export$c65e99957a05207c = "beforeMain";
var $a875f6da2c78516a$export$f22da7240b7add18 = "main";
var $a875f6da2c78516a$export$bab79516f2d662fe = "afterMain"; // modifier with the purpose to write to the DOM (or write into a framework state)
var $a875f6da2c78516a$export$8d4d2d70e7d46032 = "beforeWrite";
var $a875f6da2c78516a$export$68d8715fc104d294 = "write";
var $a875f6da2c78516a$export$70a6e5159acce2e6 = "afterWrite";
var $a875f6da2c78516a$export$d087d3878fdf71d5 = [
    $a875f6da2c78516a$export$421679a7c3d56e,
    $a875f6da2c78516a$export$aafa59e2e03f2942,
    $a875f6da2c78516a$export$6964f6c886723980,
    $a875f6da2c78516a$export$c65e99957a05207c,
    $a875f6da2c78516a$export$f22da7240b7add18,
    $a875f6da2c78516a$export$bab79516f2d662fe,
    $a875f6da2c78516a$export$8d4d2d70e7d46032,
    $a875f6da2c78516a$export$68d8715fc104d294,
    $a875f6da2c78516a$export$70a6e5159acce2e6
];


function $b7374a25fe4d9035$var$order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function $b7374a25fe4d9035$export$2e2bcd8739ae039(modifiers) {
    // order based on dependencies
    var orderedModifiers = $b7374a25fe4d9035$var$order(modifiers); // order based on phase
    return (0, $a875f6da2c78516a$export$d087d3878fdf71d5).reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}


function $ce6730929c21fa79$export$2e2bcd8739ae039(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}





function $667dcf1b9bfbca03$export$2e2bcd8739ae039(modifiers) {
    var merged1 = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
    }, {}); // IE11 does not support Object.values
    return Object.keys(merged1).map(function(key) {
        return merged1[key];
    });
}





var $b3a49267c939e7b8$var$INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var $b3a49267c939e7b8$var$INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var $b3a49267c939e7b8$var$DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function $b3a49267c939e7b8$var$areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
    });
}
function $b3a49267c939e7b8$export$ed5e13716264f202(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {};
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? $b3a49267c939e7b8$var$DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference1, popper1, options1) {
        if (options1 === void 0) options1 = defaultOptions;
        var state1 = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, $b3a49267c939e7b8$var$DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference1,
                popper: popper1
            },
            attributes: {},
            styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state1,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === "function" ? setOptionsAction(state1.options) : setOptionsAction;
                cleanupModifierEffects();
                state1.options = Object.assign({}, defaultOptions, state1.options, options);
                state1.scrollParents = {
                    reference: (0, $13b7473a8bec108e$export$45a5e7f76e0caa8d)(reference1) ? (0, $d3d1ce4a2cde1f33$export$2e2bcd8739ae039)(reference1) : reference1.contextElement ? (0, $d3d1ce4a2cde1f33$export$2e2bcd8739ae039)(reference1.contextElement) : [],
                    popper: (0, $d3d1ce4a2cde1f33$export$2e2bcd8739ae039)(popper1)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = (0, $b7374a25fe4d9035$export$2e2bcd8739ae039)((0, $667dcf1b9bfbca03$export$2e2bcd8739ae039)([].concat(defaultModifiers, state1.options.modifiers))); // Strip out disabled modifiers
                state1.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                }); // Validate the provided modifiers so that the consumer will get warned
                var modifiers, _ref, name, flipModifier, _ref2, name1, _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, margin;
                runModifierEffects();
                return instance.update();
            },
            // Sync update  it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state1.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!$b3a49267c939e7b8$var$areValidElements(reference, popper)) return;
                 // Store the reference and popper rects to be read by modifiers
                state1.rects = {
                    reference: (0, $6b18c3c088e05995$export$2e2bcd8739ae039)(reference, (0, $4845c55e2b16c249$export$2e2bcd8739ae039)(popper), state1.options.strategy === "fixed"),
                    popper: (0, $46c730d78b3059fd$export$2e2bcd8739ae039)(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state1.reset = false;
                state1.placement = state1.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state1.orderedModifiers.forEach(function(modifier) {
                    return state1.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                var __debug_loops__ = 0;
                for(var index = 0; index < state1.orderedModifiers.length; index++){
                    if (state1.reset === true) {
                        state1.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state1.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === "function") state1 = fn({
                        state: state1,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state1;
                }
            },
            // Async and optimistically optimized update  it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: (0, $ce6730929c21fa79$export$2e2bcd8739ae039)(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state1);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!$b3a49267c939e7b8$var$areValidElements(reference1, popper1)) return instance;
        instance.setOptions(options1).then(function(state) {
            if (!isDestroyed && options1.onFirstUpdate) options1.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state1.orderedModifiers.forEach(function(_ref3) {
                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;
                if (typeof effect === "function") {
                    var cleanupFn = effect({
                        state: state1,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var $b3a49267c939e7b8$export$8f7491d57c8f97a9 = /*#__PURE__*/ $b3a49267c939e7b8$export$ed5e13716264f202(); // eslint-disable-next-line import/no-unused-modules



var $7a4ebf53324a0b52$var$passive = {
    passive: true
};
function $7a4ebf53324a0b52$var$effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, $7a4ebf53324a0b52$var$passive);
    });
    if (resize) window.addEventListener("resize", instance.update, $7a4ebf53324a0b52$var$passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, $7a4ebf53324a0b52$var$passive);
        });
        if (resize) window.removeEventListener("resize", instance.update, $7a4ebf53324a0b52$var$passive);
    };
} // eslint-disable-next-line import/no-unused-modules
var $7a4ebf53324a0b52$export$2e2bcd8739ae039 = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {},
    effect: $7a4ebf53324a0b52$var$effect,
    data: {}
};



function $9d5aac344e8a729c$export$2e2bcd8739ae039(placement) {
    return placement.split("-")[0];
}


function $c4c0901fd5b5b62e$export$2e2bcd8739ae039(placement) {
    return placement.split("-")[1];
}


function $3691d9d9251cf126$export$2e2bcd8739ae039(placement) {
    return [
        "top",
        "bottom"
    ].indexOf(placement) >= 0 ? "x" : "y";
}



function $5f2157994d2d2e98$export$2e2bcd8739ae039(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(placement) : null;
    var variation = placement ? (0, $c4c0901fd5b5b62e$export$2e2bcd8739ae039)(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case 0, $a875f6da2c78516a$export$1e95b668f3b82d:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case 0, $a875f6da2c78516a$export$40e543e69a8b3fbb:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 0, $a875f6da2c78516a$export$79ffe56a765070d2:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 0, $a875f6da2c78516a$export$eabcd2c8791e7bf4:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? (0, $3691d9d9251cf126$export$2e2bcd8739ae039)(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch(variation){
            case 0, $a875f6da2c78516a$export$b3571188c770cc5a:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case 0, $a875f6da2c78516a$export$bd5df0f255a350f8:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}


function $17ffbaa636474331$var$popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = (0, $5f2157994d2d2e98$export$2e2bcd8739ae039)({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
var $17ffbaa636474331$export$2e2bcd8739ae039 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: $17ffbaa636474331$var$popperOffsets,
    data: {}
};










var $22fc2758765f92ef$var$unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function $22fc2758765f92ef$var$roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: (0, $74e3996dc8f01827$export$2077e0241d6afd3c)(x * dpr) / dpr || 0,
        y: (0, $74e3996dc8f01827$export$2077e0241d6afd3c)(y * dpr) / dpr || 0
    };
}
function $22fc2758765f92ef$export$378fa78a8fea596f(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4);
    var sideY = (0, $a875f6da2c78516a$export$1e95b668f3b82d);
    var win = window;
    if (adaptive) {
        var offsetParent = (0, $4845c55e2b16c249$export$2e2bcd8739ae039)(popper);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === (0, $b5560248333a05ae$export$2e2bcd8739ae039)(popper)) {
            offsetParent = (0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(popper);
            if ((0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(offsetParent).position !== "static" && position === "absolute") {
                heightProp = "scrollHeight";
                widthProp = "scrollWidth";
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        offsetParent;
        if (placement === (0, $a875f6da2c78516a$export$1e95b668f3b82d) || (placement === (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4) || placement === (0, $a875f6da2c78516a$export$79ffe56a765070d2)) && variation === (0, $a875f6da2c78516a$export$bd5df0f255a350f8)) {
            sideY = (0, $a875f6da2c78516a$export$40e543e69a8b3fbb);
            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4) || (placement === (0, $a875f6da2c78516a$export$1e95b668f3b82d) || placement === (0, $a875f6da2c78516a$export$40e543e69a8b3fbb)) && variation === (0, $a875f6da2c78516a$export$bd5df0f255a350f8)) {
            sideX = (0, $a875f6da2c78516a$export$79ffe56a765070d2);
            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && $22fc2758765f92ef$var$unsetSides);
    var _ref4 = roundOffsets === true ? $22fc2758765f92ef$var$roundOffsetsByDPR({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function $22fc2758765f92ef$var$computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var transitionProperty, property;
    var commonStyles = {
        placement: (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(state.placement),
        variation: (0, $c4c0901fd5b5b62e$export$2e2bcd8739ae039)(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, $22fc2758765f92ef$export$378fa78a8fea596f(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, $22fc2758765f92ef$export$378fa78a8fea596f(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
var $22fc2758765f92ef$export$2e2bcd8739ae039 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: $22fc2758765f92ef$var$computeStyles,
    data: {}
};





function $1c5b40da31cd0eb4$export$7fa02d8595b015ed(placement, rects, offset1) {
    var basePlacement = (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(placement);
    var invertDistance = [
        (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4),
        (0, $a875f6da2c78516a$export$1e95b668f3b82d)
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset1 === "function" ? offset1(Object.assign({}, rects, {
        placement: placement
    })) : offset1, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4),
        (0, $a875f6da2c78516a$export$79ffe56a765070d2)
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function $1c5b40da31cd0eb4$var$offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = (0, $a875f6da2c78516a$export$803cd8101b6c182b).reduce(function(acc, placement) {
        acc[placement] = $1c5b40da31cd0eb4$export$7fa02d8595b015ed(placement, state.rects, offset2);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var $1c5b40da31cd0eb4$export$2e2bcd8739ae039 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: [
        "popperOffsets"
    ],
    fn: $1c5b40da31cd0eb4$var$offset
};


var $74a74e5a8e2b9a09$var$hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function $74a74e5a8e2b9a09$export$2e2bcd8739ae039(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return $74a74e5a8e2b9a09$var$hash[matched];
    });
}



var $a9276ee7746897bb$var$hash = {
    start: "end",
    end: "start"
};
function $a9276ee7746897bb$export$2e2bcd8739ae039(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return $a9276ee7746897bb$var$hash[matched];
    });
}






function $33a98788df2a4a4d$export$2e2bcd8739ae039(element) {
    var win = (0, $b5560248333a05ae$export$2e2bcd8739ae039)(element);
    var html = (0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent
        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + (0, $7970f3c84d84a6f1$export$2e2bcd8739ae039)(element),
        y: y
    };
}







function $574867d38a2fb378$export$2e2bcd8739ae039(element) {
    var _element$ownerDocumen;
    var html = (0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(element);
    var winScroll = (0, $c2ee136844b33156$export$2e2bcd8739ae039)(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = (0, $74e3996dc8f01827$export$8960430cfd85939f)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = (0, $74e3996dc8f01827$export$8960430cfd85939f)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + (0, $7970f3c84d84a6f1$export$2e2bcd8739ae039)(element);
    var y = -winScroll.scrollTop;
    if ((0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(body || html).direction === "rtl") x += (0, $74e3996dc8f01827$export$8960430cfd85939f)(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}










function $f08b4b36590626d4$export$2e2bcd8739ae039(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && (0, $13b7473a8bec108e$export$af51f0f06c0f328a)(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next);
    } // Give up, the result is false
    return false;
}



function $794e45aa10983017$export$2e2bcd8739ae039(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}



function $96cb1ad0a7feedc0$var$getInnerBoundingClientRect(element) {
    var rect = (0, $87da82eae93d9d84$export$2e2bcd8739ae039)(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function $96cb1ad0a7feedc0$var$getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === (0, $a875f6da2c78516a$export$d7b7311ec04a3e8f) ? (0, $794e45aa10983017$export$2e2bcd8739ae039)((0, $33a98788df2a4a4d$export$2e2bcd8739ae039)(element)) : (0, $13b7473a8bec108e$export$45a5e7f76e0caa8d)(clippingParent) ? $96cb1ad0a7feedc0$var$getInnerBoundingClientRect(clippingParent) : (0, $794e45aa10983017$export$2e2bcd8739ae039)((0, $574867d38a2fb378$export$2e2bcd8739ae039)((0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function $96cb1ad0a7feedc0$var$getClippingParents(element) {
    var clippingParents = (0, $d3d1ce4a2cde1f33$export$2e2bcd8739ae039)((0, $04446f547a5beb16$export$2e2bcd8739ae039)(element));
    var canEscapeClipping = [
        "absolute",
        "fixed"
    ].indexOf((0, $e6b6df168bfc238b$export$2e2bcd8739ae039)(element).position) >= 0;
    var clipperElement = canEscapeClipping && (0, $13b7473a8bec108e$export$1b3bfaa9684536aa)(element) ? (0, $4845c55e2b16c249$export$2e2bcd8739ae039)(element) : element;
    if (!(0, $13b7473a8bec108e$export$45a5e7f76e0caa8d)(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return (0, $13b7473a8bec108e$export$45a5e7f76e0caa8d)(clippingParent) && (0, $f08b4b36590626d4$export$2e2bcd8739ae039)(clippingParent, clipperElement) && (0, $07b546ad6a3a68fc$export$2e2bcd8739ae039)(clippingParent) !== "body";
    });
} // Gets the maximum area that the element is visible in due to any number of
function $96cb1ad0a7feedc0$export$2e2bcd8739ae039(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? $96cb1ad0a7feedc0$var$getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = $96cb1ad0a7feedc0$var$getClientRectFromMixedType(element, clippingParent);
        accRect.top = (0, $74e3996dc8f01827$export$8960430cfd85939f)(rect.top, accRect.top);
        accRect.right = (0, $74e3996dc8f01827$export$96ec731ed4dcb222)(rect.right, accRect.right);
        accRect.bottom = (0, $74e3996dc8f01827$export$96ec731ed4dcb222)(rect.bottom, accRect.bottom);
        accRect.left = (0, $74e3996dc8f01827$export$8960430cfd85939f)(rect.left, accRect.left);
        return accRect;
    }, $96cb1ad0a7feedc0$var$getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}








function $4e185d662319c7bf$export$2e2bcd8739ae039() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}


function $3c88fbd93d8f46df$export$2e2bcd8739ae039(paddingObject) {
    return Object.assign({}, (0, $4e185d662319c7bf$export$2e2bcd8739ae039)(), paddingObject);
}


function $23139824a037ed55$export$2e2bcd8739ae039(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}


function $9c600470f86d88a2$export$2e2bcd8739ae039(state, options) {
    if (options === void 0) options = {};
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? (0, $a875f6da2c78516a$export$390fd549c5303b4d) : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? (0, $a875f6da2c78516a$export$d7b7311ec04a3e8f) : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? (0, $a875f6da2c78516a$export$ae5ab1c730825774) : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = (0, $3c88fbd93d8f46df$export$2e2bcd8739ae039)(typeof padding !== "number" ? padding : (0, $23139824a037ed55$export$2e2bcd8739ae039)(padding, (0, $a875f6da2c78516a$export$aec2ce47c367b8c3)));
    var altContext = elementContext === (0, $a875f6da2c78516a$export$ae5ab1c730825774) ? (0, $a875f6da2c78516a$export$ca50aac9f3ba507f) : (0, $a875f6da2c78516a$export$ae5ab1c730825774);
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = (0, $96cb1ad0a7feedc0$export$2e2bcd8739ae039)((0, $13b7473a8bec108e$export$45a5e7f76e0caa8d)(element) ? element : element.contextElement || (0, $61925fc620e3f3d1$export$2e2bcd8739ae039)(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = (0, $87da82eae93d9d84$export$2e2bcd8739ae039)(state.elements.reference);
    var popperOffsets = (0, $5f2157994d2d2e98$export$2e2bcd8739ae039)({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement: placement
    });
    var popperClientRect = (0, $794e45aa10983017$export$2e2bcd8739ae039)(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === (0, $a875f6da2c78516a$export$ae5ab1c730825774) ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === (0, $a875f6da2c78516a$export$ae5ab1c730825774) && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                (0, $a875f6da2c78516a$export$79ffe56a765070d2),
                (0, $a875f6da2c78516a$export$40e543e69a8b3fbb)
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                (0, $a875f6da2c78516a$export$1e95b668f3b82d),
                (0, $a875f6da2c78516a$export$40e543e69a8b3fbb)
            ].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}






function $3c2d5ee8537b5888$export$2e2bcd8739ae039(state, options) {
    if (options === void 0) options = {};
    var _options = options, placement1 = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? (0, $a875f6da2c78516a$export$803cd8101b6c182b) : _options$allowedAutoP;
    var variation = (0, $c4c0901fd5b5b62e$export$2e2bcd8739ae039)(placement1);
    var placements = variation ? flipVariations ? (0, $a875f6da2c78516a$export$368f9a87e87fa4e1) : (0, $a875f6da2c78516a$export$368f9a87e87fa4e1).filter(function(placement) {
        return (0, $c4c0901fd5b5b62e$export$2e2bcd8739ae039)(placement) === variation;
    }) : (0, $a875f6da2c78516a$export$aec2ce47c367b8c3);
    var allowedPlacements = placements.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) allowedPlacements = placements;
     // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = (0, $9c600470f86d88a2$export$2e2bcd8739ae039)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[(0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(placement)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}




function $4d29f5f08732b0f6$var$getExpandedFallbackPlacements(placement) {
    if ((0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(placement) === (0, $a875f6da2c78516a$export$dfb5619354ba860)) return [];
    var oppositePlacement = (0, $74a74e5a8e2b9a09$export$2e2bcd8739ae039)(placement);
    return [
        (0, $a9276ee7746897bb$export$2e2bcd8739ae039)(placement),
        oppositePlacement,
        (0, $a9276ee7746897bb$export$2e2bcd8739ae039)(oppositePlacement)
    ];
}
function $4d29f5f08732b0f6$var$flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        (0, $74a74e5a8e2b9a09$export$2e2bcd8739ae039)(preferredPlacement)
    ] : $4d29f5f08732b0f6$var$getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat((0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(placement) === (0, $a875f6da2c78516a$export$dfb5619354ba860) ? (0, $3c2d5ee8537b5888$export$2e2bcd8739ae039)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement1 = placements[i];
        var _basePlacement = (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(placement1);
        var isStartVariation = (0, $c4c0901fd5b5b62e$export$2e2bcd8739ae039)(placement1) === (0, $a875f6da2c78516a$export$b3571188c770cc5a);
        var isVertical = [
            (0, $a875f6da2c78516a$export$1e95b668f3b82d),
            (0, $a875f6da2c78516a$export$40e543e69a8b3fbb)
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = (0, $9c600470f86d88a2$export$2e2bcd8739ae039)(state, {
            placement: placement1,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? (0, $a875f6da2c78516a$export$79ffe56a765070d2) : (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4) : isStartVariation ? (0, $a875f6da2c78516a$export$40e543e69a8b3fbb) : (0, $a875f6da2c78516a$export$1e95b668f3b82d);
        if (referenceRect[len] > popperRect[len]) mainVariationSide = (0, $74a74e5a8e2b9a09$export$2e2bcd8739ae039)(mainVariationSide);
        var altVariationSide = (0, $74a74e5a8e2b9a09$export$2e2bcd8739ae039)(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement1;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement1, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i1 = numberOfChecks; _i1 > 0; _i1--){
            var _ret = _loop(_i1);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
var $4d29f5f08732b0f6$export$2e2bcd8739ae039 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: $4d29f5f08732b0f6$var$flip,
    requiresIfExists: [
        "offset"
    ],
    data: {
        _skip: false
    }
};





function $641d750846b3a821$export$2e2bcd8739ae039(axis) {
    return axis === "x" ? "y" : "x";
}



function $cc4b4d40f6312465$export$f28d906d67a997f3(min, value, max) {
    return (0, $74e3996dc8f01827$export$8960430cfd85939f)(min, (0, $74e3996dc8f01827$export$96ec731ed4dcb222)(value, max));
}
function $cc4b4d40f6312465$export$86c8af6d3ef0b4a(min, value, max) {
    var v = $cc4b4d40f6312465$export$f28d906d67a997f3(min, value, max);
    return v > max ? max : v;
}








function $4e2d11a752700922$var$preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = (0, $9c600470f86d88a2$export$2e2bcd8739ae039)(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(state.placement);
    var variation = (0, $c4c0901fd5b5b62e$export$2e2bcd8739ae039)(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = (0, $3691d9d9251cf126$export$2e2bcd8739ae039)(basePlacement);
    var altAxis = (0, $641d750846b3a821$export$2e2bcd8739ae039)(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? (0, $a875f6da2c78516a$export$1e95b668f3b82d) : (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4);
        var altSide = mainAxis === "y" ? (0, $a875f6da2c78516a$export$40e543e69a8b3fbb) : (0, $a875f6da2c78516a$export$79ffe56a765070d2);
        var len = mainAxis === "y" ? "height" : "width";
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === (0, $a875f6da2c78516a$export$b3571188c770cc5a) ? referenceRect[len] : popperRect[len];
        var maxLen = variation === (0, $a875f6da2c78516a$export$b3571188c770cc5a) ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? (0, $46c730d78b3059fd$export$2e2bcd8739ae039)(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : (0, $4e185d662319c7bf$export$2e2bcd8739ae039)();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = (0, $cc4b4d40f6312465$export$f28d906d67a997f3)(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && (0, $4845c55e2b16c249$export$2e2bcd8739ae039)(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = (0, $cc4b4d40f6312465$export$f28d906d67a997f3)(tether ? (0, $74e3996dc8f01827$export$96ec731ed4dcb222)(min, tetherMin) : min, offset, tether ? (0, $74e3996dc8f01827$export$8960430cfd85939f)(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? (0, $a875f6da2c78516a$export$1e95b668f3b82d) : (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4);
        var _altSide = mainAxis === "x" ? (0, $a875f6da2c78516a$export$40e543e69a8b3fbb) : (0, $a875f6da2c78516a$export$79ffe56a765070d2);
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            (0, $a875f6da2c78516a$export$1e95b668f3b82d),
            (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4)
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? (0, $cc4b4d40f6312465$export$86c8af6d3ef0b4a)(_tetherMin, _offset, _tetherMax) : (0, $cc4b4d40f6312465$export$f28d906d67a997f3)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var $4e2d11a752700922$export$2e2bcd8739ae039 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: $4e2d11a752700922$var$preventOverflow,
    requiresIfExists: [
        "offset"
    ]
};












var $4f87851f3ed637f7$var$toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
    })) : padding;
    return (0, $3c88fbd93d8f46df$export$2e2bcd8739ae039)(typeof padding !== "number" ? padding : (0, $23139824a037ed55$export$2e2bcd8739ae039)(padding, (0, $a875f6da2c78516a$export$aec2ce47c367b8c3)));
};
function $4f87851f3ed637f7$var$arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = (0, $9d5aac344e8a729c$export$2e2bcd8739ae039)(state.placement);
    var axis = (0, $3691d9d9251cf126$export$2e2bcd8739ae039)(basePlacement);
    var isVertical = [
        (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4),
        (0, $a875f6da2c78516a$export$79ffe56a765070d2)
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = $4f87851f3ed637f7$var$toPaddingObject(options.padding, state);
    var arrowRect = (0, $46c730d78b3059fd$export$2e2bcd8739ae039)(arrowElement);
    var minProp = axis === "y" ? (0, $a875f6da2c78516a$export$1e95b668f3b82d) : (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4);
    var maxProp = axis === "y" ? (0, $a875f6da2c78516a$export$40e543e69a8b3fbb) : (0, $a875f6da2c78516a$export$79ffe56a765070d2);
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = (0, $4845c55e2b16c249$export$2e2bcd8739ae039)(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = (0, $cc4b4d40f6312465$export$f28d906d67a997f3)(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function $4f87851f3ed637f7$var$effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!(0, $f08b4b36590626d4$export$2e2bcd8739ae039)(state.elements.popper, arrowElement)) return;
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
var $4f87851f3ed637f7$export$2e2bcd8739ae039 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: $4f87851f3ed637f7$var$arrow,
    effect: $4f87851f3ed637f7$var$effect,
    requires: [
        "popperOffsets"
    ],
    requiresIfExists: [
        "preventOverflow"
    ]
};




function $8fdfbe0c927828e5$var$getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function $8fdfbe0c927828e5$var$isAnySideFullyClipped(overflow) {
    return [
        (0, $a875f6da2c78516a$export$1e95b668f3b82d),
        (0, $a875f6da2c78516a$export$79ffe56a765070d2),
        (0, $a875f6da2c78516a$export$40e543e69a8b3fbb),
        (0, $a875f6da2c78516a$export$eabcd2c8791e7bf4)
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function $8fdfbe0c927828e5$var$hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = (0, $9c600470f86d88a2$export$2e2bcd8739ae039)(state, {
        elementContext: "reference"
    });
    var popperAltOverflow = (0, $9c600470f86d88a2$export$2e2bcd8739ae039)(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = $8fdfbe0c927828e5$var$getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = $8fdfbe0c927828e5$var$getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = $8fdfbe0c927828e5$var$isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = $8fdfbe0c927828e5$var$isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
    });
} // eslint-disable-next-line import/no-unused-modules
var $8fdfbe0c927828e5$export$2e2bcd8739ae039 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: [
        "preventOverflow"
    ],
    fn: $8fdfbe0c927828e5$var$hide
};




var $ff295692f8fc945a$export$d34966752335dd47 = [
    (0, $7a4ebf53324a0b52$export$2e2bcd8739ae039),
    (0, $17ffbaa636474331$export$2e2bcd8739ae039),
    (0, $22fc2758765f92ef$export$2e2bcd8739ae039),
    (0, $53c5672b43233a80$export$2e2bcd8739ae039),
    (0, $1c5b40da31cd0eb4$export$2e2bcd8739ae039),
    (0, $4d29f5f08732b0f6$export$2e2bcd8739ae039),
    (0, $4e2d11a752700922$export$2e2bcd8739ae039),
    (0, $4f87851f3ed637f7$export$2e2bcd8739ae039),
    (0, $8fdfbe0c927828e5$export$2e2bcd8739ae039)
];
var $ff295692f8fc945a$export$8f7491d57c8f97a9 = /*#__PURE__*/ (0, $b3a49267c939e7b8$export$ed5e13716264f202)({
    defaultModifiers: $ff295692f8fc945a$export$d34966752335dd47
}); // eslint-disable-next-line import/no-unused-modules



var $8c77471a259a642c$export$c96c811c44a42da5 = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var $8c77471a259a642c$var$BOX_CLASS = "tippy-box";
var $8c77471a259a642c$var$CONTENT_CLASS = "tippy-content";
var $8c77471a259a642c$var$BACKDROP_CLASS = "tippy-backdrop";
var $8c77471a259a642c$var$ARROW_CLASS = "tippy-arrow";
var $8c77471a259a642c$var$SVG_ARROW_CLASS = "tippy-svg-arrow";
var $8c77471a259a642c$var$TOUCH_OPTIONS = {
    passive: true,
    capture: true
};
var $8c77471a259a642c$var$TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
    return document.body;
};
function $8c77471a259a642c$var$hasOwnProperty(obj, key) {
    return ({}).hasOwnProperty.call(obj, key);
}
function $8c77471a259a642c$var$getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }
    return value;
}
function $8c77471a259a642c$var$isType(value, type) {
    var str = ({}).toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function $8c77471a259a642c$var$invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
}
function $8c77471a259a642c$var$debounce(fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) return fn;
    var timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            fn(arg);
        }, ms);
    };
}
function $8c77471a259a642c$var$removeProperties(obj, keys) {
    var clone = Object.assign({}, obj);
    keys.forEach(function(key) {
        delete clone[key];
    });
    return clone;
}
function $8c77471a259a642c$var$splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
}
function $8c77471a259a642c$var$normalizeToArray(value) {
    return [].concat(value);
}
function $8c77471a259a642c$var$pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) arr.push(value);
}
function $8c77471a259a642c$var$unique(arr) {
    return arr.filter(function(item, index) {
        return arr.indexOf(item) === index;
    });
}
function $8c77471a259a642c$var$getBasePlacement(placement) {
    return placement.split("-")[0];
}
function $8c77471a259a642c$var$arrayFrom(value) {
    return [].slice.call(value);
}
function $8c77471a259a642c$var$removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
        if (obj[key] !== undefined) acc[key] = obj[key];
        return acc;
    }, {});
}
function $8c77471a259a642c$var$div() {
    return document.createElement("div");
}
function $8c77471a259a642c$var$isElement(value) {
    return [
        "Element",
        "Fragment"
    ].some(function(type) {
        return $8c77471a259a642c$var$isType(value, type);
    });
}
function $8c77471a259a642c$var$isNodeList(value) {
    return $8c77471a259a642c$var$isType(value, "NodeList");
}
function $8c77471a259a642c$var$isMouseEvent(value) {
    return $8c77471a259a642c$var$isType(value, "MouseEvent");
}
function $8c77471a259a642c$var$isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
}
function $8c77471a259a642c$var$getArrayOfElements(value) {
    if ($8c77471a259a642c$var$isElement(value)) return [
        value
    ];
    if ($8c77471a259a642c$var$isNodeList(value)) return $8c77471a259a642c$var$arrayFrom(value);
    if (Array.isArray(value)) return value;
    return $8c77471a259a642c$var$arrayFrom(document.querySelectorAll(value));
}
function $8c77471a259a642c$var$setTransitionDuration(els, value) {
    els.forEach(function(el) {
        if (el) el.style.transitionDuration = value + "ms";
    });
}
function $8c77471a259a642c$var$setVisibilityState(els, state) {
    els.forEach(function(el) {
        if (el) el.setAttribute("data-state", state);
    });
}
function $8c77471a259a642c$var$getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = $8c77471a259a642c$var$normalizeToArray(elementOrElements), element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function $8c77471a259a642c$var$isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
        var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = $8c77471a259a642c$var$getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;
        if (!offsetData) return true;
        var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
        var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
}
function $8c77471a259a642c$var$updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
    // `webkitTransitionEnd`...
    [
        "transitionend",
        "webkitTransitionEnd"
    ].forEach(function(event) {
        box[method](event, listener);
    });
}
/**
 * Compared to xxx.contains, this function works for dom structures with shadow
 * dom
 */ function $8c77471a259a642c$var$actualContains(parent, child) {
    var target = child;
    while(target){
        var _target$getRootNode;
        if (parent.contains(target)) return true;
        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
}
var $8c77471a259a642c$var$currentInput = {
    isTouch: false
};
var $8c77471a259a642c$var$lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */ function $8c77471a259a642c$var$onDocumentTouchStart() {
    if ($8c77471a259a642c$var$currentInput.isTouch) return;
    $8c77471a259a642c$var$currentInput.isTouch = true;
    if (window.performance) document.addEventListener("mousemove", $8c77471a259a642c$var$onDocumentMouseMove);
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */ function $8c77471a259a642c$var$onDocumentMouseMove() {
    var now = performance.now();
    if (now - $8c77471a259a642c$var$lastMouseMoveTime < 20) {
        $8c77471a259a642c$var$currentInput.isTouch = false;
        document.removeEventListener("mousemove", $8c77471a259a642c$var$onDocumentMouseMove);
    }
    $8c77471a259a642c$var$lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */ function $8c77471a259a642c$var$onWindowBlur() {
    var activeElement = document.activeElement;
    if ($8c77471a259a642c$var$isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;
        if (activeElement.blur && !instance.state.isVisible) activeElement.blur();
    }
}
function $8c77471a259a642c$var$bindGlobalEventListeners() {
    document.addEventListener("touchstart", $8c77471a259a642c$var$onDocumentTouchStart, $8c77471a259a642c$var$TOUCH_OPTIONS);
    window.addEventListener("blur", $8c77471a259a642c$var$onWindowBlur);
}
var $8c77471a259a642c$var$isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var $8c77471a259a642c$var$isIE11 = $8c77471a259a642c$var$isBrowser ? !!window.msCrypto : false;
function $8c77471a259a642c$var$createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [
        method + "() was called on a" + txt + "destroyed instance. This is a no-op but",
        "indicates a potential memory leak."
    ].join(" ");
}
function $8c77471a259a642c$var$clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function $8c77471a259a642c$var$getDevMessage(message) {
    return $8c77471a259a642c$var$clean("\n  %ctippy.js\n\n  %c" + $8c77471a259a642c$var$clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}
function $8c77471a259a642c$var$getFormattedMessage(message) {
    return [
        $8c77471a259a642c$var$getDevMessage(message),
        "color: #00C584; font-size: 1.3em; font-weight: bold;",
        "line-height: 1.5",
        "color: #a6a095;"
    ];
} // Assume warnings and errors never have the same message
var $8c77471a259a642c$var$visitedMessages;
function $8c77471a259a642c$var$resetVisitedMessages() {
    $8c77471a259a642c$var$visitedMessages = new Set();
}
function $8c77471a259a642c$var$warnWhen(condition, message) {
    if (condition && !$8c77471a259a642c$var$visitedMessages.has(message)) {
        var _console;
        $8c77471a259a642c$var$visitedMessages.add(message);
        (_console = console).warn.apply(_console, $8c77471a259a642c$var$getFormattedMessage(message));
    }
}
function $8c77471a259a642c$var$errorWhen(condition, message) {
    if (condition && !$8c77471a259a642c$var$visitedMessages.has(message)) {
        var _console2;
        $8c77471a259a642c$var$visitedMessages.add(message);
        (_console2 = console).error.apply(_console2, $8c77471a259a642c$var$getFormattedMessage(message));
    }
}
function $8c77471a259a642c$var$validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    $8c77471a259a642c$var$errorWhen(didPassFalsyValue, [
        "tippy() was passed",
        "`" + String(targets) + "`",
        "as its targets (first) argument. Valid types are: String, Element,",
        "Element[], or NodeList."
    ].join(" "));
    $8c77471a259a642c$var$errorWhen(didPassPlainObject, [
        "tippy() was passed a plain object which is not supported as an argument",
        "for virtual positioning. Use props.getReferenceClientRect instead."
    ].join(" "));
}
var $8c77471a259a642c$var$pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
};
var $8c77471a259a642c$var$renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
};
var $8c77471a259a642c$var$defaultProps = Object.assign({
    appendTo: $8c77471a259a642c$var$TIPPY_DEFAULT_APPEND_TO,
    aria: {
        content: "auto",
        expanded: "auto"
    },
    delay: 0,
    duration: [
        300,
        250
    ],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [
        0,
        10
    ],
    onAfterUpdate: function onAfterUpdate() {},
    onBeforeUpdate: function onBeforeUpdate() {},
    onCreate: function onCreate() {},
    onDestroy: function onDestroy() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    onClickOutside: function onClickOutside() {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
}, $8c77471a259a642c$var$pluginProps, $8c77471a259a642c$var$renderProps);
var $8c77471a259a642c$var$defaultKeys = Object.keys($8c77471a259a642c$var$defaultProps);
var $8c77471a259a642c$var$setDefaultProps = function setDefaultProps(partialProps) {
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
        $8c77471a259a642c$var$defaultProps[key] = partialProps[key];
    });
};
function $8c77471a259a642c$var$getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps1 = plugins.reduce(function(acc, plugin) {
        var name = plugin.name, defaultValue = plugin.defaultValue;
        if (name) {
            var _name;
            acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = $8c77471a259a642c$var$defaultProps[name]) != null ? _name : defaultValue;
        }
        return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps1);
}
function $8c77471a259a642c$var$getDataAttributeProps(reference, plugins) {
    var propKeys = plugins ? Object.keys($8c77471a259a642c$var$getExtendedPassedProps(Object.assign({}, $8c77471a259a642c$var$defaultProps, {
        plugins: plugins
    }))) : $8c77471a259a642c$var$defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
        if (!valueAsString) return acc;
        if (key === "content") acc[key] = valueAsString;
        else try {
            acc[key] = JSON.parse(valueAsString);
        } catch (e) {
            acc[key] = valueAsString;
        }
        return acc;
    }, {});
    return props;
}
function $8c77471a259a642c$var$evaluateProps(reference, props) {
    var out = Object.assign({}, props, {
        content: $8c77471a259a642c$var$invokeWithArgsOrReturn(props.content, [
            reference
        ])
    }, props.ignoreAttributes ? {} : $8c77471a259a642c$var$getDataAttributeProps(reference, props.plugins));
    out.aria = Object.assign({}, $8c77471a259a642c$var$defaultProps.aria, out.aria);
    out.aria = {
        expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
        content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
}
function $8c77471a259a642c$var$validateProps(partialProps, plugins) {
    if (partialProps === void 0) partialProps = {};
    if (plugins === void 0) plugins = [];
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
        var nonPluginProps = $8c77471a259a642c$var$removeProperties($8c77471a259a642c$var$defaultProps, Object.keys($8c77471a259a642c$var$pluginProps));
        var didPassUnknownProp = !$8c77471a259a642c$var$hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`
        if (didPassUnknownProp) didPassUnknownProp = plugins.filter(function(plugin) {
            return plugin.name === prop;
        }).length === 0;
        $8c77471a259a642c$var$warnWhen(didPassUnknownProp, [
            "`" + prop + "`",
            "is not a valid prop. You may have spelled it incorrectly, or if it's",
            "a plugin, forgot to pass it in an array as props.plugins.",
            "\n\n",
            "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n",
            "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"
        ].join(" "));
    });
}
var $8c77471a259a642c$var$innerHTML = function innerHTML() {
    return "innerHTML";
};
function $8c77471a259a642c$var$dangerouslySetInnerHTML(element, html) {
    element[$8c77471a259a642c$var$innerHTML()] = html;
}
function $8c77471a259a642c$var$createArrowElement(value) {
    var arrow = $8c77471a259a642c$var$div();
    if (value === true) arrow.className = $8c77471a259a642c$var$ARROW_CLASS;
    else {
        arrow.className = $8c77471a259a642c$var$SVG_ARROW_CLASS;
        if ($8c77471a259a642c$var$isElement(value)) arrow.appendChild(value);
        else $8c77471a259a642c$var$dangerouslySetInnerHTML(arrow, value);
    }
    return arrow;
}
function $8c77471a259a642c$var$setContent(content, props) {
    if ($8c77471a259a642c$var$isElement(props.content)) {
        $8c77471a259a642c$var$dangerouslySetInnerHTML(content, "");
        content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
        if (props.allowHTML) $8c77471a259a642c$var$dangerouslySetInnerHTML(content, props.content);
        else content.textContent = props.content;
    }
}
function $8c77471a259a642c$var$getChildren(popper) {
    var box = popper.firstElementChild;
    var boxChildren = $8c77471a259a642c$var$arrayFrom(box.children);
    return {
        box: box,
        content: boxChildren.find(function(node) {
            return node.classList.contains($8c77471a259a642c$var$CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function(node) {
            return node.classList.contains($8c77471a259a642c$var$ARROW_CLASS) || node.classList.contains($8c77471a259a642c$var$SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function(node) {
            return node.classList.contains($8c77471a259a642c$var$BACKDROP_CLASS);
        })
    };
}
function $8c77471a259a642c$var$render(instance) {
    var popper = $8c77471a259a642c$var$div();
    var box1 = $8c77471a259a642c$var$div();
    box1.className = $8c77471a259a642c$var$BOX_CLASS;
    box1.setAttribute("data-state", "hidden");
    box1.setAttribute("tabindex", "-1");
    var content1 = $8c77471a259a642c$var$div();
    content1.className = $8c77471a259a642c$var$CONTENT_CLASS;
    content1.setAttribute("data-state", "hidden");
    $8c77471a259a642c$var$setContent(content1, instance.props);
    popper.appendChild(box1);
    box1.appendChild(content1);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
        var _getChildren = $8c77471a259a642c$var$getChildren(popper), box = _getChildren.box, content = _getChildren.content, arrow = _getChildren.arrow;
        if (nextProps.theme) box.setAttribute("data-theme", nextProps.theme);
        else box.removeAttribute("data-theme");
        if (typeof nextProps.animation === "string") box.setAttribute("data-animation", nextProps.animation);
        else box.removeAttribute("data-animation");
        if (nextProps.inertia) box.setAttribute("data-inertia", "");
        else box.removeAttribute("data-inertia");
        box.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
        if (nextProps.role) box.setAttribute("role", nextProps.role);
        else box.removeAttribute("role");
        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) $8c77471a259a642c$var$setContent(content, instance.props);
        if (nextProps.arrow) {
            if (!arrow) box.appendChild($8c77471a259a642c$var$createArrowElement(nextProps.arrow));
            else if (prevProps.arrow !== nextProps.arrow) {
                box.removeChild(arrow);
                box.appendChild($8c77471a259a642c$var$createArrowElement(nextProps.arrow));
            }
        } else if (arrow) box.removeChild(arrow);
    }
    return {
        popper: popper,
        onUpdate: onUpdate
    };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away
$8c77471a259a642c$var$render.$$tippy = true;
var $8c77471a259a642c$var$idCounter = 1;
var $8c77471a259a642c$var$mouseMoveListeners = []; // Used by `hideAll()`
var $8c77471a259a642c$var$mountedInstances = [];
function $8c77471a259a642c$var$createTippy(reference, passedProps) {
    var props = $8c77471a259a642c$var$evaluateProps(reference, Object.assign({}, $8c77471a259a642c$var$defaultProps, $8c77471a259a642c$var$getExtendedPassedProps($8c77471a259a642c$var$removeUndefinedProps(passedProps)))); // ===========================================================================
    //  Private members
    // ===========================================================================
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = $8c77471a259a642c$var$debounce(onMouseMove, props.interactiveDebounce);
    var currentTarget; // ===========================================================================
    //  Public members
    // ===========================================================================
    var id1 = $8c77471a259a642c$var$idCounter++;
    var popperInstance = null;
    var plugins = $8c77471a259a642c$var$unique(props.plugins);
    var state1 = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
    };
    var instance1 = {
        // properties
        id: id1,
        reference: reference,
        popper: $8c77471a259a642c$var$div(),
        popperInstance: popperInstance,
        props: props,
        state: state1,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent1,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
    }; // TODO: Investigate why this early return causes a TDZ error in the tests 
    // it doesn't seem to happen in the browser
    /* istanbul ignore if */ if (!props.render) return instance1;
     // ===========================================================================
    // Initial mutations
    // ===========================================================================
    var _props$render = props.render(instance1), popper1 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper1.setAttribute("data-tippy-root", "");
    popper1.id = "tippy-" + instance1.id;
    instance1.popper = popper1;
    reference._tippy = instance1;
    popper1._tippy = instance1;
    var pluginsHooks = plugins.map(function(plugin) {
        return plugin.fn(instance1);
    });
    var hasAriaExpanded = reference.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [
        instance1
    ]);
    if (props.showOnCreate) scheduleShow();
     // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding
    popper1.addEventListener("mouseenter", function() {
        if (instance1.props.interactive && instance1.state.isVisible) instance1.clearDelayTimeouts();
    });
    popper1.addEventListener("mouseleave", function() {
        if (instance1.props.interactive && instance1.props.trigger.indexOf("mouseenter") >= 0) getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    });
    return instance1; // ===========================================================================
    //  Private methods
    // ===========================================================================
    function getNormalizedTouchSettings() {
        var touch = instance1.props.touch;
        return Array.isArray(touch) ? touch : [
            touch,
            0
        ];
    }
    function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
        var _instance$props$rende;
        // @ts-ignore
        return !!((_instance$props$rende = instance1.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
        return currentTarget || reference;
    }
    function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? $8c77471a259a642c$var$getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
        return $8c77471a259a642c$var$getChildren(popper1);
    }
    function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance1.state.isMounted && !instance1.state.isVisible || $8c77471a259a642c$var$currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
            return 0;
        }
        return $8c77471a259a642c$var$getValueAtIndexOrReturn(instance1.props.delay, isShow ? 0 : 1, $8c77471a259a642c$var$defaultProps.delay);
    }
    function handleStyles(fromHide) {
        if (fromHide === void 0) {
            fromHide = false;
        }
        popper1.style.pointerEvents = instance1.props.interactive && !fromHide ? "" : "none";
        popper1.style.zIndex = "" + instance1.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
            shouldInvokePropsHook = true;
        }
        pluginsHooks.forEach(function(pluginHooks) {
            if (pluginHooks[hook]) {
                pluginHooks[hook].apply(pluginHooks, args);
            }
        });
        if (shouldInvokePropsHook) {
            var _instance$props;
            (_instance$props = instance1.props)[hook].apply(_instance$props, args);
        }
    }
    function handleAriaContentAttribute() {
        var aria = instance1.props.aria;
        if (!aria.content) {
            return;
        }
        var attr = "aria-" + aria.content;
        var id = popper1.id;
        var nodes = $8c77471a259a642c$var$normalizeToArray(instance1.props.triggerTarget || reference);
        nodes.forEach(function(node) {
            var currentValue = node.getAttribute(attr);
            if (instance1.state.isVisible) {
                node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
            } else {
                var nextValue = currentValue && currentValue.replace(id, "").trim();
                if (nextValue) {
                    node.setAttribute(attr, nextValue);
                } else {
                    node.removeAttribute(attr);
                }
            }
        });
    }
    function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance1.props.aria.expanded) {
            return;
        }
        var nodes = $8c77471a259a642c$var$normalizeToArray(instance1.props.triggerTarget || reference);
        nodes.forEach(function(node) {
            if (instance1.props.interactive) {
                node.setAttribute("aria-expanded", instance1.state.isVisible && node === getCurrentTarget() ? "true" : "false");
            } else {
                node.removeAttribute("aria-expanded");
            }
        });
    }
    function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
        $8c77471a259a642c$var$mouseMoveListeners = $8c77471a259a642c$var$mouseMoveListeners.filter(function(listener) {
            return listener !== debouncedOnMouseMove;
        });
    }
    function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if ($8c77471a259a642c$var$currentInput.isTouch) {
            if (didTouchMove || event.type === "mousedown") {
                return;
            }
        }
        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper
        if (instance1.props.interactive && $8c77471a259a642c$var$actualContains(popper1, actualTarget)) {
            return;
        } // Clicked on the event listeners target
        if ($8c77471a259a642c$var$normalizeToArray(instance1.props.triggerTarget || reference).some(function(el) {
            return $8c77471a259a642c$var$actualContains(el, actualTarget);
        })) {
            if ($8c77471a259a642c$var$currentInput.isTouch) {
                return;
            }
            if (instance1.state.isVisible && instance1.props.trigger.indexOf("click") >= 0) {
                return;
            }
        } else {
            invokeHook("onClickOutside", [
                instance1,
                event
            ]);
        }
        if (instance1.props.hideOnClick === true) {
            instance1.clearDelayTimeouts();
            instance1.hide(); // `mousedown` event is fired right before `focus` if pressing the
            // currentTarget. This lets a tippy with `focus` trigger know that it
            // should not show
            didHideDueToDocumentMouseDown = true;
            setTimeout(function() {
                didHideDueToDocumentMouseDown = false;
            }); // The listener gets added in `scheduleShow()`, but this may be hiding it
            // before it shows, and hide()'s early bail-out behavior can prevent it
            // from being cleaned up
            if (!instance1.state.isMounted) {
                removeDocumentPress();
            }
        }
    }
    function onTouchMove() {
        didTouchMove = true;
    }
    function onTouchStart() {
        didTouchMove = false;
    }
    function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener("mousedown", onDocumentPress, true);
        doc.addEventListener("touchend", onDocumentPress, $8c77471a259a642c$var$TOUCH_OPTIONS);
        doc.addEventListener("touchstart", onTouchStart, $8c77471a259a642c$var$TOUCH_OPTIONS);
        doc.addEventListener("touchmove", onTouchMove, $8c77471a259a642c$var$TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener("mousedown", onDocumentPress, true);
        doc.removeEventListener("touchend", onDocumentPress, $8c77471a259a642c$var$TOUCH_OPTIONS);
        doc.removeEventListener("touchstart", onTouchStart, $8c77471a259a642c$var$TOUCH_OPTIONS);
        doc.removeEventListener("touchmove", onTouchMove, $8c77471a259a642c$var$TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function() {
            if (!instance1.state.isVisible && popper1.parentNode && popper1.parentNode.contains(popper1)) {
                callback();
            }
        });
    }
    function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;
        function listener(event) {
            if (event.target === box) {
                $8c77471a259a642c$var$updateTransitionEndListener(box, "remove", listener);
                callback();
            }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise
        if (duration === 0) {
            return callback();
        }
        $8c77471a259a642c$var$updateTransitionEndListener(box, "remove", currentTransitionEndListener);
        $8c77471a259a642c$var$updateTransitionEndListener(box, "add", listener);
        currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
        if (options === void 0) {
            options = false;
        }
        var nodes = $8c77471a259a642c$var$normalizeToArray(instance1.props.triggerTarget || reference);
        nodes.forEach(function(node) {
            node.addEventListener(eventType, handler, options);
            listeners.push({
                node: node,
                eventType: eventType,
                handler: handler,
                options: options
            });
        });
    }
    function addListeners() {
        if (getIsCustomTouchBehavior()) {
            on("touchstart", onTrigger, {
                passive: true
            });
            on("touchend", onMouseLeave, {
                passive: true
            });
        }
        $8c77471a259a642c$var$splitBySpaces(instance1.props.trigger).forEach(function(eventType) {
            if (eventType === "manual") {
                return;
            }
            on(eventType, onTrigger);
            switch(eventType){
                case "mouseenter":
                    on("mouseleave", onMouseLeave);
                    break;
                case "focus":
                    on($8c77471a259a642c$var$isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
                    break;
                case "focusin":
                    on("focusout", onBlurOrFocusOut);
                    break;
            }
        });
    }
    function removeListeners() {
        listeners.forEach(function(_ref) {
            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
            node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
    }
    function onTrigger(event) {
        var _lastTriggerEvent;
        var shouldScheduleClickHide = false;
        if (!instance1.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
            return;
        }
        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();
        if (!instance1.state.isVisible && $8c77471a259a642c$var$isMouseEvent(event)) {
            // If scrolling, `mouseenter` events can be fired if the cursor lands
            // over a new target, but `mousemove` events don't get fired. This
            // causes interactive tooltips to get stuck open until the cursor is
            // moved
            $8c77471a259a642c$var$mouseMoveListeners.forEach(function(listener) {
                return listener(event);
            });
        } // Toggle show/hide when clicking click-triggered tooltips
        if (event.type === "click" && (instance1.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance1.props.hideOnClick !== false && instance1.state.isVisible) {
            shouldScheduleClickHide = true;
        } else {
            scheduleShow(event);
        }
        if (event.type === "click") {
            isVisibleFromClick = !shouldScheduleClickHide;
        }
        if (shouldScheduleClickHide && !wasFocused) {
            scheduleHide(event);
        }
    }
    function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper1.contains(target);
        if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
            return;
        }
        var popperTreeData = getNestedPopperTree().concat(popper1).map(function(popper) {
            var _instance$popperInsta;
            var instance = popper._tippy;
            var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
            if (state) {
                return {
                    popperRect: popper.getBoundingClientRect(),
                    popperState: state,
                    props: props
                };
            }
            return null;
        }).filter(Boolean);
        if ($8c77471a259a642c$var$isCursorOutsideInteractiveBorder(popperTreeData, event)) {
            cleanupInteractiveMouseListeners();
            scheduleHide(event);
        }
    }
    function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance1.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
        if (shouldBail) {
            return;
        }
        if (instance1.props.interactive) {
            instance1.hideWithInteractivity(event);
            return;
        }
        scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
        if (instance1.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
            return;
        } // If focus was moved to within the popper
        if (instance1.props.interactive && event.relatedTarget && popper1.contains(event.relatedTarget)) {
            return;
        }
        scheduleHide(event);
    }
    function isEventListenerStopped(event) {
        return $8c77471a259a642c$var$currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance1.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? $8c77471a259a642c$var$getChildren(popper1).arrow : null;
        var computedReference = getReferenceClientRect ? {
            getBoundingClientRect: getReferenceClientRect,
            contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
            name: "$$tippy",
            enabled: true,
            phase: "beforeWrite",
            requires: [
                "computeStyles"
            ],
            fn: function fn(_ref2) {
                var state = _ref2.state;
                if (getIsDefaultRenderFn()) {
                    var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
                    [
                        "placement",
                        "reference-hidden",
                        "escaped"
                    ].forEach(function(attr) {
                        if (attr === "placement") {
                            box.setAttribute("data-placement", state.placement);
                        } else {
                            if (state.attributes.popper["data-popper-" + attr]) {
                                box.setAttribute("data-" + attr, "");
                            } else {
                                box.removeAttribute("data-" + attr);
                            }
                        }
                    });
                    state.attributes.popper = {};
                }
            }
        };
        var modifiers = [
            {
                name: "offset",
                options: {
                    offset: offset
                }
            },
            {
                name: "preventOverflow",
                options: {
                    padding: {
                        top: 2,
                        bottom: 2,
                        left: 5,
                        right: 5
                    }
                }
            },
            {
                name: "flip",
                options: {
                    padding: 5
                }
            },
            {
                name: "computeStyles",
                options: {
                    adaptive: !moveTransition
                }
            },
            tippyModifier
        ];
        if (getIsDefaultRenderFn() && arrow) {
            modifiers.push({
                name: "arrow",
                options: {
                    element: arrow,
                    padding: 3
                }
            });
        }
        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance1.popperInstance = (0, $ff295692f8fc945a$export$8f7491d57c8f97a9)(computedReference, popper1, Object.assign({}, popperOptions, {
            placement: placement,
            onFirstUpdate: onFirstUpdate,
            modifiers: modifiers
        }));
    }
    function destroyPopperInstance() {
        if (instance1.popperInstance) {
            instance1.popperInstance.destroy();
            instance1.popperInstance = null;
        }
    }
    function mount() {
        var appendTo = instance1.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually
        var node = getCurrentTarget();
        if (instance1.props.interactive && appendTo === $8c77471a259a642c$var$TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
            parentNode = node.parentNode;
        } else {
            parentNode = $8c77471a259a642c$var$invokeWithArgsOrReturn(appendTo, [
                node
            ]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions
        if (!parentNode.contains(popper1)) {
            parentNode.appendChild(popper1);
        }
        instance1.state.isMounted = true;
        createPopperInstance();
        /* istanbul ignore else */ if (false) {
            // Accessibility check
            $8c77471a259a642c$var$warnWhen(instance1.props.interactive && appendTo === $8c77471a259a642c$var$defaultProps.appendTo && node.nextElementSibling !== popper1, [
                "Interactive tippy element may not be accessible via keyboard",
                "navigation because it is not directly after the reference element",
                "in the DOM source order.",
                "\n\n",
                "Using a wrapper <div> or <span> tag around the reference element",
                "solves this by creating a new parentNode context.",
                "\n\n",
                "Specifying `appendTo: document.body` silences this warning, but it",
                "assumes you are using a focus management solution to handle",
                "keyboard navigation.",
                "\n\n",
                "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"
            ].join(" "));
        }
    }
    function getNestedPopperTree() {
        return $8c77471a259a642c$var$arrayFrom(popper1.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
        instance1.clearDelayTimeouts();
        if (event) {
            invokeHook("onTrigger", [
                instance1,
                event
            ]);
        }
        addDocumentPress();
        var delay = getDelay(true);
        var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
        if ($8c77471a259a642c$var$currentInput.isTouch && touchValue === "hold" && touchDelay) {
            delay = touchDelay;
        }
        if (delay) {
            showTimeout = setTimeout(function() {
                instance1.show();
            }, delay);
        } else {
            instance1.show();
        }
    }
    function scheduleHide(event) {
        instance1.clearDelayTimeouts();
        invokeHook("onUntrigger", [
            instance1,
            event
        ]);
        if (!instance1.state.isVisible) {
            removeDocumentPress();
            return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.
        if (instance1.props.trigger.indexOf("mouseenter") >= 0 && instance1.props.trigger.indexOf("click") >= 0 && [
            "mouseleave",
            "mousemove"
        ].indexOf(event.type) >= 0 && isVisibleFromClick) {
            return;
        }
        var delay = getDelay(false);
        if (delay) {
            hideTimeout = setTimeout(function() {
                if (instance1.state.isVisible) {
                    instance1.hide();
                }
            }, delay);
        } else {
            // Fixes a `transitionend` problem when it fires 1 frame too
            // late sometimes, we don't want hide() to be called.
            scheduleHideAnimationFrame = requestAnimationFrame(function() {
                instance1.hide();
            });
        }
    } // ===========================================================================
    //  Public methods
    // ===========================================================================
    function enable() {
        instance1.state.isEnabled = true;
    }
    function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance1.hide();
        instance1.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
        /* istanbul ignore else */ if (false) {
            $8c77471a259a642c$var$warnWhen(instance1.state.isDestroyed, $8c77471a259a642c$var$createMemoryLeakWarning("setProps"));
        }
        if (instance1.state.isDestroyed) {
            return;
        }
        invokeHook("onBeforeUpdate", [
            instance1,
            partialProps
        ]);
        removeListeners();
        var prevProps = instance1.props;
        var nextProps = $8c77471a259a642c$var$evaluateProps(reference, Object.assign({}, prevProps, $8c77471a259a642c$var$removeUndefinedProps(partialProps), {
            ignoreAttributes: true
        }));
        instance1.props = nextProps;
        addListeners();
        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
            cleanupInteractiveMouseListeners();
            debouncedOnMouseMove = $8c77471a259a642c$var$debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed
        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
            $8c77471a259a642c$var$normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
                node.removeAttribute("aria-expanded");
            });
        } else if (nextProps.triggerTarget) {
            reference.removeAttribute("aria-expanded");
        }
        handleAriaExpandedAttribute();
        handleStyles();
        if (onUpdate) {
            onUpdate(prevProps, nextProps);
        }
        if (instance1.popperInstance) {
            createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
            // and the nested ones get re-rendered first.
            // https://github.com/atomiks/tippyjs-react/issues/177
            // TODO: find a cleaner / more efficient solution(!)
            getNestedPopperTree().forEach(function(nestedPopper) {
                // React (and other UI libs likely) requires a rAF wrapper as it flushes
                // its work in one
                requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
            });
        }
        invokeHook("onAfterUpdate", [
            instance1,
            partialProps
        ]);
    }
    function setContent1(content) {
        instance1.setProps({
            content: content
        });
    }
    function show() {
        /* istanbul ignore else */ if (false) {
            $8c77471a259a642c$var$warnWhen(instance1.state.isDestroyed, $8c77471a259a642c$var$createMemoryLeakWarning("show"));
        } // Early bail-out
        var isAlreadyVisible = instance1.state.isVisible;
        var isDestroyed = instance1.state.isDestroyed;
        var isDisabled = !instance1.state.isEnabled;
        var isTouchAndTouchDisabled = $8c77471a259a642c$var$currentInput.isTouch && !instance1.props.touch;
        var duration = $8c77471a259a642c$var$getValueAtIndexOrReturn(instance1.props.duration, 0, $8c77471a259a642c$var$defaultProps.duration);
        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
            return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.
        if (getCurrentTarget().hasAttribute("disabled")) {
            return;
        }
        invokeHook("onShow", [
            instance1
        ], false);
        if (instance1.props.onShow(instance1) === false) {
            return;
        }
        instance1.state.isVisible = true;
        if (getIsDefaultRenderFn()) {
            popper1.style.visibility = "visible";
        }
        handleStyles();
        addDocumentPress();
        if (!instance1.state.isMounted) {
            popper1.style.transition = "none";
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration
        if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
            $8c77471a259a642c$var$setTransitionDuration([
                box,
                content
            ], 0);
        }
        onFirstUpdate = function onFirstUpdate() {
            var _instance$popperInsta2;
            if (!instance1.state.isVisible || ignoreOnFirstUpdate) {
                return;
            }
            ignoreOnFirstUpdate = true; // reflow
            void popper1.offsetHeight;
            popper1.style.transition = instance1.props.moveTransition;
            if (getIsDefaultRenderFn() && instance1.props.animation) {
                var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
                $8c77471a259a642c$var$setTransitionDuration([
                    _box,
                    _content
                ], duration);
                $8c77471a259a642c$var$setVisibilityState([
                    _box,
                    _content
                ], "visible");
            }
            handleAriaContentAttribute();
            handleAriaExpandedAttribute();
            $8c77471a259a642c$var$pushIfUnique($8c77471a259a642c$var$mountedInstances, instance1); // certain modifiers (e.g. `maxSize`) require a second update after the
            // popper has been positioned for the first time
            (_instance$popperInsta2 = instance1.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
            invokeHook("onMount", [
                instance1
            ]);
            if (instance1.props.animation && getIsDefaultRenderFn()) {
                onTransitionedIn(duration, function() {
                    instance1.state.isShown = true;
                    invokeHook("onShown", [
                        instance1
                    ]);
                });
            }
        };
        mount();
    }
    function hide() {
        /* istanbul ignore else */ if (false) {
            $8c77471a259a642c$var$warnWhen(instance1.state.isDestroyed, $8c77471a259a642c$var$createMemoryLeakWarning("hide"));
        } // Early bail-out
        var isAlreadyHidden = !instance1.state.isVisible;
        var isDestroyed = instance1.state.isDestroyed;
        var isDisabled = !instance1.state.isEnabled;
        var duration = $8c77471a259a642c$var$getValueAtIndexOrReturn(instance1.props.duration, 1, $8c77471a259a642c$var$defaultProps.duration);
        if (isAlreadyHidden || isDestroyed || isDisabled) {
            return;
        }
        invokeHook("onHide", [
            instance1
        ], false);
        if (instance1.props.onHide(instance1) === false) {
            return;
        }
        instance1.state.isVisible = false;
        instance1.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;
        if (getIsDefaultRenderFn()) {
            popper1.style.visibility = "hidden";
        }
        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles(true);
        if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
            if (instance1.props.animation) {
                $8c77471a259a642c$var$setTransitionDuration([
                    box,
                    content
                ], duration);
                $8c77471a259a642c$var$setVisibilityState([
                    box,
                    content
                ], "hidden");
            }
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        if (instance1.props.animation) {
            if (getIsDefaultRenderFn()) {
                onTransitionedOut(duration, instance1.unmount);
            }
        } else {
            instance1.unmount();
        }
    }
    function hideWithInteractivity(event) {
        /* istanbul ignore else */ if (false) {
            $8c77471a259a642c$var$warnWhen(instance1.state.isDestroyed, $8c77471a259a642c$var$createMemoryLeakWarning("hideWithInteractivity"));
        }
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
        $8c77471a259a642c$var$pushIfUnique($8c77471a259a642c$var$mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
    }
    function unmount() {
        /* istanbul ignore else */ if (false) {
            $8c77471a259a642c$var$warnWhen(instance1.state.isDestroyed, $8c77471a259a642c$var$createMemoryLeakWarning("unmount"));
        }
        if (instance1.state.isVisible) {
            instance1.hide();
        }
        if (!instance1.state.isMounted) {
            return;
        }
        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible
        getNestedPopperTree().forEach(function(nestedPopper) {
            nestedPopper._tippy.unmount();
        });
        if (popper1.parentNode) {
            popper1.parentNode.removeChild(popper1);
        }
        $8c77471a259a642c$var$mountedInstances = $8c77471a259a642c$var$mountedInstances.filter(function(i) {
            return i !== instance1;
        });
        instance1.state.isMounted = false;
        invokeHook("onHidden", [
            instance1
        ]);
    }
    function destroy() {
        /* istanbul ignore else */ if (false) {
            $8c77471a259a642c$var$warnWhen(instance1.state.isDestroyed, $8c77471a259a642c$var$createMemoryLeakWarning("destroy"));
        }
        if (instance1.state.isDestroyed) {
            return;
        }
        instance1.clearDelayTimeouts();
        instance1.unmount();
        removeListeners();
        delete reference._tippy;
        instance1.state.isDestroyed = true;
        invokeHook("onDestroy", [
            instance1
        ]);
    }
}
function $8c77471a259a642c$var$tippy(targets, optionalProps) {
    if (optionalProps === void 0) optionalProps = {};
    var plugins = $8c77471a259a642c$var$defaultProps.plugins.concat(optionalProps.plugins || []);
    $8c77471a259a642c$var$bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
    });
    var elements = $8c77471a259a642c$var$getArrayOfElements(targets);
    var isSingleContentElement, isMoreThanOneReferenceElement;
    var instances = elements.reduce(function(acc, reference) {
        var instance = reference && $8c77471a259a642c$var$createTippy(reference, passedProps);
        if (instance) acc.push(instance);
        return acc;
    }, []);
    return $8c77471a259a642c$var$isElement(targets) ? instances[0] : instances;
}
$8c77471a259a642c$var$tippy.defaultProps = $8c77471a259a642c$var$defaultProps;
$8c77471a259a642c$var$tippy.setDefaultProps = $8c77471a259a642c$var$setDefaultProps;
$8c77471a259a642c$var$tippy.currentInput = $8c77471a259a642c$var$currentInput;
var $8c77471a259a642c$export$a9608aab345f7e75 = function hideAll(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, excludedReferenceOrInstance = _ref.exclude, duration = _ref.duration;
    $8c77471a259a642c$var$mountedInstances.forEach(function(instance) {
        var isExcluded = false;
        if (excludedReferenceOrInstance) isExcluded = $8c77471a259a642c$var$isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
        if (!isExcluded) {
            var originalDuration = instance.props.duration;
            instance.setProps({
                duration: duration
            });
            instance.hide();
            if (!instance.state.isDestroyed) instance.setProps({
                duration: originalDuration
            });
        }
    });
};
// every time the popper is destroyed (i.e. a new target), removing the styles
// and causing transitions to break for singletons when the console is open, but
// most notably for non-transform styles being used, `gpuAcceleration: false`.
var $8c77471a259a642c$var$applyStylesModifier = Object.assign({}, (0, $53c5672b43233a80$export$2e2bcd8739ae039), {
    effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
            popper: {
                position: state.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;
        if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
         // intentionally return no cleanup function
    // return () => { ... }
    }
});
var $8c77471a259a642c$export$374c483667c1ea9b = function createSingleton(tippyInstances, optionalProps) {
    var _optionalProps$popper;
    if (optionalProps === void 0) optionalProps = {};
    var individualInstances = tippyInstances;
    var references = [];
    var triggerTargets = [];
    var currentTarget;
    var overrides = optionalProps.overrides;
    var interceptSetPropsCleanups = [];
    var shownOnCreate = false;
    function setTriggerTargets() {
        triggerTargets = individualInstances.map(function(instance) {
            return $8c77471a259a642c$var$normalizeToArray(instance.props.triggerTarget || instance.reference);
        }).reduce(function(acc, item) {
            return acc.concat(item);
        }, []);
    }
    function setReferences() {
        references = individualInstances.map(function(instance) {
            return instance.reference;
        });
    }
    function enableInstances(isEnabled) {
        individualInstances.forEach(function(instance) {
            if (isEnabled) instance.enable();
            else instance.disable();
        });
    }
    function interceptSetProps(singleton) {
        return individualInstances.map(function(instance) {
            var originalSetProps = instance.setProps;
            instance.setProps = function(props) {
                originalSetProps(props);
                if (instance.reference === currentTarget) singleton.setProps(props);
            };
            return function() {
                instance.setProps = originalSetProps;
            };
        });
    } // have to pass singleton, as it maybe undefined on first call
    function prepareInstance(singleton, target) {
        var index = triggerTargets.indexOf(target); // bail-out
        if (target === currentTarget) return;
        currentTarget = target;
        var overrideProps = (overrides || []).concat("content").reduce(function(acc, prop) {
            acc[prop] = individualInstances[index].props[prop];
            return acc;
        }, {});
        singleton.setProps(Object.assign({}, overrideProps, {
            getReferenceClientRect: typeof overrideProps.getReferenceClientRect === "function" ? overrideProps.getReferenceClientRect : function() {
                var _references$index;
                return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();
            }
        }));
    }
    enableInstances(false);
    setReferences();
    setTriggerTargets();
    var plugin = {
        fn: function fn() {
            return {
                onDestroy: function onDestroy() {
                    enableInstances(true);
                },
                onHidden: function onHidden() {
                    currentTarget = null;
                },
                onClickOutside: function onClickOutside(instance) {
                    if (instance.props.showOnCreate && !shownOnCreate) {
                        shownOnCreate = true;
                        currentTarget = null;
                    }
                },
                onShow: function onShow(instance) {
                    if (instance.props.showOnCreate && !shownOnCreate) {
                        shownOnCreate = true;
                        prepareInstance(instance, references[0]);
                    }
                },
                onTrigger: function onTrigger(instance, event) {
                    prepareInstance(instance, event.currentTarget);
                }
            };
        }
    };
    var singleton1 = $8c77471a259a642c$var$tippy($8c77471a259a642c$var$div(), Object.assign({}, $8c77471a259a642c$var$removeProperties(optionalProps, [
        "overrides"
    ]), {
        plugins: [
            plugin
        ].concat(optionalProps.plugins || []),
        triggerTarget: triggerTargets,
        popperOptions: Object.assign({}, optionalProps.popperOptions, {
            modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [
                $8c77471a259a642c$var$applyStylesModifier
            ])
        })
    }));
    var originalShow = singleton1.show;
    singleton1.show = function(target) {
        originalShow(); // first time, showOnCreate or programmatic call with no params
        // default to showing first instance
        if (!currentTarget && target == null) return prepareInstance(singleton1, references[0]);
         // triggered from event (do nothing as prepareInstance already called by onTrigger)
        // programmatic call with no params when already visible (do nothing again)
        if (currentTarget && target == null) return;
         // target is index of instance
        if (typeof target === "number") return references[target] && prepareInstance(singleton1, references[target]);
         // target is a child tippy instance
        if (individualInstances.indexOf(target) >= 0) {
            var ref = target.reference;
            return prepareInstance(singleton1, ref);
        } // target is a ReferenceElement
        if (references.indexOf(target) >= 0) return prepareInstance(singleton1, target);
    };
    singleton1.showNext = function() {
        var first = references[0];
        if (!currentTarget) return singleton1.show(0);
        var index = references.indexOf(currentTarget);
        singleton1.show(references[index + 1] || first);
    };
    singleton1.showPrevious = function() {
        var last = references[references.length - 1];
        if (!currentTarget) return singleton1.show(last);
        var index = references.indexOf(currentTarget);
        var target = references[index - 1] || last;
        singleton1.show(target);
    };
    var originalSetProps1 = singleton1.setProps;
    singleton1.setProps = function(props) {
        overrides = props.overrides || overrides;
        originalSetProps1(props);
    };
    singleton1.setInstances = function(nextInstances) {
        enableInstances(true);
        interceptSetPropsCleanups.forEach(function(fn) {
            return fn();
        });
        individualInstances = nextInstances;
        enableInstances(false);
        setReferences();
        setTriggerTargets();
        interceptSetPropsCleanups = interceptSetProps(singleton1);
        singleton1.setProps({
            triggerTarget: triggerTargets
        });
    };
    interceptSetPropsCleanups = interceptSetProps(singleton1);
    return singleton1;
};
var $8c77471a259a642c$var$BUBBLING_EVENTS_MAP = {
    mouseover: "mouseenter",
    focusin: "focus",
    click: "click"
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */ function $8c77471a259a642c$export$10b1921597150314(targets, props) {
    var listeners = [];
    var childTippyInstances = [];
    var disabled = false;
    var target = props.target;
    var nativeProps = $8c77471a259a642c$var$removeProperties(props, [
        "target"
    ]);
    var parentProps = Object.assign({}, nativeProps, {
        trigger: "manual",
        touch: false
    });
    var childProps = Object.assign({
        touch: $8c77471a259a642c$var$defaultProps.touch
    }, nativeProps, {
        showOnCreate: true
    });
    var returnValue = $8c77471a259a642c$var$tippy(targets, parentProps);
    var normalizedReturnValue = $8c77471a259a642c$var$normalizeToArray(returnValue);
    function onTrigger(event) {
        if (!event.target || disabled) return;
        var targetNode = event.target.closest(target);
        if (!targetNode) return;
         // Get relevant trigger with fallbacks:
        // 1. Check `data-tippy-trigger` attribute on target node
        // 2. Fallback to `trigger` passed to `delegate()`
        // 3. Fallback to `defaultProps.trigger`
        var trigger = targetNode.getAttribute("data-tippy-trigger") || props.trigger || $8c77471a259a642c$var$defaultProps.trigger; // @ts-ignore
        if (targetNode._tippy) return;
        if (event.type === "touchstart" && typeof childProps.touch === "boolean") return;
        if (event.type !== "touchstart" && trigger.indexOf($8c77471a259a642c$var$BUBBLING_EVENTS_MAP[event.type]) < 0) return;
        var instance = $8c77471a259a642c$var$tippy(targetNode, childProps);
        if (instance) childTippyInstances = childTippyInstances.concat(instance);
    }
    function on(node, eventType, handler, options) {
        if (options === void 0) options = false;
        node.addEventListener(eventType, handler, options);
        listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
        });
    }
    function addEventListeners(instance) {
        var reference = instance.reference;
        on(reference, "touchstart", onTrigger, $8c77471a259a642c$var$TOUCH_OPTIONS);
        on(reference, "mouseover", onTrigger);
        on(reference, "focusin", onTrigger);
        on(reference, "click", onTrigger);
    }
    function removeEventListeners() {
        listeners.forEach(function(_ref) {
            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
            node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
    }
    function applyMutations(instance2) {
        var originalDestroy = instance2.destroy;
        var originalEnable = instance2.enable;
        var originalDisable = instance2.disable;
        instance2.destroy = function(shouldDestroyChildInstances) {
            if (shouldDestroyChildInstances === void 0) shouldDestroyChildInstances = true;
            if (shouldDestroyChildInstances) childTippyInstances.forEach(function(instance) {
                instance.destroy();
            });
            childTippyInstances = [];
            removeEventListeners();
            originalDestroy();
        };
        instance2.enable = function() {
            originalEnable();
            childTippyInstances.forEach(function(instance) {
                return instance.enable();
            });
            disabled = false;
        };
        instance2.disable = function() {
            originalDisable();
            childTippyInstances.forEach(function(instance) {
                return instance.disable();
            });
            disabled = true;
        };
        addEventListeners(instance2);
    }
    normalizedReturnValue.forEach(applyMutations);
    return returnValue;
}
var $8c77471a259a642c$export$dd8ded329c01db79 = {
    name: "animateFill",
    defaultValue: false,
    fn: function fn(instance) {
        var _instance$props$rende;
        // @ts-ignore
        if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) return {};
        var _getChildren = $8c77471a259a642c$var$getChildren(instance.popper), box = _getChildren.box, content = _getChildren.content;
        var backdrop = instance.props.animateFill ? $8c77471a259a642c$var$createBackdropElement() : null;
        return {
            onCreate: function onCreate() {
                if (backdrop) {
                    box.insertBefore(backdrop, box.firstElementChild);
                    box.setAttribute("data-animatefill", "");
                    box.style.overflow = "hidden";
                    instance.setProps({
                        arrow: false,
                        animation: "shift-away"
                    });
                }
            },
            onMount: function onMount() {
                if (backdrop) {
                    var transitionDuration = box.style.transitionDuration;
                    var duration = Number(transitionDuration.replace("ms", "")); // The content should fade in after the backdrop has mostly filled the
                    // tooltip element. `clip-path` is the other alternative but is not
                    // well-supported and is buggy on some devices.
                    content.style.transitionDelay = Math.round(duration / 10) + "ms";
                    backdrop.style.transitionDuration = transitionDuration;
                    $8c77471a259a642c$var$setVisibilityState([
                        backdrop
                    ], "visible");
                }
            },
            onShow: function onShow() {
                if (backdrop) backdrop.style.transitionDuration = "0ms";
            },
            onHide: function onHide() {
                if (backdrop) $8c77471a259a642c$var$setVisibilityState([
                    backdrop
                ], "hidden");
            }
        };
    }
};
function $8c77471a259a642c$var$createBackdropElement() {
    var backdrop = $8c77471a259a642c$var$div();
    backdrop.className = $8c77471a259a642c$var$BACKDROP_CLASS;
    $8c77471a259a642c$var$setVisibilityState([
        backdrop
    ], "hidden");
    return backdrop;
}
var $8c77471a259a642c$var$mouseCoords = {
    clientX: 0,
    clientY: 0
};
var $8c77471a259a642c$var$activeInstances = [];
function $8c77471a259a642c$var$storeMouseCoords(_ref) {
    var clientX = _ref.clientX, clientY = _ref.clientY;
    $8c77471a259a642c$var$mouseCoords = {
        clientX: clientX,
        clientY: clientY
    };
}
function $8c77471a259a642c$var$addMouseCoordsListener(doc) {
    doc.addEventListener("mousemove", $8c77471a259a642c$var$storeMouseCoords);
}
function $8c77471a259a642c$var$removeMouseCoordsListener(doc) {
    doc.removeEventListener("mousemove", $8c77471a259a642c$var$storeMouseCoords);
}
var $8c77471a259a642c$export$ac81526b64504ab6 = {
    name: "followCursor",
    defaultValue: false,
    fn: function fn(instance) {
        var reference = instance.reference;
        var doc = $8c77471a259a642c$var$getOwnerDocument(instance.props.triggerTarget || reference);
        var isInternalUpdate = false;
        var wasFocusEvent = false;
        var isUnmounted = true;
        var prevProps = instance.props;
        function getIsInitialBehavior() {
            return instance.props.followCursor === "initial" && instance.state.isVisible;
        }
        function addListener() {
            doc.addEventListener("mousemove", onMouseMove);
        }
        function removeListener() {
            doc.removeEventListener("mousemove", onMouseMove);
        }
        function unsetGetReferenceClientRect() {
            isInternalUpdate = true;
            instance.setProps({
                getReferenceClientRect: null
            });
            isInternalUpdate = false;
        }
        function onMouseMove(event) {
            // If the instance is interactive, avoid updating the position unless it's
            // over the reference element
            var isCursorOverReference = event.target ? reference.contains(event.target) : true;
            var followCursor1 = instance.props.followCursor;
            var clientX = event.clientX, clientY = event.clientY;
            var rect1 = reference.getBoundingClientRect();
            var relativeX = clientX - rect1.left;
            var relativeY = clientY - rect1.top;
            if (isCursorOverReference || !instance.props.interactive) instance.setProps({
                // @ts-ignore - unneeded DOMRect properties
                getReferenceClientRect: function getReferenceClientRect() {
                    var rect = reference.getBoundingClientRect();
                    var x = clientX;
                    var y = clientY;
                    if (followCursor1 === "initial") {
                        x = rect.left + relativeX;
                        y = rect.top + relativeY;
                    }
                    var top = followCursor1 === "horizontal" ? rect.top : y;
                    var right = followCursor1 === "vertical" ? rect.right : x;
                    var bottom = followCursor1 === "horizontal" ? rect.bottom : y;
                    var left = followCursor1 === "vertical" ? rect.left : x;
                    return {
                        width: right - left,
                        height: bottom - top,
                        top: top,
                        right: right,
                        bottom: bottom,
                        left: left
                    };
                }
            });
        }
        function create() {
            if (instance.props.followCursor) {
                $8c77471a259a642c$var$activeInstances.push({
                    instance: instance,
                    doc: doc
                });
                $8c77471a259a642c$var$addMouseCoordsListener(doc);
            }
        }
        function destroy() {
            $8c77471a259a642c$var$activeInstances = $8c77471a259a642c$var$activeInstances.filter(function(data) {
                return data.instance !== instance;
            });
            if ($8c77471a259a642c$var$activeInstances.filter(function(data) {
                return data.doc === doc;
            }).length === 0) $8c77471a259a642c$var$removeMouseCoordsListener(doc);
        }
        return {
            onCreate: create,
            onDestroy: destroy,
            onBeforeUpdate: function onBeforeUpdate() {
                prevProps = instance.props;
            },
            onAfterUpdate: function onAfterUpdate(_, _ref2) {
                var followCursor2 = _ref2.followCursor;
                if (isInternalUpdate) return;
                if (followCursor2 !== undefined && prevProps.followCursor !== followCursor2) {
                    destroy();
                    if (followCursor2) {
                        create();
                        if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) addListener();
                    } else {
                        removeListener();
                        unsetGetReferenceClientRect();
                    }
                }
            },
            onMount: function onMount() {
                if (instance.props.followCursor && !wasFocusEvent) {
                    if (isUnmounted) {
                        onMouseMove($8c77471a259a642c$var$mouseCoords);
                        isUnmounted = false;
                    }
                    if (!getIsInitialBehavior()) addListener();
                }
            },
            onTrigger: function onTrigger(_, event) {
                if ($8c77471a259a642c$var$isMouseEvent(event)) $8c77471a259a642c$var$mouseCoords = {
                    clientX: event.clientX,
                    clientY: event.clientY
                };
                wasFocusEvent = event.type === "focus";
            },
            onHidden: function onHidden() {
                if (instance.props.followCursor) {
                    unsetGetReferenceClientRect();
                    removeListener();
                    isUnmounted = true;
                }
            }
        };
    }
};
function $8c77471a259a642c$var$getProps(props, modifier) {
    var _props$popperOptions;
    return {
        popperOptions: Object.assign({}, props.popperOptions, {
            modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function(_ref) {
                var name = _ref.name;
                return name !== modifier.name;
            }), [
                modifier
            ])
        })
    };
}
var $8c77471a259a642c$export$e2b668424a9c728 = {
    name: "inlinePositioning",
    defaultValue: false,
    fn: function fn(instance) {
        var reference = instance.reference;
        function isEnabled() {
            return !!instance.props.inlinePositioning;
        }
        var placement1;
        var cursorRectIndex = -1;
        var isInternalUpdate = false;
        var triedPlacements = [];
        var modifier = {
            name: "tippyInlinePositioning",
            enabled: true,
            phase: "afterWrite",
            fn: function fn(_ref2) {
                var state = _ref2.state;
                if (isEnabled()) {
                    if (triedPlacements.indexOf(state.placement) !== -1) triedPlacements = [];
                    if (placement1 !== state.placement && triedPlacements.indexOf(state.placement) === -1) {
                        triedPlacements.push(state.placement);
                        instance.setProps({
                            // @ts-ignore - unneeded DOMRect properties
                            getReferenceClientRect: function getReferenceClientRect() {
                                return _getReferenceClientRect(state.placement);
                            }
                        });
                    }
                    placement1 = state.placement;
                }
            }
        };
        function _getReferenceClientRect(placement) {
            return $8c77471a259a642c$var$getInlineBoundingClientRect($8c77471a259a642c$var$getBasePlacement(placement), reference.getBoundingClientRect(), $8c77471a259a642c$var$arrayFrom(reference.getClientRects()), cursorRectIndex);
        }
        function setInternalProps(partialProps) {
            isInternalUpdate = true;
            instance.setProps(partialProps);
            isInternalUpdate = false;
        }
        function addModifier() {
            if (!isInternalUpdate) setInternalProps($8c77471a259a642c$var$getProps(instance.props, modifier));
        }
        return {
            onCreate: addModifier,
            onAfterUpdate: addModifier,
            onTrigger: function onTrigger(_, event) {
                if ($8c77471a259a642c$var$isMouseEvent(event)) {
                    var rects = $8c77471a259a642c$var$arrayFrom(instance.reference.getClientRects());
                    var cursorRect = rects.find(function(rect) {
                        return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
                    });
                    var index = rects.indexOf(cursorRect);
                    cursorRectIndex = index > -1 ? index : cursorRectIndex;
                }
            },
            onHidden: function onHidden() {
                cursorRectIndex = -1;
            }
        };
    }
};
function $8c77471a259a642c$var$getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
    // Not an inline element, or placement is not yet known
    if (clientRects.length < 2 || currentBasePlacement === null) return boundingRect;
     // There are two rects and they are disjoined
    if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) return clientRects[cursorRectIndex] || boundingRect;
    switch(currentBasePlacement){
        case "top":
        case "bottom":
            var firstRect = clientRects[0];
            var lastRect = clientRects[clientRects.length - 1];
            var isTop = currentBasePlacement === "top";
            var top = firstRect.top;
            var bottom = lastRect.bottom;
            var left = isTop ? firstRect.left : lastRect.left;
            var right = isTop ? firstRect.right : lastRect.right;
            var width = right - left;
            var height = bottom - top;
            return {
                top: top,
                bottom: bottom,
                left: left,
                right: right,
                width: width,
                height: height
            };
        case "left":
        case "right":
            var minLeft = Math.min.apply(Math, clientRects.map(function(rects) {
                return rects.left;
            }));
            var maxRight = Math.max.apply(Math, clientRects.map(function(rects) {
                return rects.right;
            }));
            var measureRects = clientRects.filter(function(rect) {
                return currentBasePlacement === "left" ? rect.left === minLeft : rect.right === maxRight;
            });
            var _top = measureRects[0].top;
            var _bottom = measureRects[measureRects.length - 1].bottom;
            var _left = minLeft;
            var _right = maxRight;
            var _width = _right - _left;
            var _height = _bottom - _top;
            return {
                top: _top,
                bottom: _bottom,
                left: _left,
                right: _right,
                width: _width,
                height: _height
            };
        default:
            return boundingRect;
    }
}
var $8c77471a259a642c$export$4bd4b47501432316 = {
    name: "sticky",
    defaultValue: false,
    fn: function fn(instance) {
        var reference = instance.reference, popper = instance.popper;
        function getReference() {
            return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
        }
        function shouldCheck(value) {
            return instance.props.sticky === true || instance.props.sticky === value;
        }
        var prevRefRect = null;
        var prevPopRect = null;
        function updatePosition() {
            var currentRefRect = shouldCheck("reference") ? getReference().getBoundingClientRect() : null;
            var currentPopRect = shouldCheck("popper") ? popper.getBoundingClientRect() : null;
            if (currentRefRect && $8c77471a259a642c$var$areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && $8c77471a259a642c$var$areRectsDifferent(prevPopRect, currentPopRect)) {
                if (instance.popperInstance) instance.popperInstance.update();
            }
            prevRefRect = currentRefRect;
            prevPopRect = currentPopRect;
            if (instance.state.isMounted) requestAnimationFrame(updatePosition);
        }
        return {
            onMount: function onMount() {
                if (instance.props.sticky) updatePosition();
            }
        };
    }
};
function $8c77471a259a642c$var$areRectsDifferent(rectA, rectB) {
    if (rectA && rectB) return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
    return true;
}
$8c77471a259a642c$var$tippy.setDefaultProps({
    render: $8c77471a259a642c$var$render
});
var $8c77471a259a642c$export$2e2bcd8739ae039 = $8c77471a259a642c$var$tippy;


var $1c26c315bbe147ca$exports = {};
$1c26c315bbe147ca$exports = ".tippy-box[data-animation=\"fade\"][data-state=\"hidden\"] {\n  opacity: 0;\n}\n\n[data-tippy-root] {\n  max-width: calc(100vw - 10px);\n}\n\n.tippy-box {\n  color: #fff;\n  white-space: normal;\n  background-color: #333;\n  border-radius: 4px;\n  outline: 0;\n  font-size: 14px;\n  line-height: 1.4;\n  transition-property: transform, visibility, opacity;\n  position: relative;\n}\n\n.tippy-box[data-placement^=\"top\"] > .tippy-arrow {\n  bottom: 0;\n}\n\n.tippy-box[data-placement^=\"top\"] > .tippy-arrow:before {\n  border-width: 8px 8px 0;\n  border-top-color: initial;\n  transform-origin: top;\n  bottom: -7px;\n  left: 0;\n}\n\n.tippy-box[data-placement^=\"bottom\"] > .tippy-arrow {\n  top: 0;\n}\n\n.tippy-box[data-placement^=\"bottom\"] > .tippy-arrow:before {\n  border-width: 0 8px 8px;\n  border-bottom-color: initial;\n  transform-origin: bottom;\n  top: -7px;\n  left: 0;\n}\n\n.tippy-box[data-placement^=\"left\"] > .tippy-arrow {\n  right: 0;\n}\n\n.tippy-box[data-placement^=\"left\"] > .tippy-arrow:before {\n  border-width: 8px 0 8px 8px;\n  border-left-color: initial;\n  transform-origin: 0;\n  right: -7px;\n}\n\n.tippy-box[data-placement^=\"right\"] > .tippy-arrow {\n  left: 0;\n}\n\n.tippy-box[data-placement^=\"right\"] > .tippy-arrow:before {\n  border-width: 8px 8px 8px 0;\n  border-right-color: initial;\n  transform-origin: 100%;\n  left: -7px;\n}\n\n.tippy-box[data-inertia][data-state=\"visible\"] {\n  transition-timing-function: cubic-bezier(.54, 1.5, .38, 1.11);\n}\n\n.tippy-arrow {\n  width: 16px;\n  height: 16px;\n  color: #333;\n}\n\n.tippy-arrow:before {\n  content: \"\";\n  border-style: solid;\n  border-color: #0000;\n  position: absolute;\n}\n\n.tippy-content {\n  z-index: 1;\n  padding: 5px 9px;\n  position: relative;\n}\n\n";


var $812a1dcf6f9f038f$exports = {};
$812a1dcf6f9f038f$exports = ":host {\n  position: relative;\n}\n\n:host #tip {\n  display: inline-block;\n}\n\n";


var $93fa5e13b748ef2a$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var $93fa5e13b748ef2a$var$Tooltip_1;
let $93fa5e13b748ef2a$export$28c660c63b792dea = $93fa5e13b748ef2a$var$Tooltip_1 = class Tooltip extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.trigger = "mouseenter";
        if (!$93fa5e13b748ef2a$var$Tooltip_1.stylesSet) {
            let style = document.createElement("style");
            style.textContent = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($1c26c315bbe147ca$exports)))).cssText;
            document.body.prepend(style);
            $93fa5e13b748ef2a$var$Tooltip_1.stylesSet = true;
        }
    }
    firstUpdated() {
        let el = this.shadowRoot.getElementById("tip");
        let contentEl = this.querySelector('[slot="tip"]');
        let content = this.text;
        let interact = false;
        if (contentEl) {
            content = contentEl;
            interact = true;
            this.trigger = "mousedown";
        }
        (0, $8c77471a259a642c$export$2e2bcd8739ae039)(el, {
            content: content,
            appendTo: this,
            trigger: this.trigger,
            interactive: interact
        });
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="tip"><slot></slot>
          </div>`;
    }
};
$93fa5e13b748ef2a$export$28c660c63b792dea.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($812a1dcf6f9f038f$exports))));
$93fa5e13b748ef2a$export$28c660c63b792dea.stylesSet = false;
$93fa5e13b748ef2a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $93fa5e13b748ef2a$export$28c660c63b792dea.prototype, "text", void 0);
$93fa5e13b748ef2a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $93fa5e13b748ef2a$export$28c660c63b792dea.prototype, "trigger", void 0);
$93fa5e13b748ef2a$export$28c660c63b792dea = $93fa5e13b748ef2a$var$Tooltip_1 = $93fa5e13b748ef2a$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-tooltip")
], $93fa5e13b748ef2a$export$28c660c63b792dea);


var $b073df56e351bf37$exports = {};


var $8e1b34a24ee30b5f$exports = {};
$8e1b34a24ee30b5f$exports = ":host {\n  width: 100%;\n}\n\n#tabs {\n  background-color: var(--light, #f1f1f1);\n  height: 80px;\n  border: 1px solid #ccc;\n  flex-direction: row;\n  display: flex;\n  overflow: visible;\n}\n\n#tabs-container {\n  flex-direction: column;\n  display: flex;\n}\n\n#tabs-container.vertical {\n  flex-direction: row;\n}\n\n#tabs-container.vertical #tabs {\n  flex-direction: column;\n}\n\n#tabs-container.vertical #tabs .group {\n  flex-direction: column;\n  display: flex;\n}\n\n#tabs .title {\n  background-color: inherit;\n  cursor: pointer;\n  border: none;\n  outline: none;\n  padding: 14px 16px;\n}\n\n#tabs .title.open {\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n}\n\n#tabs .title.open span {\n  padding-left: 16px;\n}\n\n#tabs .title.open div {\n  display: inline-block;\n}\n\n#tabs .title div {\n  display: none;\n}\n\n#tabs .title:hover {\n  background-color: var(--active, #ddd);\n}\n\n#tabs .title.active {\n  background-color: var(--active, #ccc);\n}\n\n.panel {\n  background-color: var(--light);\n  border: 1px solid #ccc;\n  border-top: none;\n  flex: 1;\n  padding: 6px 12px;\n  animation: fadeEffect 1s;\n  display: none;\n}\n\n@keyframes fadeEffect {\n  from {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n}\n\n";




var $ad5a5e3d85db6c6d$export$3fd36d65bf762270;
(function(EventNames1) {
    EventNames1["ButtonClick"] = "button-click";
    EventNames1["PreviousClick"] = "previous-click";
    EventNames1["NextClick"] = "next-click";
    EventNames1["Changed"] = "changed";
    EventNames1["Selected"] = "selected";
    EventNames1["Deselected"] = "deselected";
    EventNames1["Disposed"] = "disposed";
})($ad5a5e3d85db6c6d$export$3fd36d65bf762270 || ($ad5a5e3d85db6c6d$export$3fd36d65bf762270 = {}));


/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ function $381ea5e2aef5c344$export$a55877ca9db47377(n1, o, r) {
    return n1 ? o() : null == r ? void 0 : r();
}




var $b073df56e351bf37$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $b073df56e351bf37$export$2b39608944d1651e = class JuelTabs extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.ids = [];
        this.index = 0;
        this.vertical = false;
    }
    displayTab(evt, id) {
        var i, tabcontent, tablinks;
        tabcontent = this.shadowRoot.querySelectorAll(".panel");
        if (tabcontent) {
            for(i = 0; i < tabcontent.length; i++)tabcontent[i].style.display = "none";
            tablinks = this.shadowRoot.querySelectorAll(".title");
            for(i = 0; i < tablinks.length; i++)tablinks[i].classList.remove("active");
            let el = this.shadowRoot.querySelector(`#${id}`);
            if (el) {
                el.style.display = "block";
                if (evt && evt.target) evt.target.classList.add("active");
                else {
                    let tab = this.shadowRoot.querySelector(`#${id}-title`);
                    if (tab) {
                        let group = tab.closest(".group");
                        if (group) group.classList.add("open");
                        tab.classList.add("active");
                    }
                }
                let e = new CustomEvent((0, $ad5a5e3d85db6c6d$export$3fd36d65bf762270).Changed, {
                    detail: {
                        index: this.ids.indexOf(id)
                    }
                });
                this.dispatchEvent(e);
            }
        }
    }
    load() {
        this.openTab(this.index);
    }
    openTab(i) {
        if (i >= 0 && i < this.ids.length) {
            this.index = i;
            this.displayTab(null, this.ids[this.index]);
        }
    }
    childrenMap(level, idStr) {
        return (el1, index)=>{
            let result = [];
            let id = el1.id ? el1.id : idStr ? `${idStr}-${index}` : `tab-section-${index}`;
            el1.setAttribute("slot", id);
            if (level > 0) {
                el1.remove();
                this.append(el1);
            }
            let titleClass = "title";
            let hasTitleEl = false;
            let titleElId = `${id}-title`;
            let titleEl = el1.previousElementSibling;
            if (titleEl && titleEl.matches("[slot$='title']")) {
                hasTitleEl = true;
                titleEl.setAttribute("slot", titleElId);
                if (level > 0) {
                    titleEl.remove();
                    this.append(titleEl);
                }
            }
            let children = el1.children;
            let hasChildTabs;
            let hasContent = true;
            for (let child of children)if (child.matches("[data-title], [slot$='title']")) {
                hasChildTabs = true;
                hasContent = false;
            } else hasContent = true;
            let event;
            if (hasContent) {
                this.ids.push(id);
                event = (e)=>{
                    e.stopPropagation();
                    this.displayTab(e, id);
                };
            } else {
                titleClass += " group";
                event = (e)=>{
                    let el = e.target;
                    el.closest(".group").classList.toggle("open");
                };
            }
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="${titleElId}" has-content="${hasContent}" class="${titleClass}" @click="${event}">
                ${hasTitleEl ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<slot name="${titleElId}"></slot>` : (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<span>
                        ${el1.dataset.title ? el1.dataset.title : ""}
                    </span>`}
                ${(0, $381ea5e2aef5c344$export$a55877ca9db47377)(hasChildTabs, ()=>(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(el1, this.childrenMap(level + 1, id), '[slot="header"], [slot="footer"], [slot="prepend"], [slot="append"], [slot$="title"]'))}
                </div>`;
        };
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<slot name="header"></slot>
            <div id="tabs-container" class="${this.vertical ? `vertical` : ``}">
            <div id="tabs">
            <div><slot name="prepend"></slot></div>
            ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, this.childrenMap(0), '[slot="header"], [slot="footer"], [slot="prepend"], [slot="append"], [slot$="title"]')}
                <div><slot name="append"></slot></div>
                </div>
                ${this.ids.map((id)=>{
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`</div>
                        <div id="${id}" class="panel">
                        <slot name="${id}"></slot>
                        </div>`;
        })}
        </div>
        <slot name="footer"></slot>`;
    }
};
$b073df56e351bf37$export$2b39608944d1651e.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($8e1b34a24ee30b5f$exports))));
$b073df56e351bf37$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $b073df56e351bf37$export$2b39608944d1651e.prototype, "index", void 0);
$b073df56e351bf37$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $b073df56e351bf37$export$2b39608944d1651e.prototype, "vertical", void 0);
$b073df56e351bf37$export$2b39608944d1651e = $b073df56e351bf37$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-tabs")
], $b073df56e351bf37$export$2b39608944d1651e);


var $0db6702f2e2ee9fc$exports = {};



/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $782b9679dcaaea44$export$9ba3b3f20a85bfa = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
}, $782b9679dcaaea44$export$99b43ad1ed32e735 = (t1)=>(...e1)=>({
            _$litDirective$: t1,
            values: e1
        });
class $782b9679dcaaea44$export$befdefbdce210f91 {
    constructor(t){}
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AT(t2, e2, i1) {
        this._$Ct = t2, this._$AM = e2, this._$Ci = i1;
    }
    _$AS(t3, e3) {
        return this.update(t3, e3);
    }
    update(t, e4) {
        return this.render(...e4);
    }
}


/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ class $06981aafc7b47e91$export$3bebd1f0e3943985 extends (0, $782b9679dcaaea44$export$befdefbdce210f91) {
    constructor(i1){
        if (super(i1), this.it = (0, $37260750aa7b368d$export$45b790e32b2810ee), i1.type !== (0, $782b9679dcaaea44$export$9ba3b3f20a85bfa).CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(r1) {
        if (r1 === (0, $37260750aa7b368d$export$45b790e32b2810ee) || null == r1) return this.ft = void 0, this.it = r1;
        if (r1 === (0, $37260750aa7b368d$export$9c068ae9cc5db4e8)) return r1;
        if ("string" != typeof r1) throw Error(this.constructor.directiveName + "() called with a non-string value");
        if (r1 === this.it) return this.ft;
        this.it = r1;
        const s1 = [
            r1
        ];
        return s1.raw = s1, this.ft = {
            _$litType$: this.constructor.resultType,
            strings: s1,
            values: []
        };
    }
}
$06981aafc7b47e91$export$3bebd1f0e3943985.directiveName = "unsafeHTML", $06981aafc7b47e91$export$3bebd1f0e3943985.resultType = 1;
const $06981aafc7b47e91$export$b6e69390c23686fb = (0, $782b9679dcaaea44$export$99b43ad1ed32e735)($06981aafc7b47e91$export$3bebd1f0e3943985);





var $7cd237bcc800ad08$exports = {};
$7cd237bcc800ad08$exports = ":host {\n  font-family: Arial;\n  position: relative;\n}\n\nsvg {\n  width: 32px;\n  height: 32px;\n}\n\ndiv {\n  display: inline-block;\n}\n\n#items {\n  background-color: var(--light);\n  z-index: 101;\n}\n\n#badge {\n  width: 16px;\n  height: 16px;\n  background: red;\n  border-radius: 25px;\n  place-content: center;\n  font-size: small;\n  display: flex;\n  position: absolute;\n  top: 6px;\n  left: 80%;\n}\n\n#badge:before {\n  content: \"\";\n}\n\n#selected-placeholder {\n  cursor: pointer;\n  user-select: none;\n  border: 1px solid #000;\n  padding: 8px 16px;\n}\n\nselect {\n  display: none;\n}\n\n#select #arrow {\n  content: \"\";\n  width: 0;\n  height: 0;\n  border: 6px solid #0000;\n  border-color: var(--primary) transparent transparent transparent;\n  position: absolute;\n  top: 14px;\n  right: 10px;\n}\n\n#select.open #arrow {\n  border-color: transparent transparent var(--primary) transparent;\n  top: 7px;\n}\n\n#items-container, .selected {\n  cursor: pointer;\n  border: 1px solid #000;\n}\n\n#items-container {\n  display: inline-block;\n  position: absolute;\n}\n\n.item {\n  width: 100%;\n  display: inline-block;\n}\n\n.item.selected, .item:hover {\n  background-color: var(--primary);\n}\n\n";


function $38d8c756f0a655d2$export$65fee5f8f91a342f(el, name, args) {
    let evt = new CustomEvent(name, {
        detail: args
    });
    el.dispatchEvent(evt);
    if (el.juelParent) el.juelParent.dispatchEvent(evt);
}



class $7cf92cd4e9126847$export$448ee86705ad98f3 {
    constructor(){
        this.selectedSlot = null;
    }
    createSelect(select) {
        let sel = document.createElement("select");
        let options = select.data.map((item)=>{
            let opt = document.createElement("option");
            opt.textContent = item;
            opt.value = item;
            return opt;
        });
        for (let opt1 of options)sel.append(opt1);
        return sel;
    }
    init(select) {
        let service = this;
        let children = select.children;
        if (!select.data) select.data = Array.prototype.slice.call(children).filter((el)=>el.classList.contains("juel-item")).map((el)=>"value" in el.dataset ? el.dataset.value : el.textContent);
        if (select.multiple) select.value = [];
        let firstItm = $(select.shadowRoot.querySelector(".item"));
        let placeholder = select.shadowRoot.querySelector("#selected-placeholder");
        placeholder.style.minWidth = `${firstItm.outerWidth()}px`;
        placeholder.style.minHeight = `${firstItm.outerHeight()}px`;
        select.shadowRoot.querySelectorAll(".item").forEach((el)=>{
            $(el).off("click").on("click", function(event) {
                service.selectedSlot = el.querySelector("slot").getAttribute("name");
                let item1 = select.querySelector(`[slot="${service.selectedSlot}"]`);
                if (item1) {
                    let index = parseInt(el.dataset.index);
                    let value = select.data[index];
                    if (select.multiple == false) select.value = [
                        value
                    ];
                    else if (!select.value.some((item)=>item == value)) select.value.push(value);
                    else {
                        select.value = select.value.filter((item)=>item != value);
                        if (select.placeholderIndex == index && select.value.length > 0) select.placeholderIndex = select.data.indexOf(select.value[0]);
                        if (select.value.length == 0) select.placeholderIndex = null;
                    }
                    if (select.value.length == 1) select.placeholderIndex = index;
                    if (!select.multiple) select.hide();
                    let args = {
                        value: select.value
                    };
                    (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(select, (0, $ad5a5e3d85db6c6d$export$3fd36d65bf762270).Changed, args);
                }
            });
        });
    }
}




var $0db6702f2e2ee9fc$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $0db6702f2e2ee9fc$export$ef9b1a59e592288f = class Select extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.menuShown = false;
        this.placeholderIndex = null;
        this.value = [];
        this.service = new (0, $7cf92cd4e9126847$export$448ee86705ad98f3)();
        this.multiple = false;
    }
    setData(data) {
        this.data = data;
        this.requestUpdate();
    }
    setValue(value) {
        this.value = value;
        this.requestUpdate();
    }
    firstLoad() {
        this.service.init(this);
        this.menuShown = false;
        this.items = this.shadowRoot.getElementById("items");
        this.items.style.display = "none";
        this.trigger = this.shadowRoot.getElementById("trigger");
        $(this.trigger).off("click").on("click", (e)=>{
            console.log("Menu is shown " + this.menuShown);
            this.shadowRoot.getElementById("select").classList.toggle("open");
            if (this.menuShown == false) this.show();
            else this.hide();
        });
    }
    hide() {
        this.items.style.display = "none";
        this.items.style.opacity = "0";
        this.menu = null;
        this.menuShown = false;
    }
    show() {
        this.items.style.display = "inline-block";
        this.items.style.opacity = "1";
        this.menu = (0, $ff295692f8fc945a$export$8f7491d57c8f97a9)(this.trigger, this.items);
        this.menuShown = true;
    }
    GetPlaceholder() {
        let el1 = Array.prototype.slice.call(this.children).find((el)=>el.classList.contains("juel-item") && parseInt(el.dataset.index) == this.placeholderIndex);
        if (el1) return el1.innerHTML;
        else return "";
    }
    render() {
        let index = -1;
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="select">
            <div id="trigger">
                <div id="selected-placeholder">
                    ${this.placeholderIndex != null ? (0, $06981aafc7b47e91$export$b6e69390c23686fb)(this.GetPlaceholder()) : ``}
                </div>
                <div id="arrow"></div>
                ${this.multiple == true && this.value && this.value.length > 1 ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="badge">${this.value.length - 1}</div>` : ``}
            </div>
            <div id="items">
            ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, (ele, i)=>{
            let isHeading = false;
            if (ele.tagName.startsWith("H")) isHeading = true;
            else {
                index++;
                ele.classList.add("juel-item");
                ele.dataset.index = index;
            }
            let id = ele.id ? ele.id : `item-${i}`;
            ele.setAttribute("slot", id);
            let klass = isHeading ? "heading" : "item";
            if (this.data && this.data.length > 0 && this.data[index]) {
                let value = this.data[index];
                if (this.value && "some" in this.value && this.value.some((x)=>x == value)) klass += " selected";
            }
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                        <div class="${klass}" data-index="${index}"}>
                        <slot name="${id}"></slot>
                        </div>`;
        })}
            </div>
        </div>`;
    }
};
$0db6702f2e2ee9fc$export$ef9b1a59e592288f.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($7cd237bcc800ad08$exports))));
$0db6702f2e2ee9fc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $0db6702f2e2ee9fc$export$ef9b1a59e592288f.prototype, "data", void 0);
$0db6702f2e2ee9fc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $0db6702f2e2ee9fc$export$ef9b1a59e592288f.prototype, "multiple", void 0);
$0db6702f2e2ee9fc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $0db6702f2e2ee9fc$export$ef9b1a59e592288f.prototype, "value", void 0);
$0db6702f2e2ee9fc$export$ef9b1a59e592288f = $0db6702f2e2ee9fc$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-select")
], $0db6702f2e2ee9fc$export$ef9b1a59e592288f);


var $9d3d012ca8c1ae60$exports = {};

$parcel$export($9d3d012ca8c1ae60$exports, "JuelScrollPane", () => $9d3d012ca8c1ae60$export$a594d2c8fae2c977, (v) => $9d3d012ca8c1ae60$export$a594d2c8fae2c977 = v);


var $34ca301052f0712a$exports = {};
$34ca301052f0712a$exports = ":host {\n  transition: width .8s, height .8s;\n  display: flex;\n  overflow: hidden auto;\n}\n\n.container {\n  width: 100%;\n  height: 100%;\n  align-items: flex-start;\n  transition: margin .8s, width .8s, height .8s;\n  display: inline-flex;\n}\n\n#previous {\n  z-index: 1;\n  width: 10%;\n  color: #fff;\n  text-align: center;\n  opacity: .25;\n  cursor: pointer;\n  background: #000;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n}\n\n#previous span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-previous);\n}\n\n#next {\n  z-index: 1;\n  width: 10%;\n  color: #fff;\n  text-align: center;\n  opacity: .25;\n  cursor: pointer;\n  background: #000;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n\n#next span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-next);\n}\n\n@media screen and (max-height: 500px) {\n  .item {\n    height: 100%;\n  }\n}\n\n";



function $fbf75a1d72671db6$export$b141de964f0a90c1(max) {
    return Math.floor(Math.random() * Math.floor(max));
}



class $6149df29e8066370$export$a4f347957ca31449 {
    constructor(sp){
        this.sp = sp;
        this.positionHistory = [];
    }
    init() {
        this.container = this.sp.shadowRoot.querySelector(".container");
        let first = this.container.querySelector(".item");
        let w = $(first).outerWidth();
        let h = $(first).outerHeight();
        if (w > 0) {
            this.sp.style.width = `${w}px`;
            this.container.style.width = `${w}px`;
        } else if (this.sp.width) {
            this.sp.style.width = `${this.sp.width}px`;
            this.container.style.width = `${this.sp.width}px`;
        }
        if (this.sp.fullHeight) {
            this.sp.style.height = "100%";
            this.container.style.height = "100%";
        } else if (window["isMobile"] == false && h > 0) {
            this.sp.style.height = `${h}px`;
            this.container.style.height = `${h}px`;
        }
        this.children = $(this.container.querySelectorAll(".item"));
        this.randNumbers = [
            this.sp.position
        ];
        this.scrollTo(this.sp.position);
        this.startPosition = this.sp.position;
        if (this.sp.tabs) $(this.sp.tabs).each((index, el)=>{
            $(el).off("click").on("click", ()=>this.scrollTo(index));
        });
        if (this.sp.next) $(this.sp.next).off("click").on("click", ()=>this.next());
        if (this.sp.previous) $(this.sp.previous).off("click").on("click", ()=>this.previous());
        if (this.sp.random) $(this.sp.random).off("click").on("click", ()=>this.random());
        $(this.sp).children().each((index, el)=>{
            if (el.hasAttribute("data-toggle")) {
                let sel = el.dataset["toggle"];
                $(sel).off("click").on("click", ()=>{
                    console.log(this.sp.position + " " + index);
                    if (this.sp.position != index) this.scrollTo(index);
                    else this.scrollTo(this.sp.master);
                });
            }
        });
    }
    scrollTo(index) {
        console.log(this.container);
        let el = $(this.container.querySelectorAll(`[data-index="${index}"]`));
        let margin = 0;
        let prev = el.prevAll();
        console.log(prev);
        if (prev.length > 0) prev.each((i, sib)=>{
            margin += !this.sp.width ? $(sib).outerWidth() : this.sp.width;
        });
        if (!this.sp.fullHeight) {
            let w = el.outerWidth();
            let h = el.outerHeight();
            if (w > 0) this.sp.style.width = `${w}px`;
            if (window["isMobile"] == false && h > 0) this.sp.style.height = `${h}px`;
        }
        console.log(`-${margin}px`);
        this.container.style.marginLeft = `-${margin}px`;
        this.sp.position = index;
        let evt = new CustomEvent((0, $9d3d012ca8c1ae60$exports.JuelScrollPane).SCROLL, {
            detail: {
                index: index,
                element: el
            }
        });
        this.positionHistory.push(this.sp.position);
        if (this.positionHistory.length == this.children.length) this.positionHistory = [];
        this.sp.dispatchEvent(evt);
    }
    next() {
        this.sp.position++;
        if (this.sp.position >= this.sp.children.length) this.sp.position = 0;
        let prevEl = this.sp.children[this.sp.position];
        while(prevEl && prevEl.classList.contains("hidden")){
            this.sp.position++;
            if (this.sp.position >= this.children.length) this.sp.position = 0;
        }
        this.scrollTo(this.sp.position);
    }
    previous() {
        this.sp.position--;
        if (this.sp.position < 0) this.sp.position = this.children.length - 1;
        let nextEl = this.sp.children[this.sp.position];
        while(nextEl && nextEl.classList.contains("hidden")){
            this.sp.position--;
            if (this.sp.position < 0) this.sp.position = this.children.length - 1;
        }
        this.scrollTo(this.sp.position);
    }
    random() {
        let index = (0, $fbf75a1d72671db6$export$b141de964f0a90c1)(this.children.length);
        while(index == this.sp.position || this.positionHistory.some((n)=>n == index))index = (0, $fbf75a1d72671db6$export$b141de964f0a90c1)(this.children.length);
        this.scrollTo(index);
        this.sp.position = index;
        this.randNumbers.push(index);
        if (this.randNumbers.length == this.children.length) this.randNumbers = [
            index
        ];
    }
    reset(resetChildren = false) {
        this.scrollTo(this.startPosition);
        if (resetChildren == true) {
            let toggles = this.sp.querySelectorAll("juel-toggle");
            for (let toggle of toggles)toggle.reset();
        }
    }
}


var $285a58c52cac528e$exports = {};
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */ (function(window, document, exportName, undefined) {
    "use strict";
    var VENDOR_PREFIXES = [
        "",
        "webkit",
        "Moz",
        "MS",
        "ms",
        "o"
    ];
    var TEST_ELEMENT = document.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */ function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */ function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */ function each(obj, iterator, context) {
        var i;
        if (!obj) return;
        if (obj.forEach) obj.forEach(iterator, context);
        else if (obj.length !== undefined) {
            i = 0;
            while(i < obj.length){
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else for(i in obj)obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
    /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */ function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log = window.console && (window.console.warn || window.console.log);
            if (log) log.call(window.console, deprecationMessage, stack);
            return method.apply(this, arguments);
        };
    }
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */ var assign;
    if (typeof Object.assign !== "function") assign = function assign(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for(var nextKey in source)if (source.hasOwnProperty(nextKey)) output[nextKey] = source[nextKey];
            }
        }
        return output;
    };
    else assign = Object.assign;
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */ var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while(i < keys.length){
            if (!merge || merge && dest[keys[i]] === undefined) dest[keys[i]] = src[keys[i]];
            i++;
        }
        return dest;
    }, "extend", "Use `assign`.");
    /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */ var merge1 = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, "merge", "Use `assign`.");
    /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */ function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) assign(childP, properties);
    }
    /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */ function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */ function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) return val.apply(args ? args[0] || undefined : undefined, args);
        return val;
    }
    /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */ function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */ function hasParent(node, parent) {
        while(node){
            if (node == parent) return true;
            node = node.parentNode;
        }
        return false;
    }
    /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */ function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */ function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */ function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) return src.indexOf(find);
        else {
            var i = 0;
            while(i < src.length){
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) return i;
                i++;
            }
            return -1;
        }
    }
    /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */ function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */ function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while(i < src.length){
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) results.push(src[i]);
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) results = results.sort();
            else results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
        return results;
    }
    /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */ function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while(i < VENDOR_PREFIXES.length){
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) return prop;
            i++;
        }
        return undefined;
    }
    /**
 * get a unique id
 * @returns {number} uniqueId
 */ var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */ function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [
        "x",
        "y"
    ];
    var PROPS_CLIENT_XY = [
        "clientX",
        "clientY"
    ];
    /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */ function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [
                manager
            ])) self.handler(ev);
        };
        this.init();
    }
    Input.prototype = {
        /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */ handler: function() {},
        /**
     * bind the events
     */ init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
     * unbind the events
     */ destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */ function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) Type = inputClass;
        else if (SUPPORT_POINTER_EVENTS) Type = PointerEventInput;
        else if (SUPPORT_ONLY_TOUCH) Type = TouchInput;
        else if (!SUPPORT_TOUCH) Type = MouseInput;
        else Type = TouchMouseInput;
        return new Type(manager, inputHandler);
    }
    /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */ function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) manager.session = {};
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */ function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) session.firstInput = simpleCloneInputData(input);
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
        else if (pointersLength === 1) session.firstMultiple = false;
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */ function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */ function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while(i < input.pointers.length){
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */ function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
        var x = 0, y = 0, i = 0;
        while(i < pointersLength){
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */ function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */ function getDirection(x, y) {
        if (x === y) return DIRECTION_NONE;
        if (abs(x) >= abs(y)) return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */ function getDistance(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */ function getAngle(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */ function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */ function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    /**
 * Mouse events input
 * @constructor
 * @extends Input
 */ function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) this.pressed = true;
            if (eventType & INPUT_MOVE && ev.which !== 1) eventType = INPUT_END;
            // mouse must be down
            if (!this.pressed) return;
            if (eventType & INPUT_END) this.pressed = false;
            this.callback(this.manager, eventType, {
                pointers: [
                    ev
                ],
                changedPointers: [
                    ev
                ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    /**
 * Pointer events input
 * @constructor
 * @extends Input
 */ function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) removePointer = true;
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) return;
            // update the event in the store
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [
                    ev
                ],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) // remove from the store
            store.splice(storeIndex, 1);
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Touch events input
 * @constructor
 * @extends Input
 */ function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            // should we handle the touch events?
            if (type === INPUT_START) this.started = true;
            if (!this.started) return;
            var touches = normalizeSingleTouches.call(this, ev, type);
            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) this.started = false;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) all = uniqueArray(all.concat(changed), "identifier", true);
        return [
            all,
            changed
        ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */ function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) return;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [
                allTouches,
                allTouches
            ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while(i < targetTouches.length){
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while(i < changedTouches.length){
            if (targetIds[changedTouches[i].identifier]) changedTargetTouches.push(changedTouches[i]);
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) delete targetIds[changedTouches[i].identifier];
            i++;
        }
        if (!changedTargetTouches.length) return;
        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
        ];
    }
    /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */ var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
    }
    inherit(TouchMouseInput, Input, {
        /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */ handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) return;
            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) recordTouches.call(this, inputEvent, inputData);
            else if (isMouse && isSyntheticEvent.call(this, inputData)) return;
            this.callback(manager, inputEvent, inputData);
        },
        /**
     * remove the event listeners
     */ destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) setLastTouch.call(this, eventData);
    }
    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
                x: touch.clientX,
                y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) lts.splice(i, 1);
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }
    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for(var i = 0; i < this.lastTouches.length; i++){
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) return true;
        }
        return false;
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation"; // not implemented
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    var TOUCH_ACTION_MAP = getTouchActionProps();
    /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */ function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */ set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) value = this.compute();
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            this.actions = value.toLowerCase().trim();
        },
        /**
     * just re-set the touchAction value
     */ update: function() {
            this.set(this.manager.options.touchAction);
        },
        /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */ compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [
                    recognizer
                ])) actions = actions.concat(recognizer.getTouchAction());
            });
            return cleanTouchActions(actions.join(" "));
        },
        /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */ preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
                //do not prevent defaults if this is a tap gesture
                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;
                if (isTapPointer && isTapMovement && isTapTouchTime) return;
            }
            if (hasPanX && hasPanY) // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) return this.preventSrc(srcEvent);
        },
        /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */ preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */ function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
        // pan-x OR pan-y
        if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
        return TOUCH_ACTION_AUTO;
    }
    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) return false;
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        [
            "auto",
            "manipulation",
            "pan-y",
            "pan-x",
            "pan-x pan-y",
            "none"
        ].forEach(function(val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
    }
    /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */ var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */ function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
     * @virtual
     * @type {Object}
     */ defaults: {},
        /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */ set: function(options) {
            assign(this.options, options);
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) return this;
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) return this;
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) this.requireFail.splice(index, 1);
            return this;
        },
        /**
     * has require failures boolean
     * @returns {boolean}
     */ hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */ canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */ emit: function(input) {
            var self = this;
            var state = this.state;
            function emit(event) {
                self.manager.emit(event, input);
            }
            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) emit(self.options.event + stateStr(state));
            emit(self.options.event); // simple 'eventName' events
            if (input.additionalEvent) emit(input.additionalEvent);
            // panend and pancancel
            if (state >= STATE_ENDED) emit(self.options.event + stateStr(state));
        },
        /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */ tryEmit: function(input) {
            if (this.canEmit()) return this.emit(input);
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
     * can we emit?
     * @returns {boolean}
     */ canEmit: function() {
            var i = 0;
            while(i < this.requireFail.length){
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) return false;
                i++;
            }
            return true;
        },
        /**
     * update the recognizer
     * @param {Object} inputData
     */ recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);
            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [
                this,
                inputDataClone
            ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) this.state = STATE_POSSIBLE;
            this.state = this.process(inputDataClone);
            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) this.tryEmit(inputDataClone);
        },
        /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */ process: function(inputData) {},
        /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */ getTouchAction: function() {},
        /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */ reset: function() {}
    };
    /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */ function stateStr(state) {
        if (state & STATE_CANCELLED) return "cancel";
        else if (state & STATE_ENDED) return "end";
        else if (state & STATE_CHANGED) return "move";
        else if (state & STATE_BEGAN) return "start";
        return "";
    }
    /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */ function directionStr(direction) {
        if (direction == DIRECTION_DOWN) return "down";
        else if (direction == DIRECTION_UP) return "up";
        else if (direction == DIRECTION_LEFT) return "left";
        else if (direction == DIRECTION_RIGHT) return "right";
        return "";
    }
    /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */ function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) return manager.get(otherRecognizer);
        return otherRecognizer;
    }
    /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */ function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof AttrRecognizer
     */ defaults: {
            /**
         * @type {Number}
         * @default 1
         */ pointers: 1
        },
        /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */ attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */ process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) return state | STATE_CANCELLED;
            else if (isRecognized || isValid) {
                if (eventType & INPUT_END) return state | STATE_ENDED;
                else if (!(state & STATE_BEGAN)) return STATE_BEGAN;
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PanRecognizer
     */ defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) actions.push(TOUCH_ACTION_PAN_Y);
            if (direction & DIRECTION_VERTICAL) actions.push(TOUCH_ACTION_PAN_X);
            return actions;
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) input.additionalEvent = this.options.event + direction;
            this._super.emit.call(this, input);
        }
    });
    /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */ function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });
    /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */ function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PressRecognizer
     */ defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9 // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_AUTO
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) this.reset();
            else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) return STATE_RECOGNIZED;
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) return;
            if (input && input.eventType & INPUT_END) this.manager.emit(this.options.event + "up", input);
            else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */ function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof RotateRecognizer
     */ defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof SwipeRecognizer
     */ defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) velocity = input.overallVelocity;
            else if (direction & DIRECTION_HORIZONTAL) velocity = input.overallVelocityX;
            else if (direction & DIRECTION_VERTICAL) velocity = input.overallVelocityY;
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) this.manager.emit(this.options.event + direction, input);
            this.manager.emit(this.options.event, input);
        }
    });
    /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */ function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_MANIPULATION
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) return this.failTimeout();
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) return this.failTimeout();
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) this.count = 1;
                else this.count += 1;
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) return STATE_RECOGNIZED;
                    else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
 * @const {string}
 */ Hammer.VERSION = "2.0.7";
    /**
 * default settings
 * @namespace
 */ Hammer.defaults = {
        /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */ domEvents: false,
        /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */ touchAction: TOUCH_ACTION_COMPUTE,
        /**
     * @type {Boolean}
     * @default true
     */ enable: true,
        /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */ inputTarget: null,
        /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */ inputClass: null,
        /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */ preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [
                RotateRecognizer,
                {
                    enable: false
                }
            ],
            [
                PinchRecognizer,
                {
                    enable: false
                },
                [
                    "rotate"
                ]
            ],
            [
                SwipeRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                }
            ],
            [
                PanRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                },
                [
                    "swipe"
                ]
            ],
            [
                TapRecognizer
            ],
            [
                TapRecognizer,
                {
                    event: "doubletap",
                    taps: 2
                },
                [
                    "tap"
                ]
            ],
            [
                PressRecognizer
            ]
        ],
        /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */ cssProps: {
            /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userSelect: "none",
            /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */ touchSelect: "none",
            /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */ touchCallout: "none",
            /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */ contentZooming: "none",
            /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userDrag: "none",
            /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */ tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */ set: function(options) {
            assign(this.options, options);
            // Options that need a little more setup
            if (options.touchAction) this.touchAction.update();
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */ stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */ recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) return;
            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) curRecognizer = session.curRecognizer = null;
            var i = 0;
            while(i < recognizers.length){
                recognizer = recognizers[i];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
                else recognizer.reset();
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) curRecognizer = session.curRecognizer = recognizer;
                i++;
            }
        },
        /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */ get: function(recognizer) {
            if (recognizer instanceof Recognizer) return recognizer;
            var recognizers = this.recognizers;
            for(var i = 0; i < recognizers.length; i++){
                if (recognizers[i].options.event == recognizer) return recognizers[i];
            }
            return null;
        },
        /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */ add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) return this;
            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) this.remove(existing);
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */ remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) return this;
            recognizer = this.get(recognizer);
            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);
                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }
            return this;
        },
        /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */ on: function(events, handler) {
            if (events === undefined) return;
            if (handler === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */ off: function(events, handler) {
            if (events === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) delete handlers[event];
                else handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            });
            return this;
        },
        /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */ emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) triggerDomEvent(event, data);
            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) return;
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while(i < handlers.length){
                handlers[i](data);
                i++;
            }
        },
        /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */ destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */ function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) return;
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else element.style[prop] = manager.oldCssProps[prop] || "";
        });
        if (!add) manager.oldCssProps = {};
    }
    /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */ function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge1,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}; // jshint ignore:line
    freeGlobal.Hammer = Hammer;
    if (typeof define === "function" && define.amd) define(function() {
        return Hammer;
    });
    else if ($285a58c52cac528e$exports) $285a58c52cac528e$exports = Hammer;
    else window[exportName] = Hammer;
})(window, document, "Hammer");



var $9d3d012ca8c1ae60$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $9d3d012ca8c1ae60$export$a594d2c8fae2c977 = class JuelScrollPane extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.service = new (0, $6149df29e8066370$export$a4f347957ca31449)(this);
        this.master = 0;
        this.width = null;
        this.position = 0;
        this.vertical = false;
        this.auto = false;
        this.interval = 3000;
        this.effect = "fade";
        this.easing = "swing";
        this.duration = 1000;
        this.controls = false;
        if (!("Hammer" in window)) window["Hammer"] = (0, (/*@__PURE__*/$parcel$interopDefault($285a58c52cac528e$exports)));
    }
    firstLoad() {
        let mc = new (0, (/*@__PURE__*/$parcel$interopDefault($285a58c52cac528e$exports)))(this);
        mc.on("swipe", (e)=>{
            if (e.direction == 2) this.service.next();
            else if (e.direction == 4) this.service.previous();
        });
        this.service.init();
    }
    reset(resetChildren = false) {
        this.service.reset(resetChildren);
    }
    scrollIndex(index) {
        this.service.scrollTo(index);
    }
    scrollNext(e) {
        if (e) e.stopPropagation();
        this.service.next();
    }
    scrollPrevious(e) {
        if (e) e.stopPropagation();
        this.service.previous();
    }
    itemClick(e) {
        if (e) e.stopPropagation();
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`${this.controls ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="next" part="next" @click="${this.scrollNext}"><span></span></div>` : ``}
            <div class="container">
                ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, (el, index)=>{
            let id = el.id ? el.id : `item-${index}`;
            el.setAttribute("slot", id);
            el.setAttribute("draggable", "false");
            el.setAttribute("ondragstart", "event.preventDefault();");
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                        <div class="item" data-index="${index}" draggable="false" @click="${this.itemClick}">
                        <slot name="${id}"></slot>
                        </div>`;
        })}
            </div>
            ${this.controls ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="previous" part="previous" @click="${this.scrollPrevious}"><span></span></div>` : ``}`;
    }
};
$9d3d012ca8c1ae60$export$a594d2c8fae2c977.SCROLL = "scroll";
$9d3d012ca8c1ae60$export$a594d2c8fae2c977.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($34ca301052f0712a$exports))));
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "position", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "vertical", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "auto", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "interval", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "effect", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "easing", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "duration", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "controls", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "tabs", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "random", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "next", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "previous", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "master", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "width", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "autoHeight", void 0);
$9d3d012ca8c1ae60$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977.prototype, "fullHeight", void 0);
$9d3d012ca8c1ae60$export$a594d2c8fae2c977 = $9d3d012ca8c1ae60$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-scroll-pane")
], $9d3d012ca8c1ae60$export$a594d2c8fae2c977);


var $48a9952e168b5fc7$exports = {};


var $dd06c83c907a8a20$exports = {};
$dd06c83c907a8a20$exports = "li.selected {\n  background-color: var(--primary);\n  color: #fff;\n}\n\n#myInput {\n  width: 100%;\n  background-position: 10px 12px;\n  background-repeat: no-repeat;\n  border: 1px solid #ddd;\n  margin-bottom: 12px;\n  padding: 12px 20px 12px 40px;\n  font-size: 16px;\n}\n\n#myUL {\n  margin: 0;\n  padding: 0;\n  list-style-type: none;\n}\n\n#myUL li a {\n  color: #000;\n  background-color: #f6f6f6;\n  border: 1px solid #ddd;\n  margin-top: -1px;\n  padding: 12px;\n  font-size: 18px;\n  text-decoration: none;\n  display: block;\n}\n\n#myUL li a:hover:not(.header) {\n  background-color: #eee;\n}\n\n";


class $dfb8aa29da9a55f4$export$c03f8af9dcb6e561 {
    init(list) {
        let children = list.children;
        if (!list.data) list.data = Array.prototype.slice.call(children).filter((el)=>el.classList.contains("juel-item")).map((el)=>el.textContent.trim());
        console.log(list.data);
        list.selected = [];
        list.shadowRoot.querySelectorAll(".item").forEach((el)=>{
            $(el).off("click").on("click", function(event) {
                let slot = el.querySelector("slot").getAttribute("name");
                let item = list.querySelector(`[slot="${slot}"]`);
                if (item) {
                    let value = list.data[parseInt(el.dataset.index)];
                    if (el.classList.contains("selected")) {
                        list.selected = list.selected.filter((val)=>val != value);
                        $(item).find(".juel-appear").hide("slow");
                        let evt = new CustomEvent("deselected", {
                            detail: {
                                index: parseInt(el.dataset.index),
                                value: value
                            }
                        });
                        list.dispatchEvent(evt);
                    } else {
                        if (list.multi) list.selected.push(value);
                        else {
                            list.selected = [
                                value
                            ];
                            $(el).siblings().each(function(index, ele) {
                                ele.classList.remove("selected");
                                let sl = ele.querySelector("slot").getAttribute("name");
                                let itm = list.querySelector(`[slot="${sl}"]`);
                                $(itm).find(".juel-appear").hide("slow");
                            });
                        }
                        $(item).find(".juel-appear").show("slow");
                        let evt = new CustomEvent("selected", {
                            detail: {
                                index: parseInt(el.dataset.index),
                                value: value
                            }
                        });
                        list.dispatchEvent(evt);
                    }
                    el.classList.toggle("selected");
                }
            });
        });
    }
}



var $48a9952e168b5fc7$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $48a9952e168b5fc7$export$ba3591c76cfe5f21 = class JuelList extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.service = new (0, $dfb8aa29da9a55f4$export$c03f8af9dcb6e561)();
    }
    firstUpdated() {
        setTimeout(()=>{
            this.requestUpdate();
        });
    }
    updated() {
        setTimeout(()=>{
            this.service.init(this);
        });
    }
    render() {
        let index = -1;
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="list">
            <div id="selected-placeholder">
            </div>
            <ul id="items-container">
            ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, (ele, i)=>{
            let isHeading = false;
            if (ele.tagName.startsWith("H")) isHeading = true;
            else {
                index++;
                ele.classList.add("juel-item");
                $(ele).find(".juel-appear").hide();
            }
            let id = ele.id ? ele.id : `item-${i}`;
            ele.setAttribute("slot", id);
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                        <li class="${isHeading == true ? `heading` : `item`}" data-index="${index}">
                        <slot name="${id}"></slot>
                        </li>`;
        })}
            </ul>
        </div>`;
    }
};
$48a9952e168b5fc7$export$ba3591c76cfe5f21.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($dd06c83c907a8a20$exports))));
$48a9952e168b5fc7$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $48a9952e168b5fc7$export$ba3591c76cfe5f21.prototype, "data", void 0);
$48a9952e168b5fc7$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $48a9952e168b5fc7$export$ba3591c76cfe5f21.prototype, "multi", void 0);
$48a9952e168b5fc7$export$ba3591c76cfe5f21 = $48a9952e168b5fc7$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-list")
], $48a9952e168b5fc7$export$ba3591c76cfe5f21);


var $243f8b1ed5efb10f$exports = {};




var $03ea70bb900e6232$exports = {};
$03ea70bb900e6232$exports = ":host {\n  display: inline-block;\n  position: relative;\n}\n\n#items {\n  z-index: 100;\n  color: #212529;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  padding: .5rem 0;\n  font-size: 1rem;\n  display: none;\n}\n\n#trigger button {\n  display: flex;\n}\n\n#trigger button:before {\n  width: 1.25em;\n  content: var(--icon-indicator);\n  transform-origin: .5em;\n  line-height: 0;\n  transition: transform .35s;\n}\n\n#trigger.open button:before {\n  transform: rotate(90deg);\n}\n\n";




var $243f8b1ed5efb10f$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $243f8b1ed5efb10f$export$67cd5d4df7dfa10f = class JuelMenu extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.push = (0, $88b1143c261b729c$export$af899be8b8440dd5)();
        this.trigger = "over";
        this.menuShown = false;
        this.triggered = false;
    }
    load() {
        let items = this.shadowRoot.getElementById("items");
        let trigger = $(this.shadowRoot.getElementById("trigger"));
        if (!this.trigger || this.trigger == "over") this.trigger = "mouseover touchstart";
        trigger.off(this.trigger).on(this.trigger, (e)=>{
            if (this.menuShown == false) {
                this.triggered = true;
                trigger.toggleClass("open");
                items.style.display = "inline-block";
                if (this.push == false) this.menu = (0, $ff295692f8fc945a$export$8f7491d57c8f97a9)(trigger[0], items, {
                    placement: $(this).parent("juel-menu").length > 0 ? "right-end" : "bottom"
                });
                this.menuShown = true;
            }
        });
        $([
            items,
            trigger[0]
        ]).off("mousemove").on("mousemove", ()=>{
            if (this.triggered == true) this.menuShown = true;
        }).off("mouseleave").on("mouseleave", (e)=>{
            this.menuShown = false;
            setTimeout(()=>{
                if (this.menuShown == false) {
                    items.style.display = "none";
                    this.menu = null;
                    this.triggered = false;
                }
            }, 1000);
        });
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="container">
            <div id="trigger">
                <slot name="trigger">
                    <button>${this.title}</button>
                </slot>
                <div id="down-arrow"></div>
            </div>
            <div id="items">
            ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, (el, index)=>{
            let id = el.id ? el.id : `item-${index}`;
            el.setAttribute("slot", id);
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                        <div class="item" data-index="${index}">
                        <slot name="${id}"></slot>
                        </div>`;
        }, '[slot="trigger"]')}
            </div>
        </div>`;
    }
};
$243f8b1ed5efb10f$export$67cd5d4df7dfa10f.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($03ea70bb900e6232$exports))));
$243f8b1ed5efb10f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $243f8b1ed5efb10f$export$67cd5d4df7dfa10f.prototype, "push", void 0);
$243f8b1ed5efb10f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $243f8b1ed5efb10f$export$67cd5d4df7dfa10f.prototype, "trigger", void 0);
$243f8b1ed5efb10f$export$67cd5d4df7dfa10f = $243f8b1ed5efb10f$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-menu")
], $243f8b1ed5efb10f$export$67cd5d4df7dfa10f);


var $393090e0a6905930$exports = {};


var $a43879c2b2f28c22$exports = {};
$a43879c2b2f28c22$exports = ":host {\n  display: inline-block;\n}\n\n.switch {\n  width: 60px;\n  height: 34px;\n  display: block;\n  position: relative;\n}\n\n.custom {\n  display: flex;\n}\n\n.switch input, .custom input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n#trigger {\n  width: 100%;\n  height: 100%;\n  z-index: 101;\n  position: absolute;\n  top: 0;\n}\n\n.slider {\n  cursor: pointer;\n  background-color: #ccc;\n  transition: all .4s;\n  position: absolute;\n  inset: 0;\n}\n\n.slider:before {\n  content: \"\";\n  height: 26px;\n  width: 26px;\n  background-color: #fff;\n  transition: all .4s;\n  position: absolute;\n  bottom: 4px;\n  left: 4px;\n}\n\ninput:checked + .slider {\n  background-color: #2196f3;\n}\n\ninput:checked + #trigger {\n  background-color: #2196f3 !important;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #2196f3;\n}\n\ninput:checked + .slider:before {\n  transform: translateX(26px);\n}\n\n.slider.rounded {\n  border-radius: 34px;\n}\n\n.slider.rounded:before {\n  border-radius: 50%;\n}\n\n";




var $6adf22b20ee26ff4$export$4cd5cbfd5005fbe7;
(function(ToggleEvents1) {
    ToggleEvents1["Toggled"] = "toggled";
})($6adf22b20ee26ff4$export$4cd5cbfd5005fbe7 || ($6adf22b20ee26ff4$export$4cd5cbfd5005fbe7 = {}));


var $393090e0a6905930$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $393090e0a6905930$export$10bd69db0a870abd = class JuelToggle extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super(...arguments);
        this.defaultWidth = 60;
        this.defaultHeight = 34;
        this.rounded = false;
        this.singular = false;
        this.contained = false;
        this.container = ".container";
        this.type = null;
        this.content = null;
        this.custom = false;
        this.width = null;
        this.height = null;
        this.checked = false;
    }
    firstUpdated() {
        let trigger = this.shadowRoot.getElementById("trigger");
        if (!this.width) this.style.width = `${this.width}px`;
        else if (trigger) this.style.width = trigger.style.width;
        else this.style.width = `${this.defaultWidth}px`;
        if (!this.height) this.style.height = `${this.height}px`;
        else if (trigger) this.style.height = trigger.style.height;
        else this.style.height = `${this.defaultHeight}px`;
        if (this.checked) {
            this.classList.remove("unchecked");
            this.classList.add("checked");
        } else {
            this.classList.remove("checked");
            this.classList.add("unchecked");
        }
        if (trigger) $(trigger).on("click", ()=>{
            this.toggle();
            if (this.singular == true) this.singularCheck();
        });
    }
    toggle() {
        this.checked = !this.checked;
        let checkbox = this.shadowRoot.getElementById("checkbox");
        checkbox.checked = this.checked;
        if (this.checked) {
            this.classList.remove("unchecked");
            this.classList.add("checked");
        } else {
            this.classList.remove("checked");
            this.classList.add("unchecked");
        }
        let args = {
            value: this.checked
        };
        (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(this, (0, $6adf22b20ee26ff4$export$4cd5cbfd5005fbe7).Toggled, args);
    }
    reset() {
        this.checked = false;
        this.shadowRoot.getElementById("checkbox").checked = false;
    }
    check(index, ele) {
        if (ele.checked) {
            if ((ele.type != null || this.type != null) && ele.type != this.type) return;
            else ele.toggle();
        }
    }
    singularCheck() {
        if (this.contained == false) {
            let siblings = $(this).siblings("juel-toggle");
            siblings.each(this.check.bind(this));
        } else $(this).parentsUntil(this.container).parent().find("juel-toggle").not(this).each(this.check.bind(this));
    }
    checkChange(e) {
        let check = e.target;
        this.checked = check.checked;
        if (this.checked) {
            this.classList.remove("unchecked");
            this.classList.add("checked");
        } else {
            this.classList.remove("checked");
            this.classList.add("unchecked");
        }
        let args = {
            value: this.checked
        };
        (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(this, (0, $6adf22b20ee26ff4$export$4cd5cbfd5005fbe7).Toggled, args);
        this.requestUpdate();
    }
    toggleClicked(e) {
        if (this.singular == true) this.singularCheck();
    }
    render() {
        let contentStrs = null;
        if (this.content && this.content.includes(",")) contentStrs = this.content.split(",");
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<label class="${this.custom ? "custom" : "switch"}" @click="${this.toggleClicked}">
        <input type="checkbox" id="checkbox" @change="${this.checkChange}">
        ${this.custom ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<slot name="${this.checked ? "checked" : "unchecked"}"></slot>` : this.content ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<button id="trigger">${contentStrs ? contentStrs[this.checked ? 1 : 0] : this.content}</button>` : (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<span class="${this.rounded == false ? "slider" : "slider rounded"}"></span>`}
      </label>`;
    }
};
$393090e0a6905930$export$10bd69db0a870abd.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($a43879c2b2f28c22$exports))));
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "rounded", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "singular", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "contained", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "container", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "type", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "content", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "custom", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "width", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "height", void 0);
$393090e0a6905930$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $393090e0a6905930$export$10bd69db0a870abd.prototype, "checked", void 0);
$393090e0a6905930$export$10bd69db0a870abd = $393090e0a6905930$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-toggle")
], $393090e0a6905930$export$10bd69db0a870abd);


var $4c552c6c58db8c5f$exports = {};


var $5809dbd51563ce1e$exports = {};
$5809dbd51563ce1e$exports = ":host {\n  display: inline-block;\n  position: relative;\n}\n\ninput.text {\n  width: 100%;\n}\n\n.input-group {\n  flex-direction: var(--direction, row);\n  background-color: #e9ecef;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  padding: .375rem;\n  display: inline-flex;\n}\n\n.input-group :first-child {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.input-group :last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.addon {\n  background-color: var(--background, var(--primary));\n  border-color: #0a58ca;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n#dropdown-items {\n  z-index: 1000;\n  width: 100%;\n  color: #212529;\n  text-align: left;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  font-size: 1rem;\n  display: none;\n  position: absolute;\n}\n\n::slotted(ul) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 1rem;\n  list-style: none;\n  display: flex;\n}\n\n::slotted(ol) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 0;\n  list-style: none;\n  display: flex;\n}\n\n.btn {\n  position: relative;\n  overflow: hidden;\n}\n\n.btn-group {\n  vertical-align: middle;\n  display: inline-flex;\n  position: relative;\n}\n\n.btn-group > .btn-group:not(:last-child) > button, .btn-group > button:not(:last-child):not(.dropdown) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.btn-group > .btn-group:not(:first-child) > button, .btn-group > button:nth-child(n+3), .btn-group > :not(.btn-check) + button {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\nbutton {\n  color: #212529;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  user-select: none;\n  color: #fff;\n  background-color: #0000;\n  background-color: var(--background, var(--primary));\n  border: 1px solid #0a58ca;\n  border-radius: .25rem;\n  padding: .375rem .75rem;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5;\n  text-decoration: none;\n  transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out;\n  display: inline-block;\n}\n\n";


var $4a92183a680bdf45$exports = {};
$4a92183a680bdf45$exports = "@keyframes ripple {\n  to {\n    opacity: 0;\n    transform: scale(4);\n  }\n}\n\n";


class $9021e13842516968$export$df83e21cb27a0989 {
    constructor(element){
        this.element = element;
        this.removeRipples = (el)=>{
            el.removeEventListener("click", this.createRipple.bind(this));
        };
        element.addEventListener("click", this.createRipple.bind(this));
        let root = element.getRootNode();
        const style = document.createElement("style");
        style.textContent = (0, (/*@__PURE__*/$parcel$interopDefault($4a92183a680bdf45$exports)));
        root.prepend(style);
    }
    createRipple(event) {
        const button = this.element;
        const circle = document.createElement("span");
        const diameter = Math.max(button.clientWidth, button.clientHeight);
        const radius = diameter / 2;
        circle.setAttribute("part", "ripple");
        circle.style.width = circle.style.height = `${diameter}px`;
        circle.style.left = `${event.clientX - button.offsetLeft - radius}px`;
        circle.style.top = `${event.clientY - button.offsetTop - radius}px`;
        circle.classList.add("ripple");
        const ripple = button.getElementsByClassName("ripple")[0];
        if (ripple) ripple.remove();
        button.appendChild(circle);
    }
}


var $87af919838071cce$exports = {};

$parcel$export($87af919838071cce$exports, "InputBase", () => $87af919838071cce$export$36eab7f492831059, (v) => $87af919838071cce$export$36eab7f492831059 = v);
/*!
 * jQuery.tabbable 1.0 - Simple utility for selecting the next / previous ':tabbable' element.
 * https://github.com/marklagendijk/jQuery.tabbable
 *
 * Includes ':tabbable' and ':focusable' selectors from jQuery UI Core
 *
 * Copyright 2013, Mark Lagendijk
 * Released under the MIT license
 *
 */ (function($) {
    "use strict";
    /**
	 * Focusses the next :focusable element. Elements with tabindex=-1 are focusable, but not tabable.
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.focusNext = function() {
        selectNextTabbableOrFocusable(":focusable");
    };
    /**
	 * Focusses the previous :focusable element. Elements with tabindex=-1 are focusable, but not tabable.
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.focusPrev = function() {
        selectPrevTabbableOrFocusable(":focusable");
    };
    /**
	 * Focusses the next :tabable element.
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.tabNext = function() {
        selectNextTabbableOrFocusable(":tabbable");
    };
    /**
	 * Focusses the previous :tabbable element
	 * Does not take into account that the taborder might be different as the :tabbable elements order
	 * (which happens when using tabindexes which are greater than 0).
	 */ $.tabPrev = function() {
        selectPrevTabbableOrFocusable(":tabbable");
    };
    function selectNextTabbableOrFocusable(selector) {
        var selectables = $(selector);
        var current = $(":focus");
        var nextIndex = 0;
        if (current.length === 1) {
            var currentIndex = selectables.index(current);
            if (currentIndex + 1 < selectables.length) nextIndex = currentIndex + 1;
        }
        selectables.eq(nextIndex).focus();
    }
    function selectPrevTabbableOrFocusable(selector) {
        var selectables = $(selector);
        var current = $(":focus");
        var prevIndex = selectables.length - 1;
        if (current.length === 1) {
            var currentIndex = selectables.index(current);
            if (currentIndex > 0) prevIndex = currentIndex - 1;
        }
        selectables.eq(prevIndex).focus();
    }
    /**
	 * :focusable and :tabbable, both taken from jQuery UI Core
	 */ $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : // support: jQuery <1.8
        function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });
    /**
	 * focussable function, taken from jQuery UI Core
	 * @param element
	 * @returns {*}
	 */ function focusable(element1) {
        var map, mapName, img, nodeName = element1.nodeName.toLowerCase(), isTabIndexNotNaN = !isNaN($.attr(element1, "tabindex"));
        if ("area" === nodeName) {
            map = element1.parentNode;
            mapName = map.name;
            if (!element1.href || !mapName || map.nodeName.toLowerCase() !== "map") return false;
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        // Luke: Added extra strings for juel-?
        return (/input|text|memo|radio|select|textarea|button|object/.test(nodeName) ? !element1.disabled : "a" === nodeName ? element1.href || isTabIndexNotNaN : isTabIndexNotNaN) && // the element and all of its ancestors must be visible
        visible(element1);
        function visible(element) {
            return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
                return $.css(this, "visibility") === "hidden";
            }).length;
        }
    }
})(jQuery);







/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const { H: $6e6b2fa8f83f8ac5$var$i  } = (0, $37260750aa7b368d$export$8613d1ca9052b22e), $6e6b2fa8f83f8ac5$export$c3825b437cbdea5c = (o1)=>null === o1 || "object" != typeof o1 && "function" != typeof o1, $6e6b2fa8f83f8ac5$export$80c36ae3cab9881d = {
    HTML: 1,
    SVG: 2
}, $6e6b2fa8f83f8ac5$export$6b6d145ec2a44ca9 = (o2, i1)=>{
    var t1, n1;
    return void 0 === i1 ? void 0 !== (null === (t1 = o2) || void 0 === t1 ? void 0 : t1._$litType$) : (null === (n1 = o2) || void 0 === n1 ? void 0 : n1._$litType$) === i1;
}, $6e6b2fa8f83f8ac5$export$2f448fec17d50a3e = (o3)=>{
    var i2;
    return void 0 !== (null === (i2 = o3) || void 0 === i2 ? void 0 : i2._$litDirective$);
}, $6e6b2fa8f83f8ac5$export$f28e31de6a6eaf32 = (o4)=>{
    var i3;
    return null === (i3 = o4) || void 0 === i3 ? void 0 : i3._$litDirective$;
}, $6e6b2fa8f83f8ac5$export$7f431ad0fff82fd9 = (o5)=>void 0 === o5.strings, $6e6b2fa8f83f8ac5$var$e = ()=>document.createComment(""), $6e6b2fa8f83f8ac5$export$291b2338ad9b0b30 = (o6, t2, n2)=>{
    var v2;
    const l1 = o6._$AA.parentNode, d1 = void 0 === t2 ? o6._$AB : t2._$AA;
    if (void 0 === n2) {
        const t3 = l1.insertBefore($6e6b2fa8f83f8ac5$var$e(), d1), v1 = l1.insertBefore($6e6b2fa8f83f8ac5$var$e(), d1);
        n2 = new $6e6b2fa8f83f8ac5$var$i(t3, v1, o6, o6.options);
    } else {
        const i5 = n2._$AB.nextSibling, t4 = n2._$AM, r1 = t4 !== o6;
        if (r1) {
            let i4;
            null === (v2 = n2._$AQ) || void 0 === v2 || v2.call(n2, o6), n2._$AM = o6, void 0 !== n2._$AP && (i4 = o6._$AU) !== t4._$AU && n2._$AP(i4);
        }
        if (i5 !== d1 || r1) {
            let o7 = n2._$AA;
            for(; o7 !== i5;){
                const i6 = o7.nextSibling;
                l1.insertBefore(o7, d1), o7 = i6;
            }
        }
    }
    return n2;
}, $6e6b2fa8f83f8ac5$export$cb8bf9562088e9f4 = (o8, i7, t5 = o8)=>(o8._$AI(i7, t5), o8), $6e6b2fa8f83f8ac5$var$f = {}, $6e6b2fa8f83f8ac5$export$ea70d9dd5965b1c8 = (o9, i8 = $6e6b2fa8f83f8ac5$var$f)=>o9._$AH = i8, $6e6b2fa8f83f8ac5$export$59e9bce518cde500 = (o10)=>o10._$AH, $6e6b2fa8f83f8ac5$export$3133b3144bbba267 = (o11)=>{
    var i9;
    null === (i9 = o11._$AP) || void 0 === i9 || i9.call(o11, !1, !0);
    let t6 = o11._$AA;
    const n3 = o11._$AB.nextSibling;
    for(; t6 !== n3;){
        const o12 = t6.nextSibling;
        t6.remove(), t6 = o12;
    }
}, $6e6b2fa8f83f8ac5$export$7f600b8138c094dc = (o13)=>{
    o13._$AR();
};




/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $d15107ce26618194$var$e = (i2, t1)=>{
    var s1, o1;
    const n1 = i2._$AN;
    if (void 0 === n1) return !1;
    for (const i1 of n1)null === (o1 = (s1 = i1)._$AO) || void 0 === o1 || o1.call(s1, t1, !1), $d15107ce26618194$var$e(i1, t1);
    return !0;
}, $d15107ce26618194$var$o = (i3)=>{
    let t2, s2;
    do {
        if (void 0 === (t2 = i3._$AM)) break;
        s2 = t2._$AN, s2.delete(i3), i3 = t2;
    }while (0 === (null == s2 ? void 0 : s2.size));
}, $d15107ce26618194$var$n = (i4)=>{
    for(let t3; t3 = i4._$AM; i4 = t3){
        let s3 = t3._$AN;
        if (void 0 === s3) t3._$AN = s3 = new Set;
        else if (s3.has(i4)) break;
        s3.add(i4), $d15107ce26618194$var$l(t3);
    }
};
function $d15107ce26618194$var$r(i5) {
    void 0 !== this._$AN ? ($d15107ce26618194$var$o(this), this._$AM = i5, $d15107ce26618194$var$n(this)) : this._$AM = i5;
}
function $d15107ce26618194$var$h(i7, t4 = !1, s4 = 0) {
    const n2 = this._$AH, r1 = this._$AN;
    if (void 0 !== r1 && 0 !== r1.size) {
        if (t4) {
            if (Array.isArray(n2)) for(let i6 = s4; i6 < n2.length; i6++)$d15107ce26618194$var$e(n2[i6], !1), $d15107ce26618194$var$o(n2[i6]);
            else null != n2 && ($d15107ce26618194$var$e(n2, !1), $d15107ce26618194$var$o(n2));
        } else $d15107ce26618194$var$e(this, i7);
    }
}
const $d15107ce26618194$var$l = (i8)=>{
    var t5, e1, o2, n3;
    i8.type == (0, $782b9679dcaaea44$export$9ba3b3f20a85bfa).CHILD && (null !== (t5 = (o2 = i8)._$AP) && void 0 !== t5 || (o2._$AP = $d15107ce26618194$var$h), null !== (e1 = (n3 = i8)._$AQ) && void 0 !== e1 || (n3._$AQ = $d15107ce26618194$var$r));
};
class $d15107ce26618194$export$7d025501802325e extends (0, $782b9679dcaaea44$export$befdefbdce210f91) {
    constructor(){
        super(...arguments), this._$AN = void 0;
    }
    _$AT(i9, t6, s5) {
        super._$AT(i9, t6, s5), $d15107ce26618194$var$n(this), this.isConnected = i9._$AU;
    }
    _$AO(i10, t7 = !0) {
        var s6, n4;
        i10 !== this.isConnected && (this.isConnected = i10, i10 ? null === (s6 = this.reconnected) || void 0 === s6 || s6.call(this) : null === (n4 = this.disconnected) || void 0 === n4 || n4.call(this)), t7 && ($d15107ce26618194$var$e(this, i10), $d15107ce26618194$var$o(this));
    }
    setValue(t8) {
        if ((0, $6e6b2fa8f83f8ac5$export$7f431ad0fff82fd9)(this._$Ct)) this._$Ct._$AI(t8, this);
        else {
            const i11 = [
                ...this._$Ct._$AH
            ];
            i11[this._$Ci] = t8, this._$Ct._$AI(i11, this, 0);
        }
    }
    disconnected() {}
    reconnected() {}
}



/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $3444fcda03099cf9$export$7d1e3a5e95ceca43 = ()=>new $3444fcda03099cf9$var$o;
class $3444fcda03099cf9$var$o {
}
const $3444fcda03099cf9$var$h = new WeakMap, $3444fcda03099cf9$export$eff4d24c3ff7876e = (0, $782b9679dcaaea44$export$99b43ad1ed32e735)(class extends (0, $d15107ce26618194$export$7d025501802325e) {
    render(t) {
        return 0, $37260750aa7b368d$export$45b790e32b2810ee;
    }
    update(t1, [s1]) {
        var e1;
        const o1 = s1 !== this.U;
        return o1 && void 0 !== this.U && this.ot(void 0), (o1 || this.rt !== this.lt) && (this.U = s1, this.ht = null === (e1 = t1.options) || void 0 === e1 ? void 0 : e1.host, this.ot(this.lt = t1.element)), $37260750aa7b368d$export$45b790e32b2810ee;
    }
    ot(i1) {
        var t2;
        if ("function" == typeof this.U) {
            const s2 = null !== (t2 = this.ht) && void 0 !== t2 ? t2 : globalThis;
            let e2 = $3444fcda03099cf9$var$h.get(s2);
            void 0 === e2 && (e2 = new WeakMap, $3444fcda03099cf9$var$h.set(s2, e2)), void 0 !== e2.get(this.U) && this.U.call(this.ht, void 0), e2.set(this.U, i1), void 0 !== i1 && this.U.call(this.ht, i1);
        } else this.U.value = i1;
    }
    get rt() {
        var i2, t3, s3;
        return "function" == typeof this.U ? null === (t3 = $3444fcda03099cf9$var$h.get(null !== (i2 = this.ht) && void 0 !== i2 ? i2 : globalThis)) || void 0 === t3 ? void 0 : t3.get(this.U) : null === (s3 = this.U) || void 0 === s3 ? void 0 : s3.value;
    }
    disconnected() {
        this.rt === this.lt && this.ot(void 0);
    }
    reconnected() {
        this.ot(this.lt);
    }
});




var $9fc1f110788ce737$exports = {};
"use strict";
Object.defineProperty($9fc1f110788ce737$exports, "__esModule", {
    value: true
});
var $9fc1f110788ce737$var$constants;
(function(constants1) {
    constants1.typeOfFunction = "function";
    constants1.boolTrue = true;
})($9fc1f110788ce737$var$constants || ($9fc1f110788ce737$var$constants = {}));
function $9fc1f110788ce737$var$bind(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== $9fc1f110788ce737$var$constants.typeOfFunction) throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
    return {
        configurable: $9fc1f110788ce737$var$constants.boolTrue,
        get: function() {
            var bound = descriptor.value.bind(this);
            // Credits to https://github.com/andreypopp/autobind-decorator for memoizing the result of bind against a symbol on the instance.
            Object.defineProperty(this, propertyKey, {
                value: bound,
                configurable: $9fc1f110788ce737$var$constants.boolTrue,
                writable: $9fc1f110788ce737$var$constants.boolTrue
            });
            return bound;
        }
    };
}
$9fc1f110788ce737$exports.bind = $9fc1f110788ce737$var$bind;
$9fc1f110788ce737$exports.default = $9fc1f110788ce737$var$bind;


var $87af919838071cce$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class $87af919838071cce$export$36eab7f492831059 extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super(...arguments);
        this.input = (0, $3444fcda03099cf9$export$7d1e3a5e95ceca43)();
        this.dropdownShown = false;
    }
    firstUpdated() {
        this.$this = $(this);
        this.addEventListener("keyup", (e)=>{
            console.log("Up");
            console.log(e);
            if (e.key == "Enter") this.nextOrSubmit();
        });
        if (this.input.value) this.input.value.focus();
    }
    nextOrSubmit() {
        let next = this.$this.nextAll($87af919838071cce$export$36eab7f492831059.InputElementNames);
        if (next.length == 0) {
            let steps = this.closest("juel-steps");
            if (steps) {
                steps.next();
                $.tabNext();
            } else {
                let frm = this.closest("form");
                if (frm && "requestSubmit" in frm) frm.requestSubmit();
                else if (frm) frm.submit();
            }
        } else $.tabNext();
    }
    focus(options) {
        if (this.input.value) this.input.value.focus();
        else super.focus(options);
    }
    onClick(e) {}
    toggleDropdown() {
        var items = this.shadowRoot.querySelector("#dropdown-items");
        if (this.dropdownShown == false) {
            this.dropdown = (0, $ff295692f8fc945a$export$8f7491d57c8f97a9)(this.shadowRoot.querySelector("#dropdown-toggle"), items, {
                placement: "bottom-end"
            });
            items.style.display = "initial";
            this.dropdownShown = true;
        } else {
            this.dropdown.destroy();
            items.style.display = "none";
            this.dropdownShown = false;
        }
    }
}
$87af919838071cce$export$36eab7f492831059.InputElementNames = "juel-text, juel-memo, juel-range, juel-tickbox, juel-radio";
$87af919838071cce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        attribute: "prepend"
    })
], $87af919838071cce$export$36eab7f492831059.prototype, "addBefore", void 0);
$87af919838071cce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $87af919838071cce$export$36eab7f492831059.prototype, "addon", void 0);
$87af919838071cce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $87af919838071cce$export$36eab7f492831059.prototype, "addonActive", void 0);
$87af919838071cce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $87af919838071cce$export$36eab7f492831059.prototype, "label", void 0);
$87af919838071cce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $87af919838071cce$export$36eab7f492831059.prototype, "name", void 0);
$87af919838071cce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $87af919838071cce$export$36eab7f492831059.prototype, "active", void 0);
$87af919838071cce$var$__decorate([
    (0, (/*@__PURE__*/$parcel$interopDefault($9fc1f110788ce737$exports)))
], $87af919838071cce$export$36eab7f492831059.prototype, "nextOrSubmit", null);






/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $e5c00ea60213b8cf$export$f68dd208b5df064d = (l1)=>null != l1 ? l1 : (0, $37260750aa7b368d$export$45b790e32b2810ee);





function $b5f612b565643fa9$export$e2c86a3545f3ce2b(el) {
    return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<button name="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.name)}" ${(0, $3444fcda03099cf9$export$eff4d24c3ff7876e)(el.input)} type="${el.submit ? "submit" : "button"}" part="button" class="btn" part="button" @click="${el.onClick}"><slot name="content">${el.label}</slot></button>`;
}


var $dc4b52ff7b13e73e$export$930c13e962764648;
(function(InputTypes1) {
    InputTypes1[InputTypes1["Button"] = 0] = "Button";
    InputTypes1[InputTypes1["Text"] = 1] = "Text";
    InputTypes1[InputTypes1["Memo"] = 2] = "Memo";
    InputTypes1[InputTypes1["Number"] = 3] = "Number";
    InputTypes1[InputTypes1["Range"] = 4] = "Range";
    InputTypes1[InputTypes1["Tickbox"] = 5] = "Tickbox";
    InputTypes1[InputTypes1["Radio"] = 6] = "Radio";
})($dc4b52ff7b13e73e$export$930c13e962764648 || ($dc4b52ff7b13e73e$export$930c13e962764648 = {}));





function $80c9569cbe5f8124$export$8bbc79aa2dc8500d(el) {
    return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<label name="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.name)}" part="label" for="text"><slot name="content">${el.label}</slot></label><textarea ${(0, $3444fcda03099cf9$export$eff4d24c3ff7876e)(el.input)} .value=${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.value)}></textarea>`;
}





function $676d1b44660c3f35$export$43c51f51f0b06995(el) {
    return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<label name="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.name)}" for="input"><slot name="content">${el.label}</slot></label><input ${(0, $3444fcda03099cf9$export$eff4d24c3ff7876e)(el.input)} id="input" type="range" .value=${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.value)} min="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.min)}" max="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.max)}" step="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.step)}" @change="${el.onChange}">`;
}





function $60a5e4ce075c13f8$export$554cf187947ae74d(el) {
    return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<label name="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.name)}" part="label" for="text"><slot name="content">${el.label}</slot></label><input ${(0, $3444fcda03099cf9$export$eff4d24c3ff7876e)(el.input)} part="input" .value="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.value)}" class="text" @change="${el.onChange}">`;
}





function $f0e8e0f43dc255e6$export$85d8fe04c954eac(el) {
    return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<label name="${(0, $e5c00ea60213b8cf$export$f68dd208b5df064d)(el.name)}" for="input"><slot name="content">${el.label}</slot></label><input ${(0, $3444fcda03099cf9$export$eff4d24c3ff7876e)(el.input)} type="checkbox" .checked="${el.value}" id="input" @change="${el.onChange}">`;
}


function $ad1647a61f7e0cde$export$475a25926aecae05(el, type) {
    let hasAfter = false;
    let isAfterBtn;
    let hasBefore;
    let isBeforeBtn;
    let hasDropdown = false;
    let addon = el.querySelector('[slot="after"]');
    if (addon) hasAfter = true;
    let dropdown = el.querySelector('[slot="dropdown"]');
    if (dropdown) {
        hasAfter = true;
        hasDropdown = true;
    }
    let inputTemplate;
    switch(type){
        case (0, $dc4b52ff7b13e73e$export$930c13e962764648).Button:
            inputTemplate = (0, $b5f612b565643fa9$export$e2c86a3545f3ce2b);
            break;
        case (0, $dc4b52ff7b13e73e$export$930c13e962764648).Text:
            inputTemplate = (0, $60a5e4ce075c13f8$export$554cf187947ae74d);
            break;
        case (0, $dc4b52ff7b13e73e$export$930c13e962764648).Range:
            inputTemplate = (0, $676d1b44660c3f35$export$43c51f51f0b06995);
            break;
        case (0, $dc4b52ff7b13e73e$export$930c13e962764648).Tickbox:
            inputTemplate = (0, $f0e8e0f43dc255e6$export$85d8fe04c954eac);
            break;
        case (0, $dc4b52ff7b13e73e$export$930c13e962764648).Memo:
            inputTemplate = (0, $80c9569cbe5f8124$export$8bbc79aa2dc8500d);
        default:
            break;
    }
    return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`${(0, $381ea5e2aef5c344$export$a55877ca9db47377)(hasAfter, ()=>(0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div part="input-group" class="input-group">
                    ${hasBefore ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div class="addon"><slot name="addon-before"></slot></div>` : ``}
                    ${inputTemplate(el)}
                    ${hasDropdown ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<button id="dropdown-toggle" @click="${el.toggleDropdown}"></button>` : (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div class="addon"><slot name="after"></slot></div>`}
                    ${el.active == true && el.addon && el.addonActive == true ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div class="addon"><slot name="addon-active"></slot></div>` : ``}
                </div>`, ()=>inputTemplate(el))}
                ${hasDropdown ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="dropdown-items" style="display:none"><slot name="dropdown"></slot></div>` : (0, $37260750aa7b368d$export$c0bb0b647f701bb5)``}`;
}



var $b7dfb4ba9ef40c22$export$312c261205d4c8ea;
(function(ButtonEvents1) {
    ButtonEvents1["ButtonClicked"] = "button-clicked";
})($b7dfb4ba9ef40c22$export$312c261205d4c8ea || ($b7dfb4ba9ef40c22$export$312c261205d4c8ea = {}));


var $4c552c6c58db8c5f$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $4c552c6c58db8c5f$export$51a2e5404c8126eb = class JuelButton extends (0, $87af919838071cce$exports.InputBase) {
    constructor(){
        super();
        this.submit = false;
    }
    updated() {
        setTimeout(()=>{
            this.isRipple = getComputedStyle(this).getPropertyValue("--ripple");
            console.log(this.isRipple);
            if (this.isRipple) {
                let btn = this.shadowRoot.firstElementChild;
                this.r = new (0, $9021e13842516968$export$df83e21cb27a0989)(btn);
            }
        });
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    onClick(e) {
        var event = new CustomEvent((0, $b7dfb4ba9ef40c22$export$312c261205d4c8ea).ButtonClicked, {
            detail: e
        });
        this.dispatchEvent(event);
        if (this.submit == true) {
            let frm = this.closest("form");
            if (frm) {
                if ("requestSubmit" in frm) frm.requestSubmit();
                else frm.submit();
            }
        }
    }
    render() {
        return (0, $ad1647a61f7e0cde$export$475a25926aecae05)(this, (0, $dc4b52ff7b13e73e$export$930c13e962764648).Button);
    }
};
$4c552c6c58db8c5f$export$51a2e5404c8126eb.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($5809dbd51563ce1e$exports))));
$4c552c6c58db8c5f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $4c552c6c58db8c5f$export$51a2e5404c8126eb.prototype, "submit", void 0);
$4c552c6c58db8c5f$export$51a2e5404c8126eb = $4c552c6c58db8c5f$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-button")
], $4c552c6c58db8c5f$export$51a2e5404c8126eb);


var $ab5d565f41b21eff$exports = {};


var $184926c371e253fd$exports = {};
$184926c371e253fd$exports = ":host {\n  display: inline-block;\n  position: relative;\n}\n\ninput.text {\n  width: 100%;\n}\n\n.input-group {\n  flex-direction: var(--direction, row);\n  background-color: #e9ecef;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  padding: .375rem;\n  display: inline-flex;\n}\n\n.input-group :first-child {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.input-group :last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.addon {\n  background-color: var(--background, var(--primary));\n  border-color: #0a58ca;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n#dropdown-items {\n  z-index: 1000;\n  width: 100%;\n  color: #212529;\n  text-align: left;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  font-size: 1rem;\n  display: none;\n  position: absolute;\n}\n\n::slotted(ul) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 1rem;\n  list-style: none;\n  display: flex;\n}\n\n::slotted(ol) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 0;\n  list-style: none;\n  display: flex;\n}\n\n";







var $ab5d565f41b21eff$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $ab5d565f41b21eff$export$fba804f6e4c18126 = class JuelText extends (0, $87af919838071cce$exports.InputBase) {
    constructor(){
        super();
        this.dropdownShown = false;
        this.value = "";
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    onChange(e) {
        let el = e.target;
        this.value = el.value;
        let args = {
            value: this.value
        };
        (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(this, (0, $ad5a5e3d85db6c6d$export$3fd36d65bf762270).Changed, args);
    }
    render() {
        return (0, $ad1647a61f7e0cde$export$475a25926aecae05)(this, (0, $dc4b52ff7b13e73e$export$930c13e962764648).Text);
    }
};
$ab5d565f41b21eff$export$fba804f6e4c18126.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($184926c371e253fd$exports))));
$ab5d565f41b21eff$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $ab5d565f41b21eff$export$fba804f6e4c18126.prototype, "value", void 0);
$ab5d565f41b21eff$export$fba804f6e4c18126 = $ab5d565f41b21eff$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-text")
], $ab5d565f41b21eff$export$fba804f6e4c18126);


var $6932e0b34663bc20$exports = {};






var $69afd4f170a211ff$exports = {};
$69afd4f170a211ff$exports = "\n\n";



var $6932e0b34663bc20$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $6932e0b34663bc20$export$6f30dfff741da7ac = class JuelMemo extends (0, $87af919838071cce$exports.InputBase) {
    onChange(e) {
        let el = e.target;
        this.value = el.value;
        let args = {
            value: this.value
        };
        (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(this, (0, $ad5a5e3d85db6c6d$export$3fd36d65bf762270).Changed, args);
    }
    render() {
        return (0, $ad1647a61f7e0cde$export$475a25926aecae05)(this, (0, $dc4b52ff7b13e73e$export$930c13e962764648).Memo);
    }
};
$6932e0b34663bc20$export$6f30dfff741da7ac.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($69afd4f170a211ff$exports))));
$6932e0b34663bc20$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $6932e0b34663bc20$export$6f30dfff741da7ac.prototype, "value", void 0);
$6932e0b34663bc20$export$6f30dfff741da7ac = $6932e0b34663bc20$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-memo")
], $6932e0b34663bc20$export$6f30dfff741da7ac);


var $1057be894a9d7ecc$exports = {};




var $f5a2c6af77c347ab$exports = {};
$f5a2c6af77c347ab$exports = "input[type=\"range\"] {\n  -webkit-appearance: none;\n  width: 100%;\n  background: none;\n}\n\ninput[type=\"range\"]:focus {\n  outline: none;\n}\n\ninput[type=\"range\"]:focus::-webkit-slider-runnable-track {\n  background: var(--secondary);\n}\n\ninput[type=\"range\"]:focus::-ms-fill-upper {\n  background: var(--secondary);\n}\n\ninput[type=\"range\"]:focus::-ms-fill-lower {\n  background: var(--secondary);\n}\n\ninput[type=\"range\"]::-ms-track {\n  width: 100%;\n  cursor: pointer;\n  color: #0000;\n  background: none;\n  border-color: #0000;\n}\n\ninput[type=\"range\"]::-webkit-slider-runnable-track {\n  width: 100%;\n  height: 6px;\n  cursor: pointer;\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 1.3px;\n}\n\ninput[type=\"range\"]::-moz-range-track {\n  width: 100%;\n  height: 6px;\n  cursor: pointer;\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 1.3px;\n}\n\ninput[type=\"range\"]::-ms-track {\n  width: 100%;\n  height: 6px;\n  cursor: pointer;\n  color: #0000;\n  background: none;\n  border-width: 16px 0;\n  border-color: #0000;\n}\n\ninput[type=\"range\"]::-ms-fill-lower {\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 2.6px;\n}\n\ninput[type=\"range\"]::-ms-fill-upper {\n  background: var(--active);\n  border: .2px solid var(--secondary);\n  border-radius: 2.6px;\n}\n\ninput[type=\"range\"]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  height: 24px;\n  width: 24px;\n  background: var(--primary);\n  cursor: pointer;\n  border-radius: 50px;\n  margin-top: -11px;\n}\n\ninput[type=\"range\"]::-moz-range-thumb {\n  height: 24px;\n  width: 24px;\n  background: var(--primary);\n  cursor: pointer;\n  border-radius: 50px;\n}\n\ninput[type=\"range\"]::-ms-thumb {\n  height: 24px;\n  width: 24px;\n  background: var(--primary);\n  cursor: pointer;\n  border-radius: 50px;\n}\n\n";






var $1057be894a9d7ecc$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $1057be894a9d7ecc$export$ec495d047382ba78 = class JuelRange extends (0, $87af919838071cce$exports.InputBase) {
    updated() {
        setTimeout(()=>{
            this.isRipple = getComputedStyle(this).getPropertyValue("--ripple");
            console.log(this.isRipple);
            if (this.isRipple) {
                let btn = this.shadowRoot.firstElementChild;
                this.r = new (0, $9021e13842516968$export$df83e21cb27a0989)(btn);
            }
        });
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    onChange(e) {
        let el = e.target;
        this.value = parseFloat(el.value);
        let args = {
            value: this.value
        };
        (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(this, (0, $ad5a5e3d85db6c6d$export$3fd36d65bf762270).Changed, args);
    }
    render() {
        return (0, $ad1647a61f7e0cde$export$475a25926aecae05)(this, (0, $dc4b52ff7b13e73e$export$930c13e962764648).Range);
    }
};
$1057be894a9d7ecc$export$ec495d047382ba78.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($f5a2c6af77c347ab$exports))));
$1057be894a9d7ecc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $1057be894a9d7ecc$export$ec495d047382ba78.prototype, "value", void 0);
$1057be894a9d7ecc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $1057be894a9d7ecc$export$ec495d047382ba78.prototype, "min", void 0);
$1057be894a9d7ecc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $1057be894a9d7ecc$export$ec495d047382ba78.prototype, "max", void 0);
$1057be894a9d7ecc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $1057be894a9d7ecc$export$ec495d047382ba78.prototype, "step", void 0);
$1057be894a9d7ecc$export$ec495d047382ba78 = $1057be894a9d7ecc$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-range")
], $1057be894a9d7ecc$export$ec495d047382ba78);


var $eec489b14b43f080$exports = {};





var $d657a7e2ba92d216$exports = {};
$d657a7e2ba92d216$exports = ":host {\n  display: inline-block;\n  position: relative;\n}\n\ninput.text {\n  width: 100%;\n}\n\n.input-group {\n  flex-direction: var(--direction, row);\n  background-color: #e9ecef;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  padding: .375rem;\n  display: inline-flex;\n}\n\n.input-group :first-child {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.input-group :last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.addon {\n  background-color: var(--background, var(--primary));\n  border-color: #0a58ca;\n}\n\n#dropdown-toggle:after {\n  vertical-align: .255em;\n  content: \"\";\n  border: .3em solid #0000;\n  border-top-color: currentColor;\n  border-bottom: 0;\n  display: inline-block;\n}\n\n#dropdown-items {\n  z-index: 1000;\n  width: 100%;\n  color: #212529;\n  text-align: left;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #00000026;\n  border-radius: .25rem;\n  margin: 0;\n  font-size: 1rem;\n  display: none;\n  position: absolute;\n}\n\n::slotted(ul) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 1rem;\n  list-style: none;\n  display: flex;\n}\n\n::slotted(ol) {\n  flex-direction: column;\n  margin: 0;\n  padding: .5rem 0;\n  list-style: none;\n  display: flex;\n}\n\n:host {\n  align-items: center;\n  display: flex;\n}\n\ninput {\n  appearance: none;\n  width: 1em;\n  height: 1em;\n  --icon: pink;\n  background-color: var(--primary);\n  width: 40px;\n  height: 40px;\n  border: 1px solid #00000040;\n  border-radius: .25em;\n  margin: 2%;\n  position: relative;\n  box-shadow: inset 0 0 12px #add8e6;\n}\n\ninput:checked:before {\n  content: \"\";\n  width: 8px;\n  height: 50%;\n  transform-origin: 0 100%;\n  z-index: 1;\n  background-color: #7b2d14;\n  border-radius: 2px;\n  position: absolute;\n  top: 50%;\n  transform: translateX(12px)rotate(-45deg);\n}\n\ninput:checked:after {\n  content: \"\";\n  height: 8px;\n  width: 100%;\n  transform-origin: 0 100%;\n  background-color: #c83478;\n  border-radius: 2px;\n  position: absolute;\n  bottom: 0;\n  transform: translateX(12px)rotate(-45deg);\n}\n\n";




var $eec489b14b43f080$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $eec489b14b43f080$export$42658d5387a70c43 = class JuelTickbox extends (0, $87af919838071cce$exports.InputBase) {
    constructor(){
        super();
        this.value = false;
    }
    disconnectedCallback() {
        if (this.isRipple) {
            let btn = this.shadowRoot.firstElementChild;
            this.r.removeRipples(btn);
        }
    }
    setValue(value) {
        this.value = value;
    }
    onChange(e) {
        let el = e.target;
        this.value = el.checked;
        let args = {
            value: this.value
        };
        (0, $38d8c756f0a655d2$export$65fee5f8f91a342f)(this, (0, $ad5a5e3d85db6c6d$export$3fd36d65bf762270).Changed, args);
    }
    render() {
        return (0, $ad1647a61f7e0cde$export$475a25926aecae05)(this, (0, $dc4b52ff7b13e73e$export$930c13e962764648).Tickbox);
    }
};
$eec489b14b43f080$export$42658d5387a70c43.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($d657a7e2ba92d216$exports))));
$eec489b14b43f080$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $eec489b14b43f080$export$42658d5387a70c43.prototype, "value", void 0);
$eec489b14b43f080$export$42658d5387a70c43 = $eec489b14b43f080$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-tickbox")
], $eec489b14b43f080$export$42658d5387a70c43);


var $46279d4813719d0e$exports = {};


var $4259fcdb5ef487bb$exports = {};
$4259fcdb5ef487bb$exports = ".progress-ring__circle {\n  stroke-dasharray: 10 20;\n  stroke: var(--stroke, white);\n  transform-origin: 50%;\n  transition: stroke-dashoffset;\n  transform: rotate(-90deg);\n}\n\n";


var $46279d4813719d0e$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $46279d4813719d0e$export$b5b86cc426fc60e1 = class JuelProgress extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.type = "line";
        this.value = 0;
    }
    updated(_changedProperties) {
        const circle = this.shadowRoot.querySelector(".progress-ring__circle");
        const radius = circle.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        circle.style.strokeDasharray = `${circumference} ${circumference}`;
        circle.style.strokeDashoffset = circumference.toString();
        const offset = circumference - this.value / 100 * circumference;
        circle.style.strokeDashoffset = offset.toString();
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`${this.type == "ring" ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
            <svg class="progress-ring" height="120" width="120">
                <circle class="progress-ring__circle" stroke-width="1" fill="transparent" r="58" cx="60" cy="60"/>
            </svg>` : ``}`;
    }
};
$46279d4813719d0e$export$b5b86cc426fc60e1.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($4259fcdb5ef487bb$exports))));
$46279d4813719d0e$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $46279d4813719d0e$export$b5b86cc426fc60e1.prototype, "type", void 0);
$46279d4813719d0e$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $46279d4813719d0e$export$b5b86cc426fc60e1.prototype, "value", void 0);
$46279d4813719d0e$export$b5b86cc426fc60e1 = $46279d4813719d0e$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-progress")
], $46279d4813719d0e$export$b5b86cc426fc60e1);


var $038e193f9971cdd6$exports = {};


var $50c5a88b691e2d0a$exports = {};
$50c5a88b691e2d0a$exports = ":host {\n  width: 100%;\n  height: 100%;\n}\n\n";


var $038e193f9971cdd6$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var $038e193f9971cdd6$var$JuelEmbed_1;
let $038e193f9971cdd6$export$6fdd3e3b8bc0fa25 = $038e193f9971cdd6$var$JuelEmbed_1 = class JuelEmbed extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
    }
    firstUpdated(_changedProperties) {
        if (this.url) fetch(this.url).then((response)=>{
            var contentType = response.headers.get("content-type");
            if (this.type == "markdown" || /markdown/.test(contentType)) response.text().then((data)=>{
                this.processMarkdown(data);
            }).catch((err)=>{
                console.log(err);
            });
            else response.text().then((data)=>{
                let $data = $(data);
                $(this).append($data);
                this.requestUpdate();
            });
        });
        else if (this.innerHTML) {
            let data = this.innerHTML;
            this.requestUpdate();
            setTimeout(()=>this.processMarkdown(data), 400);
        }
    }
    processMarkdown(content) {
        let script;
        script = document.head.querySelector("#markdown");
        if (!script) {
            script = document.createElement("script");
            script.id = "markdown";
            script.src = $038e193f9971cdd6$var$JuelEmbed_1.UrlMarkdown;
            document.head.append(script);
            script.onload = ()=>$038e193f9971cdd6$var$JuelEmbed_1.markdownFunc(this, content);
        } else setTimeout(()=>$038e193f9971cdd6$var$JuelEmbed_1.markdownFunc(this, content), 400);
    }
    createRenderRoot() {
        return this;
    }
};
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($50c5a88b691e2d0a$exports))));
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25.UrlMarkdown = "https://cdn.jsdelivr.net/npm/marked/marked.min.js";
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25.HlJs = "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js";
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25.HlJsStyles = "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/default.min.css";
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25.HlJsStylesRoot = "https://cdn.jsdelivr.net/npm/highlight.js/styles/";
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25.markdownFunc = (em, content)=>{
    if ("marked" in window) {
        em.innerHTML = marked.parse(content);
        em.requestUpdate();
        if ("hljs" in window) setTimeout(()=>hljs.highlightAll(), 400);
        else {
            let styles = document.createElement("link");
            styles.setAttribute("rel", "stylesheet");
            styles.setAttribute("href", $038e193f9971cdd6$var$JuelEmbed_1.HlJsStyles);
            document.head.append(styles);
            let script = document.createElement("script");
            script.src = $038e193f9971cdd6$var$JuelEmbed_1.HlJs;
            document.head.append(script);
            setTimeout(()=>{
                hljs.highlightAll();
            }, 400);
        }
        if (em.theme) {
            let id = `hljs-theme-${em.theme}`;
            let style = document.head.querySelector(`#${id}`);
            if (!style) {
                style = document.createElement("link");
                style.id = id;
                style.setAttribute("rel", "stylesheet");
                style.setAttribute("href", `${$038e193f9971cdd6$var$JuelEmbed_1.HlJsStylesRoot}${em.theme}.css`);
                document.head.append(style);
            }
        }
    }
};
$038e193f9971cdd6$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $038e193f9971cdd6$export$6fdd3e3b8bc0fa25.prototype, "url", void 0);
$038e193f9971cdd6$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $038e193f9971cdd6$export$6fdd3e3b8bc0fa25.prototype, "selector", void 0);
$038e193f9971cdd6$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $038e193f9971cdd6$export$6fdd3e3b8bc0fa25.prototype, "type", void 0);
$038e193f9971cdd6$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $038e193f9971cdd6$export$6fdd3e3b8bc0fa25.prototype, "theme", void 0);
$038e193f9971cdd6$export$6fdd3e3b8bc0fa25 = $038e193f9971cdd6$var$JuelEmbed_1 = $038e193f9971cdd6$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-embed")
], $038e193f9971cdd6$export$6fdd3e3b8bc0fa25);


var $91c6e8817cac800f$exports = {};


/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $4e4b0f6b795fb5c4$export$7877a478dd30fd3d = (o1, r, n)=>{
    for (const n1 of r)if (n1[0] === o1) return (0, n1[1])();
    return null == n ? void 0 : n();
};





var $2e79bdc1748eccb0$exports = {};
$2e79bdc1748eccb0$exports = ":host {\n  display: inline-block;\n}\n\nvideo {\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n}\n\n";


var $91c6e8817cac800f$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $91c6e8817cac800f$export$40f6dde1b57ef1b = class JuelRandom extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.elementRef = (0, $3444fcda03099cf9$export$7d1e3a5e95ceca43)();
        this.type = "img";
        this.trigger = "load";
    }
    firstUpdated() {
        if (this.values) switch(this.trigger){
            case "load":
                this.setValue();
                break;
            default:
                let interval;
                if (this.trigger.endsWith("s")) interval = parseFloat(this.trigger.replace("s", "")) * 1000;
                if (interval) setInterval(()=>{
                    this.setValue();
                }, interval);
                break;
        }
    }
    setValue() {
        let splitty = this.values.split(" ");
        this.value = splitty[Math.floor(Math.random() * splitty.length)];
    }
    updated() {
        if (this.elementRef.value) {
            let el = this.elementRef.value;
            el.load();
            if (el.hasAttribute("autoplay")) el.play();
        }
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`${(0, $4e4b0f6b795fb5c4$export$7877a478dd30fd3d)(this.type, [
            [
                "img",
                ()=>(0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<img src="${this.value}" />`
            ],
            [
                "video",
                ()=>(0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<video ${(0, $3444fcda03099cf9$export$eff4d24c3ff7876e)(this.elementRef)} autoplay loop muted><source src="${this.value}"></video>`
            ]
        ])}`;
    }
};
$91c6e8817cac800f$export$40f6dde1b57ef1b.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($2e79bdc1748eccb0$exports))));
$91c6e8817cac800f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $91c6e8817cac800f$export$40f6dde1b57ef1b.prototype, "type", void 0);
$91c6e8817cac800f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $91c6e8817cac800f$export$40f6dde1b57ef1b.prototype, "values", void 0);
$91c6e8817cac800f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $91c6e8817cac800f$export$40f6dde1b57ef1b.prototype, "trigger", void 0);
$91c6e8817cac800f$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $91c6e8817cac800f$export$40f6dde1b57ef1b.prototype, "value", void 0);
$91c6e8817cac800f$export$40f6dde1b57ef1b = $91c6e8817cac800f$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-random")
], $91c6e8817cac800f$export$40f6dde1b57ef1b);


var $bd59f7747c7753c3$exports = {};



var $1bb86427827bf7d2$exports = {};
$1bb86427827bf7d2$exports = ":host {\n  width: 100%;\n  height: 100px;\n  background-color: var(--background-colour);\n  margin-bottom: 10px;\n  display: block;\n}\n\nnav {\n  align-items: baseline;\n  justify-content: var(--justify, flex-start);\n  padding-left: var(--padding-left);\n  padding-right: var(--padding-right);\n  background-color: var(--background-colour);\n  flex-flow: wrap;\n  display: flex;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n\n@media screen and (max-width: 500px) {\n  nav {\n    padding-left: initial;\n    padding-right: initial;\n    background-color: #0000;\n    flex-direction: column;\n    justify-content: flex-start;\n    bottom: 0;\n  }\n\n  nav div {\n    flex-grow: .1;\n  }\n}\n\nnav.open #items {\n  flex: 1;\n}\n\nnav.open span:nth-child(1) {\n  transform: translateY(5px)rotate(45deg);\n}\n\nnav.open span:nth-child(2) {\n  opacity: 0;\n}\n\nnav.open span:nth-child(3) {\n  transform: translateY(-5px)rotate(-45deg);\n}\n\nnav.open #items.side.left, nav.open #items.side.right {\n  flex: 1;\n}\n\n@media screen and (max-width: 500px) {\n  nav.open #items.side {\n    max-height: calc(100 * var(--vh) );\n  }\n}\n\nnav .title {\n  white-space: nowrap;\n  margin-right: 1rem;\n  padding-top: .3125rem;\n  padding-bottom: .3125rem;\n  font-size: 1.25rem;\n  text-decoration: none;\n}\n\nnav .title * {\n  display: inline-block;\n}\n\n@media screen and (max-width: 500px) {\n  nav .title {\n    margin-right: initial;\n    flex-direction: column;\n  }\n}\n\nnav #items {\n  align-items: baseline;\n  display: flex;\n  overflow: visible;\n}\n\nnav #items.side.left {\n  order: -1;\n}\n\nnav #items.side.right {\n  order: 1;\n}\n\n@media screen and (max-width: 500px) {\n  nav #items {\n    width: 100%;\n    flex-direction: column;\n    flex: 0;\n    transition: flex 1.5s;\n    overflow-y: auto;\n    order: 1 !important;\n  }\n}\n\nnav .item {\n  flex-shrink: 1;\n  flex-basis: 0;\n  padding-left: .75rem;\n  padding-right: .75rem;\n  display: block;\n}\n\nnav .addon ::slotted(*) {\n  display: flex;\n}\n\n#toggle {\n  width: 32px;\n  height: 64px;\n  cursor: pointer;\n  color: #0000008c;\n  background-color: #0000;\n  border: 1px solid #0000;\n  border-radius: .25rem;\n  padding: .25rem .75rem;\n  font-size: 1.25rem;\n  line-height: 1;\n  transition: box-shadow .15s ease-in-out;\n  display: none;\n  position: relative;\n}\n\n@media screen and (max-width: 500px) {\n  #toggle {\n    display: inline-block;\n  }\n\n  #toggle + #items.side {\n    position: relative;\n  }\n\n  #toggle + #items.side.open + #items.side {\n    max-height: calc(100 * var(--vh) );\n  }\n}\n\n@media screen and (max-width: 500px) {\n  #toggle {\n    display: inline-block;\n  }\n}\n\n#toggle span {\n  height: 1px;\n  transform-origin: center;\n  width: 16px;\n  background-color: currentColor;\n  transition-property: background-color, opacity, transform;\n  transition-duration: 86ms;\n  transition-timing-function: ease-out;\n  display: block;\n  position: absolute;\n  left: calc(50% - 8px);\n}\n\n#toggle span:nth-child(1) {\n  top: calc(50% - 6px);\n}\n\n#toggle span:nth-child(2) {\n  top: calc(50% - 1px);\n}\n\n#toggle span:nth-child(3) {\n  top: calc(50% + 4px);\n}\n\n";


var $bd59f7747c7753c3$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $bd59f7747c7753c3$export$130cc09143467b11 = class JuelNav extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super(...arguments);
        this.toggle = false;
        this.sticky = false;
    }
    firstUpdated() {
        setTimeout(()=>{
            this.requestUpdate();
            setTimeout(()=>{
                if (this.sticky == true && !window.isMobile) {
                    let nav = this.shadowRoot.querySelector("nav");
                    let title = nav.querySelector(".title");
                    var navOffset = nav.offsetTop;
                    window.addEventListener("scroll", ()=>{
                        if (window.pageYOffset >= navOffset + 10) {
                            nav.classList.add("sticky");
                            title.setAttribute("part", "title-sticky");
                        } else {
                            nav.classList.remove("sticky");
                            title.setAttribute("part", "title");
                        }
                    });
                }
            });
        });
    }
    toggleClick(e) {
        e.stopImmediatePropagation();
        let el = this.shadowRoot.getElementById("nav");
        el.classList.toggle("open");
        if (el.classList.contains("open")) {
            if (this.push) {
                let css = {};
                css["transition"] = "margin 2s";
                $(this.push).css(css);
            }
        } else if (this.push) {
            let css = {};
            $(this.push).css(css);
        }
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
            <nav id="nav">
            <div part="title" class="title">
                <slot name="title">
                    <h1>${this.title}</h1>
                </slot>
                <div id="toggle" class="${this.toggle == true ? "shown" : ""}" @click="${this.toggleClick}">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div id="items" part="items" class="${this.side ? `side ${this.side}` : ""}">
            ${(0, $57c09562a6d0b30e$export$eec70cb3a42440b6)(this, (el, index)=>{
            if (el.getAttribute("slot") != "title") {
                let id = el.id ? el.id : `item-${index}`;
                el.setAttribute("slot", id);
                let klass = "item";
                if (this.selected && this.selected == index) klass += " selected";
                return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                    <div class="${klass}" data-index="${index}">
                    <slot name="${id}"></slot>
                    </div>`;
            } else return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)``;
        }, '[slot="title"],[slot="addon"]')}
            </div>
            <div class="addon">
            <slot name="addon"></slot>
            </div>
            </nav>
        `;
    }
};
$bd59f7747c7753c3$export$130cc09143467b11.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($1bb86427827bf7d2$exports))));
$bd59f7747c7753c3$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $bd59f7747c7753c3$export$130cc09143467b11.prototype, "toggle", void 0);
$bd59f7747c7753c3$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $bd59f7747c7753c3$export$130cc09143467b11.prototype, "sticky", void 0);
$bd59f7747c7753c3$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $bd59f7747c7753c3$export$130cc09143467b11.prototype, "side", void 0);
$bd59f7747c7753c3$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $bd59f7747c7753c3$export$130cc09143467b11.prototype, "push", void 0);
$bd59f7747c7753c3$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $bd59f7747c7753c3$export$130cc09143467b11.prototype, "selected", void 0);
$bd59f7747c7753c3$export$130cc09143467b11 = $bd59f7747c7753c3$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-nav")
], $bd59f7747c7753c3$export$130cc09143467b11);


var $c55dd34de669419a$exports = {};


var $c55dd34de669419a$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $c55dd34de669419a$export$febfb6857279d236 = class JuelChart extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.width = 400;
        this.height = 400;
        this.type = "bar";
    }
    updated() {
        setTimeout(()=>{
            if ("Chart" in window) {
                let data = this.getData();
                let plugins = {};
                if (this.legend) {
                    if (this.legend == "false") plugins.legend = {
                        display: false
                    };
                    else plugins.legend = {
                        position: this.legend
                    };
                }
                if (this.title) plugins.title = {
                    display: true,
                    text: this.title
                };
                let options = {
                    responsive: this.responsive
                };
                if (this.indexAxis) options.indexAxis = this.indexAxis;
                if (plugins) options.plugins = plugins;
                let config = {
                    type: this.type,
                    data: data,
                    options: options
                };
                console.log(config);
                let ChartFunc = window["Chart"];
                this.chart = new ChartFunc(this.g, config);
            }
        });
    }
    getData() {
        if (this.data) return this.data;
        else {
            let el = this.shadowRoot.getElementById("data").firstElementChild;
            let els = el.assignedNodes();
            this.data = JSON.parse(els[0].nodeValue);
            this.g = this.shadowRoot.getElementById("canvas").getContext("2d");
            return this.data;
        }
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="data" style="display:none"><slot></slot></div><canvas id="canvas" width="${this.width}" height="${this.height}""></canvas>`;
    }
};
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $c55dd34de669419a$export$febfb6857279d236.prototype, "width", void 0);
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $c55dd34de669419a$export$febfb6857279d236.prototype, "height", void 0);
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $c55dd34de669419a$export$febfb6857279d236.prototype, "type", void 0);
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $c55dd34de669419a$export$febfb6857279d236.prototype, "responsive", void 0);
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $c55dd34de669419a$export$febfb6857279d236.prototype, "legend", void 0);
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $c55dd34de669419a$export$febfb6857279d236.prototype, "indexAxis", void 0);
$c55dd34de669419a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Object
    })
], $c55dd34de669419a$export$febfb6857279d236.prototype, "data", void 0);
$c55dd34de669419a$export$febfb6857279d236 = $c55dd34de669419a$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-chart")
], $c55dd34de669419a$export$febfb6857279d236);


var $a07cb1618cfe9f54$exports = {};


function $e3511083b6aa5502$export$9a227cb43a2634b6(event) {
    var target = $(event.target);
    var x = (parseFloat(target.data("x")) || 0) + event.dx;
    var y = (parseFloat(target.data("y")) || 0) + event.dy;
    target.css("transform", `translate(${x}px, ${y}px)`);
    target.data("x", x);
    target.data("y", y);
}


var $e502f94477649964$export$668f6b29ff2ac480 = /(\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/g;



var $kgJzb = parcelRequire("kgJzb");

var $a07cb1618cfe9f54$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $a07cb1618cfe9f54$export$f8c33909bcff7bef = class DraggableContainer extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        if (!("interact" in window)) window["interact"] = (0, $kgJzb.default);
    }
    firstLoad() {
        let html1 = this.innerHTML;
        html1 = html1.replaceAll((0, $e502f94477649964$export$668f6b29ff2ac480), "<div>$1</div>");
        this.innerHTML = html1;
        (0, $kgJzb.default)("juel-draggable *").draggable({
            listeners: {
                move: (0, $e3511083b6aa5502$export$9a227cb43a2634b6)
            }
        });
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div>
            <slot></slot>
        <div>`;
    }
};
$a07cb1618cfe9f54$export$f8c33909bcff7bef = $a07cb1618cfe9f54$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-draggable")
], $a07cb1618cfe9f54$export$f8c33909bcff7bef);


var $ae75015d85995f89$exports = {};


var $ae75015d85995f89$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $ae75015d85995f89$export$8ccb0244cca250d5 = class JuelImagePreload extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.type = "all";
    }
    firstUpdated() {
        if (this.type == "css" || this.type == "all") {
            let regex = /(?<=url\()[\w:/._\-%]+(?=\);?)/g;
            let styles = Array.prototype.slice.call(document.head.getElementsByTagName("style"));
            styles = styles.concat(Array.prototype.slice.call(document.body.getElementsByTagName("style")));
            styles = styles.filter((el)=>el.id != "juel-styles");
            for (let el1 of styles){
                let res = el1.textContent.match(regex);
                if (res) res.forEach((match)=>{
                    let img = new Image();
                    img.src = match;
                });
            }
        }
        if (this.type == "element" || this.type == "all") {
            let els = Array.prototype.slice.call(document.body.getElementsByTagName("img"));
            for (let el of els){
                let img = new Image();
                img.src = el.src;
            }
        }
    }
    createRenderRoot() {
        return this;
    }
};
$ae75015d85995f89$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $ae75015d85995f89$export$8ccb0244cca250d5.prototype, "type", void 0);
$ae75015d85995f89$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $ae75015d85995f89$export$8ccb0244cca250d5.prototype, "exclude", void 0);
$ae75015d85995f89$export$8ccb0244cca250d5 = $ae75015d85995f89$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-image-preload")
], $ae75015d85995f89$export$8ccb0244cca250d5);


var $2f16785359de0764$exports = {};


var $84c3bb5a78de2051$exports = {};
$84c3bb5a78de2051$exports = "#icon-container {\n  text-align: center;\n  margin: 0 auto;\n  position: absolute;\n  top: 50%;\n  left: 0;\n  right: 0;\n  transform: translateY(-50%);\n}\n\n#icon-container a {\n  filter: progid:DXImageTransform. Microsoft. gradient(startColorstr= \"#c054ff\", endColorstr= \"#5274ff\", GradientType= 0);\n  width: 60px;\n  height: 60px;\n  color: #fff;\n  text-align: center;\n  background: linear-gradient(#c054ff 0%, #5274ff 100%);\n  border-radius: 50%;\n  line-height: 60px;\n  display: inline-block;\n  position: relative;\n}\n\n#icon-container a:before {\n  content: \"\";\n  border-radius: inherit;\n  border: 1px solid #fff;\n  animation: btnIconRipple 2s cubic-bezier(.23, 1, .32, 1) infinite both;\n  display: inline-block;\n  position: absolute;\n  inset: -2px;\n}\n\n#icon-container a:after {\n  content: \"\";\n  z-index: 0;\n  background: none;\n  border: 70px solid #404dff1a;\n  border-radius: 50%;\n  position: absolute;\n  top: -38px;\n  left: -39px;\n  right: 0;\n}\n\n@keyframes btnIconRipple {\n  0% {\n    border-width: 4px;\n    transform: scale(1);\n  }\n\n  50% {\n    border-width: 1px;\n    transform: scale(1.5);\n  }\n\n  80% {\n    border-width: 1px;\n    transform: scale(1.9);\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n\n#lightbox-container {\n  z-index: 1000000000;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(#1e1e1ee6, #000 1810%);\n  flex-direction: column;\n  align-items: center;\n  font-family: Arial, sans-serif;\n  display: none;\n  position: fixed;\n  top: 0;\n  left: 0;\n}\n\n#lightbox-nav {\n  color: #fff;\n}\n\n:host {\n  display: inline-block;\n}\n\n#container {\n  display: inline-block;\n  position: relative;\n}\n\n#content {\n  position: relative;\n}\n\n#tabs, #tabs li {\n  display: inline-block;\n}\n\n#previous {\n  z-index: 1;\n  width: 15%;\n  color: #fff;\n  text-align: center;\n  opacity: .5;\n  background: none;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n}\n\n#previous span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-previous);\n}\n\n#next {\n  z-index: 1;\n  width: 15%;\n  color: #fff;\n  text-align: center;\n  opacity: .5;\n  background: none;\n  border: 0;\n  justify-content: center;\n  align-items: center;\n  padding: 0;\n  transition: opacity .15s;\n  display: flex;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n\n#next span {\n  width: 2rem;\n  height: 2rem;\n  background-image: var(--icon-next);\n}\n\njuel-scroll-pane {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n\n#close {\n  height: 100%;\n  width: 45px;\n  cursor: pointer;\n  color: #fff;\n  background-image: var(--icon-close);\n}\n\n";



var $3780284b9c615308$export$26f7310e1c83589c;
(function(ExternalMediaModule1) {
    ExternalMediaModule1.youtube = {
        regexp: /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/,
        link: "https://youtube.com",
        linkText: "YouTube",
        template: (info)=>{
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<iframe width="560" height="315" src="https://www.youtube.com/embed/${info.id}" title="YouTube video player" frameborder="0" allowfullscreen></iframe>`;
        }
    };
})($3780284b9c615308$export$26f7310e1c83589c || ($3780284b9c615308$export$26f7310e1c83589c = {}));



var $2f16785359de0764$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $2f16785359de0764$export$a621b5cc906c547f = class JuelLightbox extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.type = "image";
        this.icon = false;
        this.open = false;
        this.sources = [];
        this.content = [];
        this.position = 0;
    }
    firstLoad() {
        this.sp = this.shadowRoot.querySelector("juel-scroll-pane");
        var elements = Array.prototype.slice.call(document.querySelectorAll("[data-lightbox], [data-lightbox-src"));
        for (var el of elements){
            el.addEventListener("click", (e)=>{
                this.toggle(e);
            });
            if (el.hasAttribute("data-lightbox-src")) this.sources.push(el.dataset.lightboxSrc);
            else if (el.hasAttribute("src")) this.sources.push(el.getAttribute("src"));
        }
        this.requestUpdate();
        this.sp.requestUpdate();
    }
    load() {
        $(this.sp).off("scroll").on("scroll", (e)=>{
            console.log(e.detail);
            this.position = e.detail.index;
            this.requestUpdate();
        });
    }
    toggle(e) {
        e.stopPropagation();
        let lightboxContainer = this.shadowRoot.querySelector("#lightbox-container");
        if (this.open == true) {
            lightboxContainer.style.display = "none";
            this.open = false;
        } else {
            lightboxContainer.style.display = "flex";
            this.open = true;
        }
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
            <div id="preview-container" @click="${this.toggle}">
                ${this.icon == true ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="icon-container">
                            <a><slot name="icon"><slot></a>
                        </div>` : ``}
                <img src="${this.preview}" />
            </div>
            <div id="lightbox-container" @click="${this.toggle}"> 
                <div id="lightbox-nav">
                    <span>${this.position + 1} / ${this.sources.length}</span>
                    <div id="close" @click="${this.toggle}"></div>
                </div>
                <juel-scroll-pane id="lightbox-context" controls="true">
                    ${this.sources.map((src, index)=>{
            if (src.includes("youtu.be")) {
                var match = src.match((0, $3780284b9c615308$export$26f7310e1c83589c).youtube.regexp);
                if (match && match[2].length == 11) return (0, $3780284b9c615308$export$26f7310e1c83589c).youtube.template({
                    id: match[2]
                });
                return ``;
            } else return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<img src="${src}">`;
        })}
                </juel-scroll-pane>
            </div>
        `;
    }
};
$2f16785359de0764$export$a621b5cc906c547f.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($84c3bb5a78de2051$exports))));
$2f16785359de0764$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $2f16785359de0764$export$a621b5cc906c547f.prototype, "type", void 0);
$2f16785359de0764$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $2f16785359de0764$export$a621b5cc906c547f.prototype, "icon", void 0);
$2f16785359de0764$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $2f16785359de0764$export$a621b5cc906c547f.prototype, "preview", void 0);
$2f16785359de0764$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $2f16785359de0764$export$a621b5cc906c547f.prototype, "position", void 0);
$2f16785359de0764$export$a621b5cc906c547f = $2f16785359de0764$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-lightbox")
], $2f16785359de0764$export$a621b5cc906c547f);


var $3ff51d680d103cc6$exports = {};


var $cc28cbb97c4320bd$exports = {};
$cc28cbb97c4320bd$exports = "* {\n  height: 100%;\n}\n\n.container {\n  width: 300px;\n  height: 200px;\n  perspective: 1000px;\n  background-color: #0000;\n  border: 1px solid #f1f1f1;\n}\n\n#inner {\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  transform-style: preserve-3d;\n  transition: transform .8s;\n  position: relative;\n}\n\n#inner .front, #inner .back {\n  width: 100%;\n  height: 100%;\n  backface-visibility: hidden;\n}\n\n#inner.flip:not(.vertical) {\n  transform: rotateY(180deg);\n}\n\n#inner.flip.vertical, #inner.vertical .back {\n  transform: rotateX(180deg);\n}\n\n.front {\n  position: relative;\n}\n\n.back {\n  background: #fff;\n  position: absolute;\n  top: 0;\n  transform: rotateY(180deg);\n}\n\n::slotted(*) {\n  width: 100%;\n  height: 100%;\n}\n\n";



var $3ff51d680d103cc6$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $3ff51d680d103cc6$export$770775f877e377e2 = class JuelFlip extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.vertical = false;
        this.trigger = "click";
    }
    init() {
        let evtName;
        switch(this.trigger){
            case "click":
                evtName = "click";
                break;
            case "hover":
                evtName = "mouseenter";
                break;
        }
        $(this.shadowRoot.getElementById("container")).off().on(evtName, ()=>{
            let el = this.shadowRoot.getElementById("inner");
            if (this.vertical) el.classList.add("vertical");
            el.classList.toggle("flip");
        });
    }
    firstLoad() {
        this.init();
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)` <div id="container">
        <div id="inner">
          <div class="front" part="front">
            <slot name="front"></front>>
          </div>
          <div class="back" part="back">
            <slot name="back"></slot>
          </div>
        </div>
      </div> `;
    }
};
$3ff51d680d103cc6$export$770775f877e377e2.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($cc28cbb97c4320bd$exports))));
$3ff51d680d103cc6$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Boolean
    })
], $3ff51d680d103cc6$export$770775f877e377e2.prototype, "vertical", void 0);
$3ff51d680d103cc6$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $3ff51d680d103cc6$export$770775f877e377e2.prototype, "trigger", void 0);
$3ff51d680d103cc6$export$770775f877e377e2 = $3ff51d680d103cc6$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-flip")
], $3ff51d680d103cc6$export$770775f877e377e2);


var $b3c5609f1a35a9fc$exports = {};


var $9f65bbb2d775f32d$exports = {};
"use strict";
var $9f65bbb2d775f32d$var$classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
};
/**
 * Created by Sergiu andor (micku7zu) on 1/27/2017.
 * Original idea: https://github.com/gijsroge/tilt.js
 * MIT License.
 * Version 1.7.2
 */ var $9f65bbb2d775f32d$var$VanillaTilt = function() {
    function VanillaTilt1(element) {
        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        $9f65bbb2d775f32d$var$classCallCheck(this, VanillaTilt1);
        if (!(element instanceof Node)) throw "Can't initialize VanillaTilt because " + element + " is not a Node.";
        this.width = null;
        this.height = null;
        this.clientWidth = null;
        this.clientHeight = null;
        this.left = null;
        this.top = null;
        // for Gyroscope sampling
        this.gammazero = null;
        this.betazero = null;
        this.lastgammazero = null;
        this.lastbetazero = null;
        this.transitionTimeout = null;
        this.updateCall = null;
        this.event = null;
        this.updateBind = this.update.bind(this);
        this.resetBind = this.reset.bind(this);
        this.element = element;
        this.settings = this.extendSettings(settings);
        this.reverse = this.settings.reverse ? -1 : 1;
        this.glare = VanillaTilt1.isSettingTrue(this.settings.glare);
        this.glarePrerender = VanillaTilt1.isSettingTrue(this.settings["glare-prerender"]);
        this.fullPageListening = VanillaTilt1.isSettingTrue(this.settings["full-page-listening"]);
        this.gyroscope = VanillaTilt1.isSettingTrue(this.settings.gyroscope);
        this.gyroscopeSamples = this.settings.gyroscopeSamples;
        this.elementListener = this.getElementListener();
        if (this.glare) this.prepareGlare();
        if (this.fullPageListening) this.updateClientSize();
        this.addEventListeners();
        this.reset();
        this.updateInitialPosition();
    }
    VanillaTilt1.isSettingTrue = function isSettingTrue(setting) {
        return setting === "" || setting === true || setting === 1;
    };
    /**
   * Method returns element what will be listen mouse events
   * @return {Node}
   */ VanillaTilt1.prototype.getElementListener = function getElementListener() {
        if (this.fullPageListening) return window.document;
        if (typeof this.settings["mouse-event-element"] === "string") {
            var mouseEventElement = document.querySelector(this.settings["mouse-event-element"]);
            if (mouseEventElement) return mouseEventElement;
        }
        if (this.settings["mouse-event-element"] instanceof Node) return this.settings["mouse-event-element"];
        return this.element;
    };
    /**
   * Method set listen methods for this.elementListener
   * @return {Node}
   */ VanillaTilt1.prototype.addEventListeners = function addEventListeners() {
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseMoveBind = this.onMouseMove.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.onWindowResizeBind = this.onWindowResize.bind(this);
        this.onDeviceOrientationBind = this.onDeviceOrientation.bind(this);
        this.elementListener.addEventListener("mouseenter", this.onMouseEnterBind);
        this.elementListener.addEventListener("mouseleave", this.onMouseLeaveBind);
        this.elementListener.addEventListener("mousemove", this.onMouseMoveBind);
        if (this.glare || this.fullPageListening) window.addEventListener("resize", this.onWindowResizeBind);
        if (this.gyroscope) window.addEventListener("deviceorientation", this.onDeviceOrientationBind);
    };
    /**
   * Method remove event listeners from current this.elementListener
   */ VanillaTilt1.prototype.removeEventListeners = function removeEventListeners() {
        this.elementListener.removeEventListener("mouseenter", this.onMouseEnterBind);
        this.elementListener.removeEventListener("mouseleave", this.onMouseLeaveBind);
        this.elementListener.removeEventListener("mousemove", this.onMouseMoveBind);
        if (this.gyroscope) window.removeEventListener("deviceorientation", this.onDeviceOrientationBind);
        if (this.glare || this.fullPageListening) window.removeEventListener("resize", this.onWindowResizeBind);
    };
    VanillaTilt1.prototype.destroy = function destroy() {
        clearTimeout(this.transitionTimeout);
        if (this.updateCall !== null) cancelAnimationFrame(this.updateCall);
        this.reset();
        this.removeEventListeners();
        this.element.vanillaTilt = null;
        delete this.element.vanillaTilt;
        this.element = null;
    };
    VanillaTilt1.prototype.onDeviceOrientation = function onDeviceOrientation(event) {
        if (event.gamma === null || event.beta === null) return;
        this.updateElementPosition();
        if (this.gyroscopeSamples > 0) {
            this.lastgammazero = this.gammazero;
            this.lastbetazero = this.betazero;
            if (this.gammazero === null) {
                this.gammazero = event.gamma;
                this.betazero = event.beta;
            } else {
                this.gammazero = (event.gamma + this.lastgammazero) / 2;
                this.betazero = (event.beta + this.lastbetazero) / 2;
            }
            this.gyroscopeSamples -= 1;
        }
        var totalAngleX = this.settings.gyroscopeMaxAngleX - this.settings.gyroscopeMinAngleX;
        var totalAngleY = this.settings.gyroscopeMaxAngleY - this.settings.gyroscopeMinAngleY;
        var degreesPerPixelX = totalAngleX / this.width;
        var degreesPerPixelY = totalAngleY / this.height;
        var angleX = event.gamma - (this.settings.gyroscopeMinAngleX + this.gammazero);
        var angleY = event.beta - (this.settings.gyroscopeMinAngleY + this.betazero);
        var posX = angleX / degreesPerPixelX;
        var posY = angleY / degreesPerPixelY;
        if (this.updateCall !== null) cancelAnimationFrame(this.updateCall);
        this.event = {
            clientX: posX + this.left,
            clientY: posY + this.top
        };
        this.updateCall = requestAnimationFrame(this.updateBind);
    };
    VanillaTilt1.prototype.onMouseEnter = function onMouseEnter() {
        this.updateElementPosition();
        this.element.style.willChange = "transform";
        this.setTransition();
    };
    VanillaTilt1.prototype.onMouseMove = function onMouseMove(event) {
        if (this.updateCall !== null) cancelAnimationFrame(this.updateCall);
        this.event = event;
        this.updateCall = requestAnimationFrame(this.updateBind);
    };
    VanillaTilt1.prototype.onMouseLeave = function onMouseLeave() {
        this.setTransition();
        if (this.settings.reset) requestAnimationFrame(this.resetBind);
    };
    VanillaTilt1.prototype.reset = function reset() {
        this.event = {
            clientX: this.left + this.width / 2,
            clientY: this.top + this.height / 2
        };
        if (this.element && this.element.style) this.element.style.transform = "perspective(" + this.settings.perspective + "px) " + "rotateX(0deg) " + "rotateY(0deg) " + "scale3d(1, 1, 1)";
        this.resetGlare();
    };
    VanillaTilt1.prototype.resetGlare = function resetGlare() {
        if (this.glare) {
            this.glareElement.style.transform = "rotate(180deg) translate(-50%, -50%)";
            this.glareElement.style.opacity = "0";
        }
    };
    VanillaTilt1.prototype.updateInitialPosition = function updateInitialPosition() {
        if (this.settings.startX === 0 && this.settings.startY === 0) return;
        this.onMouseEnter();
        if (this.fullPageListening) this.event = {
            clientX: (this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.clientWidth,
            clientY: (this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.clientHeight
        };
        else this.event = {
            clientX: this.left + (this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.width,
            clientY: this.top + (this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.height
        };
        var backupScale = this.settings.scale;
        this.settings.scale = 1;
        this.update();
        this.settings.scale = backupScale;
        this.resetGlare();
    };
    VanillaTilt1.prototype.getValues = function getValues() {
        var x = void 0, y = void 0;
        if (this.fullPageListening) {
            x = this.event.clientX / this.clientWidth;
            y = this.event.clientY / this.clientHeight;
        } else {
            x = (this.event.clientX - this.left) / this.width;
            y = (this.event.clientY - this.top) / this.height;
        }
        x = Math.min(Math.max(x, 0), 1);
        y = Math.min(Math.max(y, 0), 1);
        var tiltX = (this.reverse * (this.settings.max - x * this.settings.max * 2)).toFixed(2);
        var tiltY = (this.reverse * (y * this.settings.max * 2 - this.settings.max)).toFixed(2);
        var angle = Math.atan2(this.event.clientX - (this.left + this.width / 2), -(this.event.clientY - (this.top + this.height / 2))) * (180 / Math.PI);
        return {
            tiltX: tiltX,
            tiltY: tiltY,
            percentageX: x * 100,
            percentageY: y * 100,
            angle: angle
        };
    };
    VanillaTilt1.prototype.updateElementPosition = function updateElementPosition() {
        var rect = this.element.getBoundingClientRect();
        this.width = this.element.offsetWidth;
        this.height = this.element.offsetHeight;
        this.left = rect.left;
        this.top = rect.top;
    };
    VanillaTilt1.prototype.update = function update() {
        var values = this.getValues();
        this.element.style.transform = "perspective(" + this.settings.perspective + "px) " + "rotateX(" + (this.settings.axis === "x" ? 0 : values.tiltY) + "deg) " + "rotateY(" + (this.settings.axis === "y" ? 0 : values.tiltX) + "deg) " + "scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")";
        if (this.glare) {
            this.glareElement.style.transform = "rotate(" + values.angle + "deg) translate(-50%, -50%)";
            this.glareElement.style.opacity = "" + values.percentageY * this.settings["max-glare"] / 100;
        }
        this.element.dispatchEvent(new CustomEvent("tiltChange", {
            "detail": values
        }));
        this.updateCall = null;
    };
    /**
   * Appends the glare element (if glarePrerender equals false)
   * and sets the default style
   */ VanillaTilt1.prototype.prepareGlare = function prepareGlare() {
        // If option pre-render is enabled we assume all html/css is present for an optimal glare effect.
        if (!this.glarePrerender) {
            // Create glare element
            var jsTiltGlare = document.createElement("div");
            jsTiltGlare.classList.add("js-tilt-glare");
            var jsTiltGlareInner = document.createElement("div");
            jsTiltGlareInner.classList.add("js-tilt-glare-inner");
            jsTiltGlare.appendChild(jsTiltGlareInner);
            this.element.appendChild(jsTiltGlare);
        }
        this.glareElementWrapper = this.element.querySelector(".js-tilt-glare");
        this.glareElement = this.element.querySelector(".js-tilt-glare-inner");
        if (this.glarePrerender) return;
        Object.assign(this.glareElementWrapper.style, {
            "position": "absolute",
            "top": "0",
            "left": "0",
            "width": "100%",
            "height": "100%",
            "overflow": "hidden",
            "pointer-events": "none"
        });
        Object.assign(this.glareElement.style, {
            "position": "absolute",
            "top": "50%",
            "left": "50%",
            "pointer-events": "none",
            "background-image": "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)",
            "transform": "rotate(180deg) translate(-50%, -50%)",
            "transform-origin": "0% 0%",
            "opacity": "0"
        });
        this.updateGlareSize();
    };
    VanillaTilt1.prototype.updateGlareSize = function updateGlareSize() {
        if (this.glare) {
            var glareSize = (this.element.offsetWidth > this.element.offsetHeight ? this.element.offsetWidth : this.element.offsetHeight) * 2;
            Object.assign(this.glareElement.style, {
                "width": glareSize + "px",
                "height": glareSize + "px"
            });
        }
    };
    VanillaTilt1.prototype.updateClientSize = function updateClientSize() {
        this.clientWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        this.clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    };
    VanillaTilt1.prototype.onWindowResize = function onWindowResize() {
        this.updateGlareSize();
        this.updateClientSize();
    };
    VanillaTilt1.prototype.setTransition = function setTransition() {
        var _this = this;
        clearTimeout(this.transitionTimeout);
        this.element.style.transition = this.settings.speed + "ms " + this.settings.easing;
        if (this.glare) this.glareElement.style.transition = "opacity " + this.settings.speed + "ms " + this.settings.easing;
        this.transitionTimeout = setTimeout(function() {
            _this.element.style.transition = "";
            if (_this.glare) _this.glareElement.style.transition = "";
        }, this.settings.speed);
    };
    /**
   * Method return patched settings of instance
   * @param {boolean} settings.reverse - reverse the tilt direction
   * @param {number} settings.max - max tilt rotation (degrees)
   * @param {startX} settings.startX - the starting tilt on the X axis, in degrees. Default: 0
   * @param {startY} settings.startY - the starting tilt on the Y axis, in degrees. Default: 0
   * @param {number} settings.perspective - Transform perspective, the lower the more extreme the tilt gets
   * @param {string} settings.easing - Easing on enter/exit
   * @param {number} settings.scale - 2 = 200%, 1.5 = 150%, etc..
   * @param {number} settings.speed - Speed of the enter/exit transition
   * @param {boolean} settings.transition - Set a transition on enter/exit
   * @param {string|null} settings.axis - What axis should be disabled. Can be X or Y
   * @param {boolean} settings.glare - What axis should be disabled. Can be X or Y
   * @param {number} settings.max-glare - the maximum "glare" opacity (1 = 100%, 0.5 = 50%)
   * @param {boolean} settings.glare-prerender - false = VanillaTilt creates the glare elements for you, otherwise
   * @param {boolean} settings.full-page-listening - If true, parallax effect will listen to mouse move events on the whole document, not only the selected element
   * @param {string|object} settings.mouse-event-element - String selector or link to HTML-element what will be listen mouse events
   * @param {boolean} settings.reset - false = If the tilt effect has to be reset on exit
   * @param {gyroscope} settings.gyroscope - Enable tilting by deviceorientation events
   * @param {gyroscopeSensitivity} settings.gyroscopeSensitivity - Between 0 and 1 - The angle at which max tilt position is reached. 1 = 90deg, 0.5 = 45deg, etc..
   * @param {gyroscopeSamples} settings.gyroscopeSamples - How many gyroscope moves to decide the starting position.
   */ VanillaTilt1.prototype.extendSettings = function extendSettings(settings) {
        var defaultSettings = {
            reverse: false,
            max: 15,
            startX: 0,
            startY: 0,
            perspective: 1000,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: 1,
            speed: 300,
            transition: true,
            axis: null,
            glare: false,
            "max-glare": 1,
            "glare-prerender": false,
            "full-page-listening": false,
            "mouse-event-element": null,
            reset: true,
            gyroscope: true,
            gyroscopeMinAngleX: -45,
            gyroscopeMaxAngleX: 45,
            gyroscopeMinAngleY: -45,
            gyroscopeMaxAngleY: 45,
            gyroscopeSamples: 10
        };
        var newSettings = {};
        for(var property in defaultSettings){
            if (property in settings) newSettings[property] = settings[property];
            else if (this.element.hasAttribute("data-tilt-" + property)) {
                var attribute = this.element.getAttribute("data-tilt-" + property);
                try {
                    newSettings[property] = JSON.parse(attribute);
                } catch (e) {
                    newSettings[property] = attribute;
                }
            } else newSettings[property] = defaultSettings[property];
        }
        return newSettings;
    };
    VanillaTilt1.init = function init(elements, settings) {
        if (elements instanceof Node) elements = [
            elements
        ];
        if (elements instanceof NodeList) elements = [].slice.call(elements);
        if (!(elements instanceof Array)) return;
        elements.forEach(function(element) {
            if (!("vanillaTilt" in element)) element.vanillaTilt = new VanillaTilt1(element, settings);
        });
    };
    return VanillaTilt1;
}();
if (typeof document !== "undefined") {
    /* expose the class to window */ window.VanillaTilt = $9f65bbb2d775f32d$var$VanillaTilt;
    /**
   * Auto load
   */ $9f65bbb2d775f32d$var$VanillaTilt.init(document.querySelectorAll("[data-tilt]"));
}
$9f65bbb2d775f32d$exports = $9f65bbb2d775f32d$var$VanillaTilt;


var $6cb4ed00c6823062$exports = {};
$6cb4ed00c6823062$exports = ":host {\n  display: inline-flex;\n  position: relative;\n}\n\n";



var $b3c5609f1a35a9fc$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $b3c5609f1a35a9fc$export$18ef6d7c4b996651 = class JuelTilt extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super(...arguments);
        this.perspective = 250;
    }
    firstLoad() {
        let el = this.shadowRoot.getElementById("tilt");
        (0, (/*@__PURE__*/$parcel$interopDefault($9f65bbb2d775f32d$exports))).init(el, {
            perspective: this.perspective
        });
        if (this.childElementCount > 1) el.style.transformStyle = "preserve-3d";
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<div id="tilt">
            <slot></slot>
        </div>`;
    }
};
$b3c5609f1a35a9fc$export$18ef6d7c4b996651.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($6cb4ed00c6823062$exports))));
$b3c5609f1a35a9fc$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $b3c5609f1a35a9fc$export$18ef6d7c4b996651.prototype, "perspective", void 0);
$b3c5609f1a35a9fc$export$18ef6d7c4b996651 = $b3c5609f1a35a9fc$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-tilt")
], $b3c5609f1a35a9fc$export$18ef6d7c4b996651);


var $d99092614941c881$exports = {};



function $ece0a5810ae2e6bf$export$f647ff1e6108fc22(elem, selector, filter) {
    var siblings = [];
    elem = elem.nextElementSibling;
    while(elem){
        if (elem.matches(selector)) break;
        if (filter && !elem.matches(filter)) {
            elem = elem.nextElementSibling;
            continue;
        }
        siblings.push(elem);
        elem = elem.nextElementSibling;
    }
    return siblings;
}


var $d99092614941c881$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $d99092614941c881$export$fd5608fd81737ac = class JuelContents extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    populateContents() {
        this.contents = [];
        var h1s = document.querySelectorAll("h1");
        for (let h1 of h1s){
            let item = {
                id: h1.id,
                title: h1.textContent
            };
            let h2s = (0, $ece0a5810ae2e6bf$export$f647ff1e6108fc22)(h1, `h1`, `h2`);
            for (let h2 of h2s)this.populateChildren(h2, 2, item);
            this.contents.push(item);
        }
    }
    populateChildren(heading, level, item) {
        let child = {
            id: heading.id,
            title: heading.textContent
        };
        let childHeadings = (0, $ece0a5810ae2e6bf$export$f647ff1e6108fc22)(heading, `h${level}`, `h${level + 1}`);
        for (let h of childHeadings)this.populateChildren(h, level + 1, child);
        if (!item.children) item.children = [
            child
        ];
        else item.children.push(child);
    }
    firstUpdated() {
        setTimeout(()=>{
            this.populateContents();
            this.requestUpdate();
        });
    }
    renderContentsItem(item) {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<li>
            <a href="#${item.id}">${item.title}</a>
            ${item.children ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<ul>
                    ${item.children.map(this.renderContentsItem)}
                </ul>` : ""}
        </li>`;
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
            <ul id="toc">
                ${this.contents ? this.contents.map(this.renderContentsItem) : ""}
            </ul>
        `;
    }
};
$d99092614941c881$var$__decorate([
    (0, (/*@__PURE__*/$parcel$interopDefault($9fc1f110788ce737$exports)))
], $d99092614941c881$export$fd5608fd81737ac.prototype, "renderContentsItem", null);
$d99092614941c881$export$fd5608fd81737ac = $d99092614941c881$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-contents")
], $d99092614941c881$export$fd5608fd81737ac);


var $cdb24e412cec7d79$exports = {};



function $a073a184d3e52a18$export$f6089544e0fe0b13(templateString, data) {
    return new Function("html", "return html`" + templateString + "`;").call(data, (0, $37260750aa7b368d$export$c0bb0b647f701bb5));
}


var $cdb24e412cec7d79$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $cdb24e412cec7d79$export$c59a34fa9683e6aa = class JuelTemplate extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`${this.context ? (0, $a073a184d3e52a18$export$f6089544e0fe0b13)(this.innerHTML, this.context) : ""}`;
    }
};
$cdb24e412cec7d79$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $cdb24e412cec7d79$export$c59a34fa9683e6aa.prototype, "context", void 0);
$cdb24e412cec7d79$export$c59a34fa9683e6aa = $cdb24e412cec7d79$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-template")
], $cdb24e412cec7d79$export$c59a34fa9683e6aa);


var $b3849b5a0a82fe66$exports = {};


class $902c4372c93e9393$export$c926439f63623f31 {
    constructor(ele){
        this.voiceIndex = 0;
        this.ele = ele;
        this.voiceChangeHandler = this.voiceChangeHandler.bind(this);
        this.volumeChangeHandler = this.volumeChangeHandler.bind(this);
        this.rateChangeHandler = this.rateChangeHandler.bind(this);
        this.pitchChangeHandler = this.pitchChangeHandler.bind(this);
    }
    getVoices() {
        this.voices = window.speechSynthesis.getVoices();
    }
    voiceChangeHandler(e) {
        this.voiceIndex = e.target.value;
    }
    volumeChangeHandler(e) {
        this.volume = e.target.value;
    }
    rateChangeHandler(e) {
        this.rate = e.target.value;
    }
    pitchChangeHandler(e) {
        this.pitch = e.target.value;
    }
    initExternalControl() {
        let con = $(this.ele.controls);
        con.find('[data-control="voice"]').each((index, element)=>{
            let options = this.voices.map((v, voiceIndex)=>{
                let opt = document.createElement("option");
                opt.value = voiceIndex.toString();
                opt.text = `${v.name} (${v.lang})`;
                return opt;
            });
            $(element).append(options);
        }).change(this.voiceChangeHandler).on("selectmenuchange", this.voiceChangeHandler);
        con.find('[data-control="volume"]').on("slidechange", (e, ui)=>{
            e.target.value = ui.value;
            this.volumeChangeHandler(e);
        });
        con.find('[data-control="rate"]').on("slidechange", (e, ui)=>{
            e.target.value = ui.value;
            this.rateChangeHandler(e);
        });
        con.find('[data-control="pitch"]').on("slidechange", (e, ui)=>{
            e.target.value = ui.value / 100;
            this.pitchChangeHandler(e);
        });
    }
    init() {
        let $ele = $(this.ele);
        if (this.ele.controls != "true" && this.ele.controls != "false") this.initExternalControl();
        $(this.ele.shadowRoot).find(".trigger").click((e)=>{
            let text = $ele.find('[slot="content"').text();
            let udder = new SpeechSynthesisUtterance(text);
            if (this.voices) udder.voice = this.voices[this.voiceIndex];
            if (this.volume) udder.volume = this.volume;
            if (this.rate) udder.rate = this.rate;
            if (this.pitch) udder.pitch = this.pitch;
            window.speechSynthesis.speak(udder);
        });
    }
}


var $87095252ed887ac0$exports = {};
$87095252ed887ac0$exports = ":host {\n  --trigger-font-size: 2em;\n}\n\n.trigger {\n  cursor: pointer;\n  font-size: var(--trigger-font-size);\n}\n\nspan.control {\n  display: inline-grid;\n}\n\n";


var $b3849b5a0a82fe66$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $b3849b5a0a82fe66$export$a9c64d4e42cb769c = class SpeechSection extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.pitchLabel = "Pitch";
        this.rateLabel = "Rate";
        this.voiceLabel = "Voice";
        this.volumeLabel = "Volume";
        this.controlPitch = false;
        this.controlRate = false;
        this.controlVolume = false;
        this.service = new (0, $902c4372c93e9393$export$c926439f63623f31)(this);
        this.service.getVoices();
    }
    firstUpdated() {
        this.service.init();
        this.service.volume = this.volume;
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
        <div class="header">
            <div class="trigger"><slot name="trigger"></slot></div>
            ${this.controls == "true" ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                    <span class="control">
                        <label for="voice">${this.voiceLabel}</label>
                        <select id="voice" @change="${this.service.voiceChangeHandler}">
                            ${this.service.voices.map((v, i)=>(0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<option value="${i}">${v.name} (${v.lang})</option>`)}
                        </select>
                    </span>
                    ${this.controlVolume ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                        <span class="control">
                            <label for="volume">${this.volumeLabel}</label>
                            <input type="range" id="volume" name="volume"
                                value="1" min="0" max="1" step=".01" @change="${this.service.volumeChangeHandler}">
                        </span>` : ""}
                    ${this.controlRate ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                            <span class="control">
                                <label for="rate">${this.rateLabel}</label>
                                <input type="range" id="rate"
                                    value="1" min="0" max="1" step=".01" @change="${this.service.rateChangeHandler}">
                            </span>` : ""}
                    ${this.controlPitch ? (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
                            <span class="control">
                                <label for="pitch">${this.pitchLabel}</label>
                                <input type="range" id="pitch"
                                    value="1" min="0" max="1" step=".01" @change="${this.service.pitchChangeHandler}">
                            </span>` : ""}
                    ` : ""}
        </div>
        <div class="content"><slot name="content"></slot></div>`;
    }
};
$b3849b5a0a82fe66$export$a9c64d4e42cb769c.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($87095252ed887ac0$exports))));
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "lang", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "pitch", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "pitchLabel", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "rate", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "rateLabel", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "voice", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "voiceLabel", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "volume", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "volumeLabel", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "controls", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "controlPitch", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "controlRate", void 0);
$b3849b5a0a82fe66$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c.prototype, "controlVolume", void 0);
$b3849b5a0a82fe66$export$a9c64d4e42cb769c = $b3849b5a0a82fe66$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("speech-section")
], $b3849b5a0a82fe66$export$a9c64d4e42cb769c);


var $039e051edbcb40ce$exports = {};


const $5731d812273396e7$var$caption_class = ".caption";
class $5731d812273396e7$export$8100df246d13b588 {
    constructor(ele){
        this.ele = ele;
    }
    close(ele) {
        let w = this.ele.closeWidth;
        let h = this.ele.closeHeight;
        if (ele[0]) ele[0].style.transform = "scale(1)";
        ele.removeClass("open");
        ele.children($5731d812273396e7$var$caption_class).css({
            display: "none"
        });
    }
    open(ele, scale, displayCaption) {
        let w = this.ele.openWidth;
        let h = this.ele.openHeight;
        let caption = ele.children($5731d812273396e7$var$caption_class);
        if (ele[0] && displayCaption && caption.length > 0) ele[0].style.transform = `scale(${scale}) translate(0, -${caption.height() / 2}px)`;
        else if (ele[0]) ele[0].style.transform = `scale(${scale})`;
        if (scale >= 1) {
            ele.addClass("open");
            if (displayCaption) ele.children($5731d812273396e7$var$caption_class).css({
                display: "block",
                top: -(h * scale / 2)
            });
        } else ele.addClass("lui-fisheye-part");
    }
    init() {
        $(this.ele).children().each((index, element)=>{
            let $this = $(element);
            var title = $this.find($5731d812273396e7$var$caption_class);
            let w = this.ele.style.getPropertyValue("--closeWidth");
            let h = this.ele.style.getPropertyValue("--closeHeight");
            title.css({
                display: "none"
            });
            $this.hover(()=>{
                this.open($this.prev(), 2);
                this.open($this, 3, true);
                this.open($this.next(), 2);
            }, ()=>{
                this.close($this.prev());
                this.close($this);
                this.close($this.next());
            });
        });
    }
}


var $7540d147bb71b7b9$exports = {};
$7540d147bb71b7b9$exports = ":host * {\n  text-align: center;\n}\n\n";



var $039e051edbcb40ce$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $039e051edbcb40ce$export$a299f63d80ba04f = class FishEye extends (0, $5e0a45860ddebf78$exports.JuelComponent) {
    constructor(){
        super();
        this.service = new (0, $5731d812273396e7$export$8100df246d13b588)(this);
    }
    firstLoad() {
        this.service.init();
    }
    createRenderRoot() {
        return this;
    }
};
$039e051edbcb40ce$export$a299f63d80ba04f.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($7540d147bb71b7b9$exports))));
$039e051edbcb40ce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $039e051edbcb40ce$export$a299f63d80ba04f.prototype, "closeWidth", void 0);
$039e051edbcb40ce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $039e051edbcb40ce$export$a299f63d80ba04f.prototype, "closeHeight", void 0);
$039e051edbcb40ce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $039e051edbcb40ce$export$a299f63d80ba04f.prototype, "openWidth", void 0);
$039e051edbcb40ce$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $039e051edbcb40ce$export$a299f63d80ba04f.prototype, "openHeight", void 0);
$039e051edbcb40ce$export$a299f63d80ba04f = $039e051edbcb40ce$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("fish-eye")
], $039e051edbcb40ce$export$a299f63d80ba04f);


var $e575c7eff917e4c2$exports = {};


class $5eae388e80fb9760$export$72d58a6e16efa33 {
    constructor(ele){
        this.changeDirection = false;
        this.dirCase = 1;
        this.patternPoints = [];
        this.ele = ele;
    }
    bindElementEvents(index, ele, pos) {
        ele.bind("mouseenter", (e)=>{
            let $this = $(e.target);
            event.stopPropagation();
            this.closeFollowing($this);
            pos = {
                x: $this.offset().left,
                y: $this.offset().top
            };
            if (this.ele.type != "all" && this.ele.type != "all-cascade") this.showNextElement(index, $this, pos);
        }).bind("mouseleave", function(e) {
            let $this = $(this);
            if (index == 0) {
                if ($this.nextAll(".open").length < 1) $this.removeClass("open").hide();
            } else if ($this.prevAll(".open").length < 1) $this.removeClass("open").hide();
        });
    }
    closeFollowing(ele) {
        ele.nextAll(".open").removeClass("open").hide();
    }
    closeOpenSiblings(listItem) {
        listItem.siblings().removeClass("open").each(function(index, element) {
            $(element).children().slice(1).removeClass("open").hide();
        });
    }
    closeOpenChildren(listItem) {
        listItem.children(".open").removeClass("open").hide();
    }
    showElement(index, ele, pos) {
        var pre = ele.prev();
        ele.css({
            left: pos.x,
            top: pos.y,
            zIndex: parseInt(pre.css("zIndex")) - 1
        }).unbind("mouseenter mouseleave");
        pos.x += this.patternPoints[index].x;
        pos.y += this.patternPoints[index].y;
        ele.stop().show().animate({
            left: pos.x,
            top: pos.y
        }, this.ele.duration, ()=>{
            this.bindElementEvents(index, ele, pos);
        }).addClass("open");
    }
    showNextElement(index, ele, pos) {
        var next = ele.next();
        if (next.length > 0) this.showElement(index + 1, next, pos);
    }
    showAllCascade(index, ele, pos) {
        var pre = ele.prev();
        var x = pre.position().left;
        var y = pre.position().top;
        ele.css({
            left: pos.x,
            top: pos.y,
            zIndex: pre.css("zIndex") - 1
        });
        pos.x += this.patternPoints[index].x;
        pos.y += this.patternPoints[index].y;
        ele.stop().show().animate({
            left: pos.x,
            top: pos.y
        }, this.ele.duration, ()=>{
            var next = ele.next();
            if (next.length > 0) this.showAllCascade(index + 1, next, pos);
        }).addClass("open");
    }
    createPatternPositions(index, pre) {
        switch(this.ele.pattern){
            case "zigzag":
                if (pre && index != 0 && index % this.ele.span == 0) {
                    this.patternPoints[index] = {
                        x: pre.width(),
                        y: 0
                    };
                    this.changeDirection = !this.changeDirection;
                } else if (pre) {
                    if (!this.changeDirection) this.patternPoints[index] = {
                        x: 0,
                        y: pre.height()
                    };
                    else this.patternPoints[index] = {
                        x: 0,
                        y: -pre.height()
                    };
                }
                break;
            case "square":
                if (index != 0) {
                    switch(this.dirCase){
                        case 1:
                            this.patternPoints[index] = {
                                x: pre.width(),
                                y: 0
                            };
                            break;
                        case 2:
                            this.patternPoints[index] = {
                                x: 0,
                                y: -pre.height()
                            };
                            break;
                        case 3:
                            this.patternPoints[index] = {
                                x: -pre.width(),
                                y: 0
                            };
                            break;
                        case 4:
                            this.patternPoints[index] = {
                                x: 0,
                                y: pre.height()
                            };
                            break;
                    }
                    if ((index + 1) % this.patternCount == 0) {
                        this.dirCase++;
                        if (this.dirCase == 2 || this.dirCase == 4) this.patternCount++;
                        if (this.dirCase > 4) this.dirCase = 1;
                    }
                } else this.patternPoints[index] = {
                    x: 0,
                    y: pre.height()
                };
                break;
        }
    }
    init() {
        let $ele = $(this.ele);
        $ele.children().each((index1, element)=>{
            var listItem = $(element);
            var pos = {
                x: listItem.position().left,
                y: listItem.position().top + listItem.height() + 4
            };
            if (this.ele.pattern == "square" && !this.patternCount) this.patternCount = 1;
            listItem.children().first().css({
                position: "relative",
                zIndex: 100,
                width: this.ele.width,
                height: this.ele.height
            });
            listItem.children().slice(1).css({
                position: "absolute",
                width: this.ele.width,
                height: this.ele.height
            }).hide();
            listItem.children().slice(1).each((index, child)=>{
                this.createPatternPositions(index, $(child).prev());
            });
            listItem.bind("mouseenter", ()=>{
                if (listItem.children().slice(1).hasClass("open")) listItem.children().removeClass("open").slice(1).hide();
                else {
                    pos = {
                        x: listItem.offset().left,
                        y: listItem.offset().top
                    };
                    this.closeOpenSiblings(listItem);
                    this.closeOpenChildren(listItem);
                    if (this.ele.type == "all") listItem.children().slice(1).each((index, child)=>{
                        this.showElement(index, $(child), pos);
                    });
                    else if (this.ele.type == "all-cascade") listItem.children().first().each((index, child)=>{
                        var next = $(child).next();
                        if (next.length > 0) this.showAllCascade(index, next, pos);
                    });
                    else if (this.ele.type == "cascade") listItem.children().slice(1).each((index, child)=>{
                        if (index == 0) this.showElement(index, $(child), pos);
                    });
                    listItem.addClass("open");
                }
            });
            listItem.bind("mouseleave", function() {
                if (!listItem.children().slice(1).hasClass("open")) listItem.children().removeClass("open").slice(1).hide();
            });
        });
    }
}


var $e575c7eff917e4c2$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $e575c7eff917e4c2$export$d2ca168f660d53d2 = class BoxMenu extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.slice = 1;
        this.span = 2;
        this.width = 100;
        this.height = 100;
        this.type = "cascade";
        this.pattern = "zigzag";
        this.duration = "fast";
        this.direction = "right";
        this.service = new (0, $5eae388e80fb9760$export$72d58a6e16efa33)(this);
    }
    firstUpdated() {
        this.service.init();
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<slot></slot>`;
    }
};
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "slice", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "span", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "width", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "height", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "type", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "pattern", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "duration", void 0);
$e575c7eff917e4c2$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)()
], $e575c7eff917e4c2$export$d2ca168f660d53d2.prototype, "direction", void 0);
$e575c7eff917e4c2$export$d2ca168f660d53d2 = $e575c7eff917e4c2$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("box-menu")
], $e575c7eff917e4c2$export$d2ca168f660d53d2);


var $ea0819ddf412b59a$exports = {};


function $3df9fe8bd8bcdc7c$export$636b3443dac3eaf9(start, stop, step) {
    return Array.from({
        length: (stop - start) / step + 1
    }, (_, i)=>start + i * step);
}


var $4d9dd558b601a400$exports = {};
$4d9dd558b601a400$exports = ":host {\n  display: inline-flex;\n}\n\n#container {\n  height: 100px;\n  overflow: hidden;\n}\n\n#items h1 {\n  height: 100px;\n  margin: 0;\n  font-size: 64px;\n}\n\n";



var $736ca119f3df4efc$export$cdbe365d8c7d477d;
(function(MathUtil1) {
    function clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }
    MathUtil1.clamp = clamp;
})($736ca119f3df4efc$export$cdbe365d8c7d477d || ($736ca119f3df4efc$export$cdbe365d8c7d477d = {}));


var $ea0819ddf412b59a$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let $ea0819ddf412b59a$export$7dec0544e22d70df = class JuelSpinner extends (0, $69a66af8deb391ea$export$3f2f9f5909897157) {
    constructor(){
        super();
        this.value = "0";
        this.min = 0;
        this.max = 10;
        this.step = 1;
        this.pos = 0;
        if (!("Hammer" in window)) window["Hammer"] = (0, (/*@__PURE__*/$parcel$interopDefault($285a58c52cac528e$exports)));
    }
    setTransition(el) {
        el.style.transition = "margin .73s";
    }
    firstUpdated() {
        let items = this.shadowRoot.getElementById("items");
        let mc = new (0, (/*@__PURE__*/$parcel$interopDefault($285a58c52cac528e$exports)))(this.shadowRoot.getElementById("container"));
        mc.get("pan").set({
            direction: (0, (/*@__PURE__*/$parcel$interopDefault($285a58c52cac528e$exports))).DIRECTION_VERTICAL
        });
        mc.on("pan", (e)=>{
            let margin = (0, $736ca119f3df4efc$export$cdbe365d8c7d477d).clamp(this.pos + e.deltaY * -1, -((items.childElementCount - 1) * 100 + 50), 50);
            items.style.marginTop = `${margin}px`;
            items.style.transition = null;
        });
        mc.on("panend", (e)=>{
            this.pos = (0, $736ca119f3df4efc$export$cdbe365d8c7d477d).clamp(this.pos + Math.round(e.deltaY * -1 / 100) * 100, -((items.childElementCount - 1) * 100), 0);
            items.style.marginTop = `${this.pos}px`;
            this.setTransition(items);
            let index = this.pos < 0 ? this.pos / -100 : 0;
            let ray = this.items ? this.items : (0, $3df9fe8bd8bcdc7c$export$636b3443dac3eaf9)(this.min, this.max, this.step);
            this.value = ray[index];
        });
    }
    increase() {
        let items = this.shadowRoot.getElementById("items");
        this.pos = (0, $736ca119f3df4efc$export$cdbe365d8c7d477d).clamp(this.pos + 100, -((items.childElementCount - 1) * 100), 0);
        items.style.marginTop = `${this.pos}px`;
        this.setTransition(items);
    }
    decrease() {
        let items = this.shadowRoot.getElementById("items");
        this.pos = (0, $736ca119f3df4efc$export$cdbe365d8c7d477d).clamp(this.pos + -100, -((items.childElementCount - 1) * 100), 0);
        items.style.marginTop = `${this.pos}px`;
        this.setTransition(items);
    }
    render() {
        return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`
            <button id="increase" @click="${this.increase}"></button>
            <div id="container">
            <div id="items">
                ${(this.items ? this.items : (0, $3df9fe8bd8bcdc7c$export$636b3443dac3eaf9)(this.min, this.max, this.step)).map((item, index)=>{
            return (0, $37260750aa7b368d$export$c0bb0b647f701bb5)`<h1>${item}</h1>`;
        })}
            </div>
            </div>
            <button id="decrease" @click="${this.decrease}"></button>
        `;
    }
};
$ea0819ddf412b59a$export$7dec0544e22d70df.styles = (0, $0e96f61157968e0c$export$8d80f9cac07cdb3)((0, (/*@__PURE__*/$parcel$interopDefault($4d9dd558b601a400$exports))));
$ea0819ddf412b59a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: String
    })
], $ea0819ddf412b59a$export$7dec0544e22d70df.prototype, "value", void 0);
$ea0819ddf412b59a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $ea0819ddf412b59a$export$7dec0544e22d70df.prototype, "min", void 0);
$ea0819ddf412b59a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $ea0819ddf412b59a$export$7dec0544e22d70df.prototype, "max", void 0);
$ea0819ddf412b59a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Number
    })
], $ea0819ddf412b59a$export$7dec0544e22d70df.prototype, "step", void 0);
$ea0819ddf412b59a$var$__decorate([
    (0, $5fa65b806545cdfc$export$d541bacb2bda4494)({
        type: Array
    })
], $ea0819ddf412b59a$export$7dec0544e22d70df.prototype, "items", void 0);
$ea0819ddf412b59a$export$7dec0544e22d70df = $ea0819ddf412b59a$var$__decorate([
    (0, $3f78cf6008406935$export$da64fc29f17f9d0e)("juel-spinner")
], $ea0819ddf412b59a$export$7dec0544e22d70df);




$(function() {
    (0, $88b1143c261b729c$export$af899be8b8440dd5)();
    (0, $d2e5bb9409e4cccd$export$81eb3b81d17ebff1)();
});


